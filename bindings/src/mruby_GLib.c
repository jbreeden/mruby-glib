/*
 * TODO: INCLUDES
 */

#include "mruby_GLib.h"

#ifdef __cplusplus
extern "C" {
#endif

#if BIND__g_log_fallback_handler_FUNCTION
#define _g_log_fallback_handler_REQUIRED_ARGC 4
#define _g_log_fallback_handler_OPTIONAL_ARGC 0
/* _g_log_fallback_handler
 *
 * Parameters:
 * - log_domain: const char *
 * - log_level: GLogLevelFlags
 * - message: const char *
 * - unused_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib__g_log_fallback_handler(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  mrb_int native_log_level;
  char * native_message = NULL;
  mrb_value unused_data;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!o", &native_log_domain, &native_log_level, &native_message, &unused_data);

  /* Type checking */
  TODO_type_check_void_PTR(unused_data);

  /* Unbox parameters */
  void * native_unused_data = TODO_mruby_unbox_void_PTR(unused_data);

  /* Invocation */
  _g_log_fallback_handler(native_log_domain, native_log_level, native_message, native_unused_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_access_FUNCTION
#define g_access_REQUIRED_ARGC 2
#define g_access_OPTIONAL_ARGC 0
/* g_access
 *
 * Parameters:
 * - filename: const char *
 * - mode: int
 * Return Type: int
 */
mrb_value
mrb_GLib_g_access(mrb_state* mrb, mrb_value self) {
  char * native_filename = NULL;
  mrb_int native_mode;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_filename, &native_mode);

  /* Invocation */
  int native_return_value = g_access(native_filename, native_mode);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_array_append_vals_FUNCTION
#define g_array_append_vals_REQUIRED_ARGC 3
#define g_array_append_vals_OPTIONAL_ARGC 0
/* g_array_append_vals
 *
 * Parameters:
 * - array: struct _GArray *
 * - data: const void *
 * - len: unsigned int
 * Return Type: GArray *
 */
mrb_value
mrb_GLib_g_array_append_vals(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value data;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &array, &data, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GArray * native_return_value = g_array_append_vals(native_array, native_data, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_array_free_FUNCTION
#define g_array_free_REQUIRED_ARGC 2
#define g_array_free_OPTIONAL_ARGC 0
/* g_array_free
 *
 * Parameters:
 * - array: struct _GArray *
 * - free_segment: int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_array_free(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_free_segment;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_free_segment);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  /* Invocation */
  gchar * native_return_value = g_array_free(native_array, native_free_segment);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_array_get_element_size_FUNCTION
#define g_array_get_element_size_REQUIRED_ARGC 1
#define g_array_get_element_size_OPTIONAL_ARGC 0
/* g_array_get_element_size
 *
 * Parameters:
 * - array: struct _GArray *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_array_get_element_size(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  /* Invocation */
  guint native_return_value = g_array_get_element_size(native_array);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_array_insert_vals_FUNCTION
#define g_array_insert_vals_REQUIRED_ARGC 4
#define g_array_insert_vals_OPTIONAL_ARGC 0
/* g_array_insert_vals
 *
 * Parameters:
 * - array: struct _GArray *
 * - index_: unsigned int
 * - data: const void *
 * - len: unsigned int
 * Return Type: GArray *
 */
mrb_value
mrb_GLib_g_array_insert_vals(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;
  mrb_value data;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oioi", &array, &native_index_, &data, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GArray * native_return_value = g_array_insert_vals(native_array, native_index_, native_data, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_array_new_FUNCTION
#define g_array_new_REQUIRED_ARGC 3
#define g_array_new_OPTIONAL_ARGC 0
/* g_array_new
 *
 * Parameters:
 * - zero_terminated: int
 * - clear_: int
 * - element_size: unsigned int
 * Return Type: GArray *
 */
mrb_value
mrb_GLib_g_array_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_zero_terminated;
  mrb_int native_clear_;
  mrb_int native_element_size;

  /* Fetch the args */
  mrb_get_args(mrb, "iii", &native_zero_terminated, &native_clear_, &native_element_size);

  /* Invocation */
  GArray * native_return_value = g_array_new(native_zero_terminated, native_clear_, native_element_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_array_prepend_vals_FUNCTION
#define g_array_prepend_vals_REQUIRED_ARGC 3
#define g_array_prepend_vals_OPTIONAL_ARGC 0
/* g_array_prepend_vals
 *
 * Parameters:
 * - array: struct _GArray *
 * - data: const void *
 * - len: unsigned int
 * Return Type: GArray *
 */
mrb_value
mrb_GLib_g_array_prepend_vals(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value data;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &array, &data, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GArray * native_return_value = g_array_prepend_vals(native_array, native_data, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_array_ref_FUNCTION
#define g_array_ref_REQUIRED_ARGC 1
#define g_array_ref_OPTIONAL_ARGC 0
/* g_array_ref
 *
 * Parameters:
 * - array: struct _GArray *
 * Return Type: GArray *
 */
mrb_value
mrb_GLib_g_array_ref(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  /* Invocation */
  GArray * native_return_value = g_array_ref(native_array);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_array_remove_index_FUNCTION
#define g_array_remove_index_REQUIRED_ARGC 2
#define g_array_remove_index_OPTIONAL_ARGC 0
/* g_array_remove_index
 *
 * Parameters:
 * - array: struct _GArray *
 * - index_: unsigned int
 * Return Type: GArray *
 */
mrb_value
mrb_GLib_g_array_remove_index(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_index_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  /* Invocation */
  GArray * native_return_value = g_array_remove_index(native_array, native_index_);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_array_remove_index_fast_FUNCTION
#define g_array_remove_index_fast_REQUIRED_ARGC 2
#define g_array_remove_index_fast_OPTIONAL_ARGC 0
/* g_array_remove_index_fast
 *
 * Parameters:
 * - array: struct _GArray *
 * - index_: unsigned int
 * Return Type: GArray *
 */
mrb_value
mrb_GLib_g_array_remove_index_fast(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_index_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  /* Invocation */
  GArray * native_return_value = g_array_remove_index_fast(native_array, native_index_);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_array_remove_range_FUNCTION
#define g_array_remove_range_REQUIRED_ARGC 3
#define g_array_remove_range_OPTIONAL_ARGC 0
/* g_array_remove_range
 *
 * Parameters:
 * - array: struct _GArray *
 * - index_: unsigned int
 * - length: unsigned int
 * Return Type: GArray *
 */
mrb_value
mrb_GLib_g_array_remove_range(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &array, &native_index_, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  /* Invocation */
  GArray * native_return_value = g_array_remove_range(native_array, native_index_, native_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_array_set_clear_func_FUNCTION
#define g_array_set_clear_func_REQUIRED_ARGC 2
#define g_array_set_clear_func_OPTIONAL_ARGC 0
/* g_array_set_clear_func
 *
 * Parameters:
 * - array: struct _GArray *
 * - clear_func: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_array_set_clear_func(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value clear_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &clear_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(clear_func);

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  void (*native_clear_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(clear_func);

  /* Invocation */
  g_array_set_clear_func(native_array, native_clear_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_array_set_size_FUNCTION
#define g_array_set_size_REQUIRED_ARGC 2
#define g_array_set_size_OPTIONAL_ARGC 0
/* g_array_set_size
 *
 * Parameters:
 * - array: struct _GArray *
 * - length: unsigned int
 * Return Type: GArray *
 */
mrb_value
mrb_GLib_g_array_set_size(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  /* Invocation */
  GArray * native_return_value = g_array_set_size(native_array, native_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_array_sized_new_FUNCTION
#define g_array_sized_new_REQUIRED_ARGC 4
#define g_array_sized_new_OPTIONAL_ARGC 0
/* g_array_sized_new
 *
 * Parameters:
 * - zero_terminated: int
 * - clear_: int
 * - element_size: unsigned int
 * - reserved_size: unsigned int
 * Return Type: GArray *
 */
mrb_value
mrb_GLib_g_array_sized_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_zero_terminated;
  mrb_int native_clear_;
  mrb_int native_element_size;
  mrb_int native_reserved_size;

  /* Fetch the args */
  mrb_get_args(mrb, "iiii", &native_zero_terminated, &native_clear_, &native_element_size, &native_reserved_size);

  /* Invocation */
  GArray * native_return_value = g_array_sized_new(native_zero_terminated, native_clear_, native_element_size, native_reserved_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_array_sort_FUNCTION
#define g_array_sort_REQUIRED_ARGC 2
#define g_array_sort_OPTIONAL_ARGC 0
/* g_array_sort
 *
 * Parameters:
 * - array: struct _GArray *
 * - compare_func: int (*)(const void *, const void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_array_sort(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value compare_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &compare_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(compare_func);

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  int (*native_compare_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(compare_func);

  /* Invocation */
  g_array_sort(native_array, native_compare_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_array_sort_with_data_FUNCTION
#define g_array_sort_with_data_REQUIRED_ARGC 3
#define g_array_sort_with_data_OPTIONAL_ARGC 0
/* g_array_sort_with_data
 *
 * Parameters:
 * - array: struct _GArray *
 * - compare_func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_array_sort_with_data(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value compare_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &array, &compare_func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  int (*native_compare_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_array_sort_with_data(native_array, native_compare_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_array_unref_FUNCTION
#define g_array_unref_REQUIRED_ARGC 1
#define g_array_unref_OPTIONAL_ARGC 0
/* g_array_unref
 *
 * Parameters:
 * - array: struct _GArray *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_array_unref(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GArray(array));

  /* Invocation */
  g_array_unref(native_array);

  return mrb_nil_value();
}
#endif

#if BIND_g_ascii_digit_value_FUNCTION
#define g_ascii_digit_value_REQUIRED_ARGC 1
#define g_ascii_digit_value_OPTIONAL_ARGC 0
/* g_ascii_digit_value
 *
 * Parameters:
 * - c: char
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_ascii_digit_value(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gint native_return_value = g_ascii_digit_value(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ascii_dtostr_FUNCTION
#define g_ascii_dtostr_REQUIRED_ARGC 3
#define g_ascii_dtostr_OPTIONAL_ARGC 0
/* g_ascii_dtostr
 *
 * Parameters:
 * - buffer: char *
 * - buf_len: int
 * - d: double
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_ascii_dtostr(mrb_state* mrb, mrb_value self) {
  char * buffer = NULL;
  mrb_int native_buf_len;
  double native_d;

  /* Fetch the args */
  mrb_get_args(mrb, "z!if", &buffer, &native_buf_len, &native_d);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_buffer = strdup(buffer);

  /* Invocation */
  gchar * native_return_value = g_ascii_dtostr(native_buffer, native_buf_len, native_d);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_buffer);
  native_buffer = NULL;

  return return_value;
}
#endif

#if BIND_g_ascii_formatd_FUNCTION
#define g_ascii_formatd_REQUIRED_ARGC 4
#define g_ascii_formatd_OPTIONAL_ARGC 0
/* g_ascii_formatd
 *
 * Parameters:
 * - buffer: char *
 * - buf_len: int
 * - format: const char *
 * - d: double
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_ascii_formatd(mrb_state* mrb, mrb_value self) {
  char * buffer = NULL;
  mrb_int native_buf_len;
  char * native_format = NULL;
  double native_d;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!f", &buffer, &native_buf_len, &native_format, &native_d);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_buffer = strdup(buffer);

  /* Invocation */
  gchar * native_return_value = g_ascii_formatd(native_buffer, native_buf_len, native_format, native_d);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_buffer);
  native_buffer = NULL;

  return return_value;
}
#endif

#if BIND_g_ascii_strcasecmp_FUNCTION
#define g_ascii_strcasecmp_REQUIRED_ARGC 2
#define g_ascii_strcasecmp_OPTIONAL_ARGC 0
/* g_ascii_strcasecmp
 *
 * Parameters:
 * - s1: const char *
 * - s2: const char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_ascii_strcasecmp(mrb_state* mrb, mrb_value self) {
  char * native_s1 = NULL;
  char * native_s2 = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_s1, &native_s2);

  /* Invocation */
  gint native_return_value = g_ascii_strcasecmp(native_s1, native_s2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ascii_strdown_FUNCTION
#define g_ascii_strdown_REQUIRED_ARGC 2
#define g_ascii_strdown_OPTIONAL_ARGC 0
/* g_ascii_strdown
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_ascii_strdown(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_str, &native_len);

  /* Invocation */
  gchar * native_return_value = g_ascii_strdown(native_str, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ascii_strncasecmp_FUNCTION
#define g_ascii_strncasecmp_REQUIRED_ARGC 3
#define g_ascii_strncasecmp_OPTIONAL_ARGC 0
/* g_ascii_strncasecmp
 *
 * Parameters:
 * - s1: const char *
 * - s2: const char *
 * - n: unsigned long
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_ascii_strncasecmp(mrb_state* mrb, mrb_value self) {
  char * native_s1 = NULL;
  char * native_s2 = NULL;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &native_s1, &native_s2, &native_n);

  /* Invocation */
  gint native_return_value = g_ascii_strncasecmp(native_s1, native_s2, native_n);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ascii_strtod_FUNCTION
#define g_ascii_strtod_REQUIRED_ARGC 2
#define g_ascii_strtod_OPTIONAL_ARGC 0
/* g_ascii_strtod
 *
 * Parameters:
 * - nptr: const char *
 * - endptr: char **
 * Return Type: gdouble
 */
mrb_value
mrb_GLib_g_ascii_strtod(mrb_state* mrb, mrb_value self) {
  char * native_nptr = NULL;
  mrb_value endptr;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_nptr, &endptr);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(endptr);

  /* Unbox parameters */
  char ** native_endptr = TODO_mruby_unbox_char_PTR_PTR(endptr);

  /* Invocation */
  gdouble native_return_value = g_ascii_strtod(native_nptr, native_endptr);

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ascii_strtoll_FUNCTION
#define g_ascii_strtoll_REQUIRED_ARGC 3
#define g_ascii_strtoll_OPTIONAL_ARGC 0
/* g_ascii_strtoll
 *
 * Parameters:
 * - nptr: const char *
 * - endptr: char **
 * - base: unsigned int
 * Return Type: gint64
 */
mrb_value
mrb_GLib_g_ascii_strtoll(mrb_state* mrb, mrb_value self) {
  char * native_nptr = NULL;
  mrb_value endptr;
  mrb_int native_base;

  /* Fetch the args */
  mrb_get_args(mrb, "z!oi", &native_nptr, &endptr, &native_base);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(endptr);

  /* Unbox parameters */
  char ** native_endptr = TODO_mruby_unbox_char_PTR_PTR(endptr);

  /* Invocation */
  gint64 native_return_value = g_ascii_strtoll(native_nptr, native_endptr, native_base);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint64(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ascii_strtoull_FUNCTION
#define g_ascii_strtoull_REQUIRED_ARGC 3
#define g_ascii_strtoull_OPTIONAL_ARGC 0
/* g_ascii_strtoull
 *
 * Parameters:
 * - nptr: const char *
 * - endptr: char **
 * - base: unsigned int
 * Return Type: guint64
 */
mrb_value
mrb_GLib_g_ascii_strtoull(mrb_state* mrb, mrb_value self) {
  char * native_nptr = NULL;
  mrb_value endptr;
  mrb_int native_base;

  /* Fetch the args */
  mrb_get_args(mrb, "z!oi", &native_nptr, &endptr, &native_base);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(endptr);

  /* Unbox parameters */
  char ** native_endptr = TODO_mruby_unbox_char_PTR_PTR(endptr);

  /* Invocation */
  guint64 native_return_value = g_ascii_strtoull(native_nptr, native_endptr, native_base);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint64(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ascii_strup_FUNCTION
#define g_ascii_strup_REQUIRED_ARGC 2
#define g_ascii_strup_OPTIONAL_ARGC 0
/* g_ascii_strup
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_ascii_strup(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_str, &native_len);

  /* Invocation */
  gchar * native_return_value = g_ascii_strup(native_str, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ascii_tolower_FUNCTION
#define g_ascii_tolower_REQUIRED_ARGC 1
#define g_ascii_tolower_OPTIONAL_ARGC 0
/* g_ascii_tolower
 *
 * Parameters:
 * - c: char
 * Return Type: gchar
 */
mrb_value
mrb_GLib_g_ascii_tolower(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gchar native_return_value = g_ascii_tolower(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ascii_toupper_FUNCTION
#define g_ascii_toupper_REQUIRED_ARGC 1
#define g_ascii_toupper_OPTIONAL_ARGC 0
/* g_ascii_toupper
 *
 * Parameters:
 * - c: char
 * Return Type: gchar
 */
mrb_value
mrb_GLib_g_ascii_toupper(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gchar native_return_value = g_ascii_toupper(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ascii_xdigit_value_FUNCTION
#define g_ascii_xdigit_value_REQUIRED_ARGC 1
#define g_ascii_xdigit_value_OPTIONAL_ARGC 0
/* g_ascii_xdigit_value
 *
 * Parameters:
 * - c: char
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_ascii_xdigit_value(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gint native_return_value = g_ascii_xdigit_value(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_assert_warning_FUNCTION
#define g_assert_warning_REQUIRED_ARGC 5
#define g_assert_warning_OPTIONAL_ARGC 0
/* g_assert_warning
 *
 * Parameters:
 * - log_domain: const char *
 * - file: const char *
 * - line: const int
 * - pretty_function: const char *
 * - expression: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_assert_warning(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  char * native_file = NULL;
  mrb_int native_line;
  char * native_pretty_function = NULL;
  char * native_expression = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!iz!z!", &native_log_domain, &native_file, &native_line, &native_pretty_function, &native_expression);

  /* Invocation */
  g_assert_warning(native_log_domain, native_file, native_line, native_pretty_function, native_expression);

  return mrb_nil_value();
}
#endif

#if BIND_g_assertion_message_FUNCTION
#define g_assertion_message_REQUIRED_ARGC 5
#define g_assertion_message_OPTIONAL_ARGC 0
/* g_assertion_message
 *
 * Parameters:
 * - domain: const char *
 * - file: const char *
 * - line: int
 * - func: const char *
 * - message: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_assertion_message(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_file = NULL;
  mrb_int native_line;
  char * native_func = NULL;
  char * native_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!iz!z!", &native_domain, &native_file, &native_line, &native_func, &native_message);

  /* Invocation */
  g_assertion_message(native_domain, native_file, native_line, native_func, native_message);

  return mrb_nil_value();
}
#endif

#if BIND_g_assertion_message_cmpnum_FUNCTION
#define g_assertion_message_cmpnum_REQUIRED_ARGC 9
#define g_assertion_message_cmpnum_OPTIONAL_ARGC 0
/* g_assertion_message_cmpnum
 *
 * Parameters:
 * - domain: const char *
 * - file: const char *
 * - line: int
 * - func: const char *
 * - expr: const char *
 * - arg1: long double
 * - cmp: const char *
 * - arg2: long double
 * - numtype: char
 * Return Type: void
 */
mrb_value
mrb_GLib_g_assertion_message_cmpnum(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_file = NULL;
  mrb_int native_line;
  char * native_func = NULL;
  char * native_expr = NULL;
  mrb_value arg1;
  char * native_cmp = NULL;
  mrb_value arg2;
  mrb_int native_numtype;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!iz!z!oz!oi", &native_domain, &native_file, &native_line, &native_func, &native_expr, &arg1, &native_cmp, &arg2, &native_numtype);

  /* Type checking */
  TODO_type_check_long_double(arg1);
  TODO_type_check_long_double(arg2);

  /* Unbox parameters */
  long double native_arg1 = TODO_mruby_unbox_long_double(arg1);

  long double native_arg2 = TODO_mruby_unbox_long_double(arg2);

  /* Invocation */
  g_assertion_message_cmpnum(native_domain, native_file, native_line, native_func, native_expr, native_arg1, native_cmp, native_arg2, native_numtype);

  return mrb_nil_value();
}
#endif

#if BIND_g_assertion_message_cmpstr_FUNCTION
#define g_assertion_message_cmpstr_REQUIRED_ARGC 8
#define g_assertion_message_cmpstr_OPTIONAL_ARGC 0
/* g_assertion_message_cmpstr
 *
 * Parameters:
 * - domain: const char *
 * - file: const char *
 * - line: int
 * - func: const char *
 * - expr: const char *
 * - arg1: const char *
 * - cmp: const char *
 * - arg2: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_assertion_message_cmpstr(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_file = NULL;
  mrb_int native_line;
  char * native_func = NULL;
  char * native_expr = NULL;
  char * native_arg1 = NULL;
  char * native_cmp = NULL;
  char * native_arg2 = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!iz!z!z!z!z!", &native_domain, &native_file, &native_line, &native_func, &native_expr, &native_arg1, &native_cmp, &native_arg2);

  /* Invocation */
  g_assertion_message_cmpstr(native_domain, native_file, native_line, native_func, native_expr, native_arg1, native_cmp, native_arg2);

  return mrb_nil_value();
}
#endif

#if BIND_g_assertion_message_error_FUNCTION
#define g_assertion_message_error_REQUIRED_ARGC 8
#define g_assertion_message_error_OPTIONAL_ARGC 0
/* g_assertion_message_error
 *
 * Parameters:
 * - domain: const char *
 * - file: const char *
 * - line: int
 * - func: const char *
 * - expr: const char *
 * - error: const struct _GError *
 * - error_domain: unsigned int
 * - error_code: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_assertion_message_error(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_file = NULL;
  mrb_int native_line;
  char * native_func = NULL;
  char * native_expr = NULL;
  mrb_value error;
  mrb_int native_error_domain;
  mrb_int native_error_code;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!iz!z!oii", &native_domain, &native_file, &native_line, &native_func, &native_expr, &error, &native_error_domain, &native_error_code);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, error, GError_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GError expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GError * native_error = (mrb_nil_p(error) ? NULL : mruby_unbox__GError(error));

  /* Invocation */
  g_assertion_message_error(native_domain, native_file, native_line, native_func, native_expr, native_error, native_error_domain, native_error_code);

  return mrb_nil_value();
}
#endif

#if BIND_g_assertion_message_expr_FUNCTION
#define g_assertion_message_expr_REQUIRED_ARGC 5
#define g_assertion_message_expr_OPTIONAL_ARGC 0
/* g_assertion_message_expr
 *
 * Parameters:
 * - domain: const char *
 * - file: const char *
 * - line: int
 * - func: const char *
 * - expr: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_assertion_message_expr(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_file = NULL;
  mrb_int native_line;
  char * native_func = NULL;
  char * native_expr = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!iz!z!", &native_domain, &native_file, &native_line, &native_func, &native_expr);

  /* Invocation */
  g_assertion_message_expr(native_domain, native_file, native_line, native_func, native_expr);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_length_FUNCTION
#define g_async_queue_length_REQUIRED_ARGC 1
#define g_async_queue_length_OPTIONAL_ARGC 0
/* g_async_queue_length
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_async_queue_length(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  gint native_return_value = g_async_queue_length(native_queue);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_length_unlocked_FUNCTION
#define g_async_queue_length_unlocked_REQUIRED_ARGC 1
#define g_async_queue_length_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_length_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_async_queue_length_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  gint native_return_value = g_async_queue_length_unlocked(native_queue);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_lock_FUNCTION
#define g_async_queue_lock_REQUIRED_ARGC 1
#define g_async_queue_lock_OPTIONAL_ARGC 0
/* g_async_queue_lock
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_lock(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  g_async_queue_lock(native_queue);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_new_FUNCTION
#define g_async_queue_new_REQUIRED_ARGC 0
#define g_async_queue_new_OPTIONAL_ARGC 0
/* g_async_queue_new
 *
 * Parameters: None
 * Return Type: GAsyncQueue *
 */
mrb_value
mrb_GLib_g_async_queue_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GAsyncQueue * native_return_value = g_async_queue_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GAsyncQueue(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_async_queue_new_full_FUNCTION
#define g_async_queue_new_full_REQUIRED_ARGC 1
#define g_async_queue_new_full_OPTIONAL_ARGC 0
/* g_async_queue_new_full
 *
 * Parameters:
 * - item_free_func: void (*)(void *)
 * Return Type: GAsyncQueue *
 */
mrb_value
mrb_GLib_g_async_queue_new_full(mrb_state* mrb, mrb_value self) {
  mrb_value item_free_func;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &item_free_func);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(item_free_func);

  /* Unbox parameters */
  void (*native_item_free_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(item_free_func);

  /* Invocation */
  GAsyncQueue * native_return_value = g_async_queue_new_full(native_item_free_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GAsyncQueue(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_async_queue_pop_FUNCTION
#define g_async_queue_pop_REQUIRED_ARGC 1
#define g_async_queue_pop_OPTIONAL_ARGC 0
/* g_async_queue_pop
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_async_queue_pop(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_async_queue_pop(native_queue);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_pop_unlocked_FUNCTION
#define g_async_queue_pop_unlocked_REQUIRED_ARGC 1
#define g_async_queue_pop_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_pop_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_async_queue_pop_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_async_queue_pop_unlocked(native_queue);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_push_FUNCTION
#define g_async_queue_push_REQUIRED_ARGC 2
#define g_async_queue_push_OPTIONAL_ARGC 0
/* g_async_queue_push
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_push(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_async_queue_push(native_queue, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_push_front_FUNCTION
#define g_async_queue_push_front_REQUIRED_ARGC 2
#define g_async_queue_push_front_OPTIONAL_ARGC 0
/* g_async_queue_push_front
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - item: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_push_front(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value item;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &item);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(item);

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  void * native_item = TODO_mruby_unbox_void_PTR(item);

  /* Invocation */
  g_async_queue_push_front(native_queue, native_item);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_push_front_unlocked_FUNCTION
#define g_async_queue_push_front_unlocked_REQUIRED_ARGC 2
#define g_async_queue_push_front_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_push_front_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - item: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_push_front_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value item;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &item);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(item);

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  void * native_item = TODO_mruby_unbox_void_PTR(item);

  /* Invocation */
  g_async_queue_push_front_unlocked(native_queue, native_item);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_push_sorted_FUNCTION
#define g_async_queue_push_sorted_REQUIRED_ARGC 4
#define g_async_queue_push_sorted_OPTIONAL_ARGC 0
/* g_async_queue_push_sorted
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - data: void *
 * - func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_push_sorted(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &queue, &data, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_async_queue_push_sorted(native_queue, native_data, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_push_sorted_unlocked_FUNCTION
#define g_async_queue_push_sorted_unlocked_REQUIRED_ARGC 4
#define g_async_queue_push_sorted_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_push_sorted_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - data: void *
 * - func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_push_sorted_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &queue, &data, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_async_queue_push_sorted_unlocked(native_queue, native_data, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_push_unlocked_FUNCTION
#define g_async_queue_push_unlocked_REQUIRED_ARGC 2
#define g_async_queue_push_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_push_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_push_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_async_queue_push_unlocked(native_queue, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_ref_FUNCTION
#define g_async_queue_ref_REQUIRED_ARGC 1
#define g_async_queue_ref_OPTIONAL_ARGC 0
/* g_async_queue_ref
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: GAsyncQueue *
 */
mrb_value
mrb_GLib_g_async_queue_ref(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  GAsyncQueue * native_return_value = g_async_queue_ref(native_queue);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GAsyncQueue(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_async_queue_ref_unlocked_FUNCTION
#define g_async_queue_ref_unlocked_REQUIRED_ARGC 1
#define g_async_queue_ref_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_ref_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_ref_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  g_async_queue_ref_unlocked(native_queue);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_remove_FUNCTION
#define g_async_queue_remove_REQUIRED_ARGC 2
#define g_async_queue_remove_OPTIONAL_ARGC 0
/* g_async_queue_remove
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - item: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_async_queue_remove(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value item;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &item);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(item);

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  void * native_item = TODO_mruby_unbox_void_PTR(item);

  /* Invocation */
  gboolean native_return_value = g_async_queue_remove(native_queue, native_item);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_remove_unlocked_FUNCTION
#define g_async_queue_remove_unlocked_REQUIRED_ARGC 2
#define g_async_queue_remove_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_remove_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - item: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_async_queue_remove_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value item;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &item);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(item);

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  void * native_item = TODO_mruby_unbox_void_PTR(item);

  /* Invocation */
  gboolean native_return_value = g_async_queue_remove_unlocked(native_queue, native_item);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_sort_FUNCTION
#define g_async_queue_sort_REQUIRED_ARGC 3
#define g_async_queue_sort_OPTIONAL_ARGC 0
/* g_async_queue_sort
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_sort(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &queue, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  int (*native_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_async_queue_sort(native_queue, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_sort_unlocked_FUNCTION
#define g_async_queue_sort_unlocked_REQUIRED_ARGC 3
#define g_async_queue_sort_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_sort_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_sort_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &queue, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  int (*native_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_async_queue_sort_unlocked(native_queue, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_timed_pop_FUNCTION
#define g_async_queue_timed_pop_REQUIRED_ARGC 2
#define g_async_queue_timed_pop_OPTIONAL_ARGC 0
/* g_async_queue_timed_pop
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - end_time: struct _GTimeVal *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_async_queue_timed_pop(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value end_time;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &end_time);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, end_time, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  struct _GTimeVal * native_end_time = (mrb_nil_p(end_time) ? NULL : mruby_unbox__GTimeVal(end_time));

  /* Invocation */
  gpointer native_return_value = g_async_queue_timed_pop(native_queue, native_end_time);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_timed_pop_unlocked_FUNCTION
#define g_async_queue_timed_pop_unlocked_REQUIRED_ARGC 2
#define g_async_queue_timed_pop_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_timed_pop_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - end_time: struct _GTimeVal *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_async_queue_timed_pop_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value end_time;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &end_time);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, end_time, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  struct _GTimeVal * native_end_time = (mrb_nil_p(end_time) ? NULL : mruby_unbox__GTimeVal(end_time));

  /* Invocation */
  gpointer native_return_value = g_async_queue_timed_pop_unlocked(native_queue, native_end_time);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_timeout_pop_FUNCTION
#define g_async_queue_timeout_pop_REQUIRED_ARGC 2
#define g_async_queue_timeout_pop_OPTIONAL_ARGC 0
/* g_async_queue_timeout_pop
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - timeout: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_async_queue_timeout_pop(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_int native_timeout;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &queue, &native_timeout);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_async_queue_timeout_pop(native_queue, native_timeout);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_timeout_pop_unlocked_FUNCTION
#define g_async_queue_timeout_pop_unlocked_REQUIRED_ARGC 2
#define g_async_queue_timeout_pop_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_timeout_pop_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * - timeout: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_async_queue_timeout_pop_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_int native_timeout;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &queue, &native_timeout);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_async_queue_timeout_pop_unlocked(native_queue, native_timeout);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_try_pop_FUNCTION
#define g_async_queue_try_pop_REQUIRED_ARGC 1
#define g_async_queue_try_pop_OPTIONAL_ARGC 0
/* g_async_queue_try_pop
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_async_queue_try_pop(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_async_queue_try_pop(native_queue);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_try_pop_unlocked_FUNCTION
#define g_async_queue_try_pop_unlocked_REQUIRED_ARGC 1
#define g_async_queue_try_pop_unlocked_OPTIONAL_ARGC 0
/* g_async_queue_try_pop_unlocked
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_async_queue_try_pop_unlocked(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_async_queue_try_pop_unlocked(native_queue);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_async_queue_unlock_FUNCTION
#define g_async_queue_unlock_REQUIRED_ARGC 1
#define g_async_queue_unlock_OPTIONAL_ARGC 0
/* g_async_queue_unlock
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_unlock(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  g_async_queue_unlock(native_queue);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_unref_FUNCTION
#define g_async_queue_unref_REQUIRED_ARGC 1
#define g_async_queue_unref_OPTIONAL_ARGC 0
/* g_async_queue_unref
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_unref(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  g_async_queue_unref(native_queue);

  return mrb_nil_value();
}
#endif

#if BIND_g_async_queue_unref_and_unlock_FUNCTION
#define g_async_queue_unref_and_unlock_REQUIRED_ARGC 1
#define g_async_queue_unref_and_unlock_OPTIONAL_ARGC 0
/* g_async_queue_unref_and_unlock
 *
 * Parameters:
 * - queue: struct _GAsyncQueue *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_async_queue_unref_and_unlock(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GAsyncQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GAsyncQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GAsyncQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GAsyncQueue(queue));

  /* Invocation */
  g_async_queue_unref_and_unlock(native_queue);

  return mrb_nil_value();
}
#endif

#if BIND_g_atexit_FUNCTION
#define g_atexit_REQUIRED_ARGC 1
#define g_atexit_OPTIONAL_ARGC 0
/* g_atexit
 *
 * Parameters:
 * - func: void (*)(void)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_atexit(mrb_state* mrb, mrb_value self) {
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &func);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_RPAREN(func);

  /* Unbox parameters */
  void (*native_func)(void) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_RPAREN(func);

  /* Invocation */
  g_atexit(native_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_atomic_int_add_FUNCTION
#define g_atomic_int_add_REQUIRED_ARGC 2
#define g_atomic_int_add_OPTIONAL_ARGC 0
/* g_atomic_int_add
 *
 * Parameters:
 * - atomic: volatile int *
 * - val: int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_atomic_int_add(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_val;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &atomic, &native_val);

  /* Type checking */
  TODO_type_check_volatile_int_PTR(atomic);

  /* Unbox parameters */
  volatile int * native_atomic = TODO_mruby_unbox_volatile_int_PTR(atomic);

  /* Invocation */
  gint native_return_value = g_atomic_int_add(native_atomic, native_val);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_int_and_FUNCTION
#define g_atomic_int_and_REQUIRED_ARGC 2
#define g_atomic_int_and_OPTIONAL_ARGC 0
/* g_atomic_int_and
 *
 * Parameters:
 * - atomic: volatile unsigned int *
 * - val: unsigned int
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_atomic_int_and(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_val;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &atomic, &native_val);

  /* Type checking */
  TODO_type_check_volatile_unsigned_int_PTR(atomic);

  /* Unbox parameters */
  volatile unsigned int * native_atomic = TODO_mruby_unbox_volatile_unsigned_int_PTR(atomic);

  /* Invocation */
  guint native_return_value = g_atomic_int_and(native_atomic, native_val);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_int_compare_and_exchange_FUNCTION
#define g_atomic_int_compare_and_exchange_REQUIRED_ARGC 3
#define g_atomic_int_compare_and_exchange_OPTIONAL_ARGC 0
/* g_atomic_int_compare_and_exchange
 *
 * Parameters:
 * - atomic: volatile int *
 * - oldval: int
 * - newval: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_atomic_int_compare_and_exchange(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_oldval;
  mrb_int native_newval;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &atomic, &native_oldval, &native_newval);

  /* Type checking */
  TODO_type_check_volatile_int_PTR(atomic);

  /* Unbox parameters */
  volatile int * native_atomic = TODO_mruby_unbox_volatile_int_PTR(atomic);

  /* Invocation */
  gboolean native_return_value = g_atomic_int_compare_and_exchange(native_atomic, native_oldval, native_newval);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_int_dec_and_test_FUNCTION
#define g_atomic_int_dec_and_test_REQUIRED_ARGC 1
#define g_atomic_int_dec_and_test_OPTIONAL_ARGC 0
/* g_atomic_int_dec_and_test
 *
 * Parameters:
 * - atomic: volatile int *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_atomic_int_dec_and_test(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &atomic);

  /* Type checking */
  TODO_type_check_volatile_int_PTR(atomic);

  /* Unbox parameters */
  volatile int * native_atomic = TODO_mruby_unbox_volatile_int_PTR(atomic);

  /* Invocation */
  gboolean native_return_value = g_atomic_int_dec_and_test(native_atomic);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_int_exchange_and_add_FUNCTION
#define g_atomic_int_exchange_and_add_REQUIRED_ARGC 2
#define g_atomic_int_exchange_and_add_OPTIONAL_ARGC 0
/* g_atomic_int_exchange_and_add
 *
 * Parameters:
 * - atomic: volatile int *
 * - val: int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_atomic_int_exchange_and_add(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_val;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &atomic, &native_val);

  /* Type checking */
  TODO_type_check_volatile_int_PTR(atomic);

  /* Unbox parameters */
  volatile int * native_atomic = TODO_mruby_unbox_volatile_int_PTR(atomic);

  /* Invocation */
  gint native_return_value = g_atomic_int_exchange_and_add(native_atomic, native_val);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_int_get_FUNCTION
#define g_atomic_int_get_REQUIRED_ARGC 1
#define g_atomic_int_get_OPTIONAL_ARGC 0
/* g_atomic_int_get
 *
 * Parameters:
 * - atomic: const volatile int *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_atomic_int_get(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &atomic);

  /* Type checking */
  TODO_type_check_volatile_int_PTR(atomic);

  /* Unbox parameters */
  const volatile int * native_atomic = TODO_mruby_unbox_volatile_int_PTR(atomic);

  /* Invocation */
  gint native_return_value = g_atomic_int_get(native_atomic);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_int_inc_FUNCTION
#define g_atomic_int_inc_REQUIRED_ARGC 1
#define g_atomic_int_inc_OPTIONAL_ARGC 0
/* g_atomic_int_inc
 *
 * Parameters:
 * - atomic: volatile int *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_atomic_int_inc(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &atomic);

  /* Type checking */
  TODO_type_check_volatile_int_PTR(atomic);

  /* Unbox parameters */
  volatile int * native_atomic = TODO_mruby_unbox_volatile_int_PTR(atomic);

  /* Invocation */
  g_atomic_int_inc(native_atomic);

  return mrb_nil_value();
}
#endif

#if BIND_g_atomic_int_or_FUNCTION
#define g_atomic_int_or_REQUIRED_ARGC 2
#define g_atomic_int_or_OPTIONAL_ARGC 0
/* g_atomic_int_or
 *
 * Parameters:
 * - atomic: volatile unsigned int *
 * - val: unsigned int
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_atomic_int_or(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_val;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &atomic, &native_val);

  /* Type checking */
  TODO_type_check_volatile_unsigned_int_PTR(atomic);

  /* Unbox parameters */
  volatile unsigned int * native_atomic = TODO_mruby_unbox_volatile_unsigned_int_PTR(atomic);

  /* Invocation */
  guint native_return_value = g_atomic_int_or(native_atomic, native_val);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_int_set_FUNCTION
#define g_atomic_int_set_REQUIRED_ARGC 2
#define g_atomic_int_set_OPTIONAL_ARGC 0
/* g_atomic_int_set
 *
 * Parameters:
 * - atomic: volatile int *
 * - newval: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_atomic_int_set(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_newval;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &atomic, &native_newval);

  /* Type checking */
  TODO_type_check_volatile_int_PTR(atomic);

  /* Unbox parameters */
  volatile int * native_atomic = TODO_mruby_unbox_volatile_int_PTR(atomic);

  /* Invocation */
  g_atomic_int_set(native_atomic, native_newval);

  return mrb_nil_value();
}
#endif

#if BIND_g_atomic_int_xor_FUNCTION
#define g_atomic_int_xor_REQUIRED_ARGC 2
#define g_atomic_int_xor_OPTIONAL_ARGC 0
/* g_atomic_int_xor
 *
 * Parameters:
 * - atomic: volatile unsigned int *
 * - val: unsigned int
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_atomic_int_xor(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_val;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &atomic, &native_val);

  /* Type checking */
  TODO_type_check_volatile_unsigned_int_PTR(atomic);

  /* Unbox parameters */
  volatile unsigned int * native_atomic = TODO_mruby_unbox_volatile_unsigned_int_PTR(atomic);

  /* Invocation */
  guint native_return_value = g_atomic_int_xor(native_atomic, native_val);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_pointer_add_FUNCTION
#define g_atomic_pointer_add_REQUIRED_ARGC 2
#define g_atomic_pointer_add_OPTIONAL_ARGC 0
/* g_atomic_pointer_add
 *
 * Parameters:
 * - atomic: volatile void *
 * - val: long
 * Return Type: gssize
 */
mrb_value
mrb_GLib_g_atomic_pointer_add(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_val;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &atomic, &native_val);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(atomic);

  /* Unbox parameters */
  volatile void * native_atomic = TODO_mruby_unbox_volatile_void_PTR(atomic);

  /* Invocation */
  gssize native_return_value = g_atomic_pointer_add(native_atomic, native_val);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gssize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_pointer_and_FUNCTION
#define g_atomic_pointer_and_REQUIRED_ARGC 2
#define g_atomic_pointer_and_OPTIONAL_ARGC 0
/* g_atomic_pointer_and
 *
 * Parameters:
 * - atomic: volatile void *
 * - val: unsigned long
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_atomic_pointer_and(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_val;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &atomic, &native_val);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(atomic);

  /* Unbox parameters */
  volatile void * native_atomic = TODO_mruby_unbox_volatile_void_PTR(atomic);

  /* Invocation */
  gsize native_return_value = g_atomic_pointer_and(native_atomic, native_val);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_pointer_compare_and_exchange_FUNCTION
#define g_atomic_pointer_compare_and_exchange_REQUIRED_ARGC 3
#define g_atomic_pointer_compare_and_exchange_OPTIONAL_ARGC 0
/* g_atomic_pointer_compare_and_exchange
 *
 * Parameters:
 * - atomic: volatile void *
 * - oldval: void *
 * - newval: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_atomic_pointer_compare_and_exchange(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_value oldval;
  mrb_value newval;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &atomic, &oldval, &newval);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(atomic);
  TODO_type_check_void_PTR(oldval);
  TODO_type_check_void_PTR(newval);

  /* Unbox parameters */
  volatile void * native_atomic = TODO_mruby_unbox_volatile_void_PTR(atomic);

  void * native_oldval = TODO_mruby_unbox_void_PTR(oldval);

  void * native_newval = TODO_mruby_unbox_void_PTR(newval);

  /* Invocation */
  gboolean native_return_value = g_atomic_pointer_compare_and_exchange(native_atomic, native_oldval, native_newval);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_pointer_get_FUNCTION
#define g_atomic_pointer_get_REQUIRED_ARGC 1
#define g_atomic_pointer_get_OPTIONAL_ARGC 0
/* g_atomic_pointer_get
 *
 * Parameters:
 * - atomic: const volatile void *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_atomic_pointer_get(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &atomic);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(atomic);

  /* Unbox parameters */
  const volatile void * native_atomic = TODO_mruby_unbox_volatile_void_PTR(atomic);

  /* Invocation */
  gpointer native_return_value = g_atomic_pointer_get(native_atomic);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_pointer_or_FUNCTION
#define g_atomic_pointer_or_REQUIRED_ARGC 2
#define g_atomic_pointer_or_OPTIONAL_ARGC 0
/* g_atomic_pointer_or
 *
 * Parameters:
 * - atomic: volatile void *
 * - val: unsigned long
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_atomic_pointer_or(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_val;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &atomic, &native_val);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(atomic);

  /* Unbox parameters */
  volatile void * native_atomic = TODO_mruby_unbox_volatile_void_PTR(atomic);

  /* Invocation */
  gsize native_return_value = g_atomic_pointer_or(native_atomic, native_val);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_atomic_pointer_set_FUNCTION
#define g_atomic_pointer_set_REQUIRED_ARGC 2
#define g_atomic_pointer_set_OPTIONAL_ARGC 0
/* g_atomic_pointer_set
 *
 * Parameters:
 * - atomic: volatile void *
 * - newval: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_atomic_pointer_set(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_value newval;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &atomic, &newval);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(atomic);
  TODO_type_check_void_PTR(newval);

  /* Unbox parameters */
  volatile void * native_atomic = TODO_mruby_unbox_volatile_void_PTR(atomic);

  void * native_newval = TODO_mruby_unbox_void_PTR(newval);

  /* Invocation */
  g_atomic_pointer_set(native_atomic, native_newval);

  return mrb_nil_value();
}
#endif

#if BIND_g_atomic_pointer_xor_FUNCTION
#define g_atomic_pointer_xor_REQUIRED_ARGC 2
#define g_atomic_pointer_xor_OPTIONAL_ARGC 0
/* g_atomic_pointer_xor
 *
 * Parameters:
 * - atomic: volatile void *
 * - val: unsigned long
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_atomic_pointer_xor(mrb_state* mrb, mrb_value self) {
  mrb_value atomic;
  mrb_int native_val;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &atomic, &native_val);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(atomic);

  /* Unbox parameters */
  volatile void * native_atomic = TODO_mruby_unbox_volatile_void_PTR(atomic);

  /* Invocation */
  gsize native_return_value = g_atomic_pointer_xor(native_atomic, native_val);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_base64_decode_FUNCTION
#define g_base64_decode_REQUIRED_ARGC 2
#define g_base64_decode_OPTIONAL_ARGC 0
/* g_base64_decode
 *
 * Parameters:
 * - text: const char *
 * - out_len: unsigned long *
 * Return Type: guchar *
 */
mrb_value
mrb_GLib_g_base64_decode(mrb_state* mrb, mrb_value self) {
  char * native_text = NULL;
  mrb_value out_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_text, &out_len);

  /* Type checking */
  TODO_type_check_unsigned_long_PTR(out_len);

  /* Unbox parameters */
  unsigned long * native_out_len = TODO_mruby_unbox_unsigned_long_PTR(out_len);

  /* Invocation */
  guchar * native_return_value = g_base64_decode(native_text, native_out_len);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guchar_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_base64_decode_inplace_FUNCTION
#define g_base64_decode_inplace_REQUIRED_ARGC 2
#define g_base64_decode_inplace_OPTIONAL_ARGC 0
/* g_base64_decode_inplace
 *
 * Parameters:
 * - text: char *
 * - out_len: unsigned long *
 * Return Type: guchar *
 */
mrb_value
mrb_GLib_g_base64_decode_inplace(mrb_state* mrb, mrb_value self) {
  char * text = NULL;
  mrb_value out_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &text, &out_len);

  /* Type checking */
  TODO_type_check_unsigned_long_PTR(out_len);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_text = strdup(text);

  unsigned long * native_out_len = TODO_mruby_unbox_unsigned_long_PTR(out_len);

  /* Invocation */
  guchar * native_return_value = g_base64_decode_inplace(native_text, native_out_len);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guchar_PTR(mrb, native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_text);
  native_text = NULL;

  return return_value;
}
#endif

#if BIND_g_base64_decode_step_FUNCTION
#define g_base64_decode_step_REQUIRED_ARGC 5
#define g_base64_decode_step_OPTIONAL_ARGC 0
/* g_base64_decode_step
 *
 * Parameters:
 * - in: const char *
 * - len: unsigned long
 * - out: unsigned char *
 * - state: int *
 * - save: unsigned int *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_base64_decode_step(mrb_state* mrb, mrb_value self) {
  char * native_in = NULL;
  mrb_int native_len;
  mrb_value out;
  mrb_value state;
  mrb_value save;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iooo", &native_in, &native_len, &out, &state, &save);

  /* Type checking */
  TODO_type_check_unsigned_char_PTR(out);
  TODO_type_check_int_PTR(state);
  TODO_type_check_unsigned_int_PTR(save);

  /* Unbox parameters */
  unsigned char * native_out = TODO_mruby_unbox_unsigned_char_PTR(out);

  int * native_state = TODO_mruby_unbox_int_PTR(state);

  unsigned int * native_save = TODO_mruby_unbox_unsigned_int_PTR(save);

  /* Invocation */
  gsize native_return_value = g_base64_decode_step(native_in, native_len, native_out, native_state, native_save);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_base64_encode_FUNCTION
#define g_base64_encode_REQUIRED_ARGC 2
#define g_base64_encode_OPTIONAL_ARGC 0
/* g_base64_encode
 *
 * Parameters:
 * - data: const unsigned char *
 * - len: unsigned long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_base64_encode(mrb_state* mrb, mrb_value self) {
  mrb_value data;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &data, &native_len);

  /* Type checking */
  TODO_type_check_unsigned_char_PTR(data);

  /* Unbox parameters */
  const unsigned char * native_data = TODO_mruby_unbox_unsigned_char_PTR(data);

  /* Invocation */
  gchar * native_return_value = g_base64_encode(native_data, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_base64_encode_close_FUNCTION
#define g_base64_encode_close_REQUIRED_ARGC 4
#define g_base64_encode_close_OPTIONAL_ARGC 0
/* g_base64_encode_close
 *
 * Parameters:
 * - break_lines: int
 * - out: char *
 * - state: int *
 * - save: int *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_base64_encode_close(mrb_state* mrb, mrb_value self) {
  mrb_int native_break_lines;
  char * out = NULL;
  mrb_value state;
  mrb_value save;

  /* Fetch the args */
  mrb_get_args(mrb, "iz!oo", &native_break_lines, &out, &state, &save);

  /* Type checking */
  TODO_type_check_int_PTR(state);
  TODO_type_check_int_PTR(save);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_out = strdup(out);

  int * native_state = TODO_mruby_unbox_int_PTR(state);

  int * native_save = TODO_mruby_unbox_int_PTR(save);

  /* Invocation */
  gsize native_return_value = g_base64_encode_close(native_break_lines, native_out, native_state, native_save);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_out);
  native_out = NULL;

  return return_value;
}
#endif

#if BIND_g_base64_encode_step_FUNCTION
#define g_base64_encode_step_REQUIRED_ARGC 6
#define g_base64_encode_step_OPTIONAL_ARGC 0
/* g_base64_encode_step
 *
 * Parameters:
 * - in: const unsigned char *
 * - len: unsigned long
 * - break_lines: int
 * - out: char *
 * - state: int *
 * - save: int *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_base64_encode_step(mrb_state* mrb, mrb_value self) {
  mrb_value in;
  mrb_int native_len;
  mrb_int native_break_lines;
  char * out = NULL;
  mrb_value state;
  mrb_value save;

  /* Fetch the args */
  mrb_get_args(mrb, "oiiz!oo", &in, &native_len, &native_break_lines, &out, &state, &save);

  /* Type checking */
  TODO_type_check_unsigned_char_PTR(in);
  TODO_type_check_int_PTR(state);
  TODO_type_check_int_PTR(save);

  /* Unbox parameters */
  const unsigned char * native_in = TODO_mruby_unbox_unsigned_char_PTR(in);

  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_out = strdup(out);

  int * native_state = TODO_mruby_unbox_int_PTR(state);

  int * native_save = TODO_mruby_unbox_int_PTR(save);

  /* Invocation */
  gsize native_return_value = g_base64_encode_step(native_in, native_len, native_break_lines, native_out, native_state, native_save);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_out);
  native_out = NULL;

  return return_value;
}
#endif

#if BIND_g_basename_FUNCTION
#define g_basename_REQUIRED_ARGC 1
#define g_basename_OPTIONAL_ARGC 0
/* g_basename
 *
 * Parameters:
 * - file_name: const char *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_basename(mrb_state* mrb, mrb_value self) {
  char * native_file_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_file_name);

  /* Invocation */
  const gchar * native_return_value = g_basename(native_file_name);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bit_lock_FUNCTION
#define g_bit_lock_REQUIRED_ARGC 2
#define g_bit_lock_OPTIONAL_ARGC 0
/* g_bit_lock
 *
 * Parameters:
 * - address: volatile int *
 * - lock_bit: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bit_lock(mrb_state* mrb, mrb_value self) {
  mrb_value address;
  mrb_int native_lock_bit;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &address, &native_lock_bit);

  /* Type checking */
  TODO_type_check_volatile_int_PTR(address);

  /* Unbox parameters */
  volatile int * native_address = TODO_mruby_unbox_volatile_int_PTR(address);

  /* Invocation */
  g_bit_lock(native_address, native_lock_bit);

  return mrb_nil_value();
}
#endif

#if BIND_g_bit_nth_lsf_FUNCTION
#define g_bit_nth_lsf_REQUIRED_ARGC 2
#define g_bit_nth_lsf_OPTIONAL_ARGC 0
/* g_bit_nth_lsf
 *
 * Parameters:
 * - mask: unsigned long
 * - nth_bit: int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_bit_nth_lsf(mrb_state* mrb, mrb_value self) {
  mrb_int native_mask;
  mrb_int native_nth_bit;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_mask, &native_nth_bit);

  /* Invocation */
  gint native_return_value = g_bit_nth_lsf(native_mask, native_nth_bit);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bit_nth_msf_FUNCTION
#define g_bit_nth_msf_REQUIRED_ARGC 2
#define g_bit_nth_msf_OPTIONAL_ARGC 0
/* g_bit_nth_msf
 *
 * Parameters:
 * - mask: unsigned long
 * - nth_bit: int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_bit_nth_msf(mrb_state* mrb, mrb_value self) {
  mrb_int native_mask;
  mrb_int native_nth_bit;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_mask, &native_nth_bit);

  /* Invocation */
  gint native_return_value = g_bit_nth_msf(native_mask, native_nth_bit);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bit_storage_FUNCTION
#define g_bit_storage_REQUIRED_ARGC 1
#define g_bit_storage_OPTIONAL_ARGC 0
/* g_bit_storage
 *
 * Parameters:
 * - number: unsigned long
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_bit_storage(mrb_state* mrb, mrb_value self) {
  mrb_int native_number;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_number);

  /* Invocation */
  guint native_return_value = g_bit_storage(native_number);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bit_trylock_FUNCTION
#define g_bit_trylock_REQUIRED_ARGC 2
#define g_bit_trylock_OPTIONAL_ARGC 0
/* g_bit_trylock
 *
 * Parameters:
 * - address: volatile int *
 * - lock_bit: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bit_trylock(mrb_state* mrb, mrb_value self) {
  mrb_value address;
  mrb_int native_lock_bit;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &address, &native_lock_bit);

  /* Type checking */
  TODO_type_check_volatile_int_PTR(address);

  /* Unbox parameters */
  volatile int * native_address = TODO_mruby_unbox_volatile_int_PTR(address);

  /* Invocation */
  gboolean native_return_value = g_bit_trylock(native_address, native_lock_bit);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bit_unlock_FUNCTION
#define g_bit_unlock_REQUIRED_ARGC 2
#define g_bit_unlock_OPTIONAL_ARGC 0
/* g_bit_unlock
 *
 * Parameters:
 * - address: volatile int *
 * - lock_bit: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bit_unlock(mrb_state* mrb, mrb_value self) {
  mrb_value address;
  mrb_int native_lock_bit;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &address, &native_lock_bit);

  /* Type checking */
  TODO_type_check_volatile_int_PTR(address);

  /* Unbox parameters */
  volatile int * native_address = TODO_mruby_unbox_volatile_int_PTR(address);

  /* Invocation */
  g_bit_unlock(native_address, native_lock_bit);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_add_application_FUNCTION
#define g_bookmark_file_add_application_REQUIRED_ARGC 4
#define g_bookmark_file_add_application_OPTIONAL_ARGC 0
/* g_bookmark_file_add_application
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - name: const char *
 * - exec: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_add_application(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_name = NULL;
  char * native_exec = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!z!", &bookmark, &native_uri, &native_name, &native_exec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_add_application(native_bookmark, native_uri, native_name, native_exec);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_add_group_FUNCTION
#define g_bookmark_file_add_group_REQUIRED_ARGC 3
#define g_bookmark_file_add_group_OPTIONAL_ARGC 0
/* g_bookmark_file_add_group
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - group: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_add_group(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_group = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &bookmark, &native_uri, &native_group);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_add_group(native_bookmark, native_uri, native_group);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_error_quark_FUNCTION
#define g_bookmark_file_error_quark_REQUIRED_ARGC 0
#define g_bookmark_file_error_quark_OPTIONAL_ARGC 0
/* g_bookmark_file_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_bookmark_file_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_bookmark_file_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bookmark_file_free_FUNCTION
#define g_bookmark_file_free_REQUIRED_ARGC 1
#define g_bookmark_file_free_OPTIONAL_ARGC 0
/* g_bookmark_file_free
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_free(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bookmark);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_free(native_bookmark);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_get_added_FUNCTION
#define g_bookmark_file_get_added_REQUIRED_ARGC 2
#define g_bookmark_file_get_added_OPTIONAL_ARGC 0
/* g_bookmark_file_get_added
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * Return Type: time_t
 */
mrb_value
mrb_GLib_g_bookmark_file_get_added(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_uri);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  time_t native_return_value = g_bookmark_file_get_added(native_bookmark, native_uri, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_time_t(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_get_app_info_FUNCTION
#define g_bookmark_file_get_app_info_REQUIRED_ARGC 6
#define g_bookmark_file_get_app_info_OPTIONAL_ARGC 0
/* g_bookmark_file_get_app_info
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - name: const char *
 * - exec: char **
 * - count: unsigned int *
 * - stamp: long *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_get_app_info(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_name = NULL;
  mrb_value exec;
  mrb_value count;
  mrb_value stamp;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!ooo", &bookmark, &native_uri, &native_name, &exec, &count, &stamp);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(exec);
  TODO_type_check_unsigned_int_PTR(count);
  TODO_type_check_long_PTR(stamp);

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  char ** native_exec = TODO_mruby_unbox_char_PTR_PTR(exec);

  unsigned int * native_count = TODO_mruby_unbox_unsigned_int_PTR(count);

  long * native_stamp = TODO_mruby_unbox_long_PTR(stamp);

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_get_app_info(native_bookmark, native_uri, native_name, native_exec, native_count, native_stamp, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_get_applications_FUNCTION
#define g_bookmark_file_get_applications_REQUIRED_ARGC 3
#define g_bookmark_file_get_applications_OPTIONAL_ARGC 0
/* g_bookmark_file_get_applications
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - length: unsigned long *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_bookmark_file_get_applications(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!o", &bookmark, &native_uri, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar ** native_return_value = g_bookmark_file_get_applications(native_bookmark, native_uri, native_length, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_get_description_FUNCTION
#define g_bookmark_file_get_description_REQUIRED_ARGC 2
#define g_bookmark_file_get_description_OPTIONAL_ARGC 0
/* g_bookmark_file_get_description
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_bookmark_file_get_description(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_uri);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gchar * native_return_value = g_bookmark_file_get_description(native_bookmark, native_uri, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_get_groups_FUNCTION
#define g_bookmark_file_get_groups_REQUIRED_ARGC 3
#define g_bookmark_file_get_groups_OPTIONAL_ARGC 0
/* g_bookmark_file_get_groups
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - length: unsigned long *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_bookmark_file_get_groups(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!o", &bookmark, &native_uri, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar ** native_return_value = g_bookmark_file_get_groups(native_bookmark, native_uri, native_length, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_get_icon_FUNCTION
#define g_bookmark_file_get_icon_REQUIRED_ARGC 4
#define g_bookmark_file_get_icon_OPTIONAL_ARGC 0
/* g_bookmark_file_get_icon
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - href: char **
 * - mime_type: char **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_get_icon(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  mrb_value href;
  mrb_value mime_type;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!oo", &bookmark, &native_uri, &href, &mime_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(href);
  TODO_type_check_char_PTR_PTR(mime_type);

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  char ** native_href = TODO_mruby_unbox_char_PTR_PTR(href);

  char ** native_mime_type = TODO_mruby_unbox_char_PTR_PTR(mime_type);

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_get_icon(native_bookmark, native_uri, native_href, native_mime_type, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_get_is_private_FUNCTION
#define g_bookmark_file_get_is_private_REQUIRED_ARGC 2
#define g_bookmark_file_get_is_private_OPTIONAL_ARGC 0
/* g_bookmark_file_get_is_private
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_get_is_private(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_uri);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_get_is_private(native_bookmark, native_uri, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_get_mime_type_FUNCTION
#define g_bookmark_file_get_mime_type_REQUIRED_ARGC 2
#define g_bookmark_file_get_mime_type_OPTIONAL_ARGC 0
/* g_bookmark_file_get_mime_type
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_bookmark_file_get_mime_type(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_uri);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gchar * native_return_value = g_bookmark_file_get_mime_type(native_bookmark, native_uri, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_get_modified_FUNCTION
#define g_bookmark_file_get_modified_REQUIRED_ARGC 2
#define g_bookmark_file_get_modified_OPTIONAL_ARGC 0
/* g_bookmark_file_get_modified
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * Return Type: time_t
 */
mrb_value
mrb_GLib_g_bookmark_file_get_modified(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_uri);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  time_t native_return_value = g_bookmark_file_get_modified(native_bookmark, native_uri, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_time_t(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_get_size_FUNCTION
#define g_bookmark_file_get_size_REQUIRED_ARGC 1
#define g_bookmark_file_get_size_OPTIONAL_ARGC 0
/* g_bookmark_file_get_size
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_bookmark_file_get_size(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bookmark);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gint native_return_value = g_bookmark_file_get_size(native_bookmark);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bookmark_file_get_title_FUNCTION
#define g_bookmark_file_get_title_REQUIRED_ARGC 2
#define g_bookmark_file_get_title_OPTIONAL_ARGC 0
/* g_bookmark_file_get_title
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_bookmark_file_get_title(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_uri);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gchar * native_return_value = g_bookmark_file_get_title(native_bookmark, native_uri, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_get_uris_FUNCTION
#define g_bookmark_file_get_uris_REQUIRED_ARGC 2
#define g_bookmark_file_get_uris_OPTIONAL_ARGC 0
/* g_bookmark_file_get_uris
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - length: unsigned long *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_bookmark_file_get_uris(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &bookmark, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar ** native_return_value = g_bookmark_file_get_uris(native_bookmark, native_length);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bookmark_file_get_visited_FUNCTION
#define g_bookmark_file_get_visited_REQUIRED_ARGC 2
#define g_bookmark_file_get_visited_OPTIONAL_ARGC 0
/* g_bookmark_file_get_visited
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * Return Type: time_t
 */
mrb_value
mrb_GLib_g_bookmark_file_get_visited(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_uri);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  time_t native_return_value = g_bookmark_file_get_visited(native_bookmark, native_uri, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_time_t(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_has_application_FUNCTION
#define g_bookmark_file_has_application_REQUIRED_ARGC 3
#define g_bookmark_file_has_application_OPTIONAL_ARGC 0
/* g_bookmark_file_has_application
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - name: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_has_application(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_name = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &bookmark, &native_uri, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_has_application(native_bookmark, native_uri, native_name, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_has_group_FUNCTION
#define g_bookmark_file_has_group_REQUIRED_ARGC 3
#define g_bookmark_file_has_group_OPTIONAL_ARGC 0
/* g_bookmark_file_has_group
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - group: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_has_group(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_group = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &bookmark, &native_uri, &native_group);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_has_group(native_bookmark, native_uri, native_group, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_has_item_FUNCTION
#define g_bookmark_file_has_item_REQUIRED_ARGC 2
#define g_bookmark_file_has_item_OPTIONAL_ARGC 0
/* g_bookmark_file_has_item
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_has_item(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_uri);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_has_item(native_bookmark, native_uri);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bookmark_file_load_from_data_FUNCTION
#define g_bookmark_file_load_from_data_REQUIRED_ARGC 3
#define g_bookmark_file_load_from_data_OPTIONAL_ARGC 0
/* g_bookmark_file_load_from_data
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - data: const char *
 * - length: unsigned long
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_load_from_data(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_data = NULL;
  mrb_int native_length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &bookmark, &native_data, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_load_from_data(native_bookmark, native_data, native_length, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_load_from_data_dirs_FUNCTION
#define g_bookmark_file_load_from_data_dirs_REQUIRED_ARGC 3
#define g_bookmark_file_load_from_data_dirs_OPTIONAL_ARGC 0
/* g_bookmark_file_load_from_data_dirs
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - file: const char *
 * - full_path: char **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_load_from_data_dirs(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_file = NULL;
  mrb_value full_path;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!o", &bookmark, &native_file, &full_path);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(full_path);

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  char ** native_full_path = TODO_mruby_unbox_char_PTR_PTR(full_path);

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_load_from_data_dirs(native_bookmark, native_file, native_full_path, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_load_from_file_FUNCTION
#define g_bookmark_file_load_from_file_REQUIRED_ARGC 2
#define g_bookmark_file_load_from_file_OPTIONAL_ARGC 0
/* g_bookmark_file_load_from_file
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - filename: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_load_from_file(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_filename = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_filename);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_load_from_file(native_bookmark, native_filename, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_move_item_FUNCTION
#define g_bookmark_file_move_item_REQUIRED_ARGC 3
#define g_bookmark_file_move_item_OPTIONAL_ARGC 0
/* g_bookmark_file_move_item
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - old_uri: const char *
 * - new_uri: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_move_item(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_old_uri = NULL;
  char * native_new_uri = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &bookmark, &native_old_uri, &native_new_uri);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_move_item(native_bookmark, native_old_uri, native_new_uri, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_new_FUNCTION
#define g_bookmark_file_new_REQUIRED_ARGC 0
#define g_bookmark_file_new_OPTIONAL_ARGC 0
/* g_bookmark_file_new
 *
 * Parameters: None
 * Return Type: GBookmarkFile *
 */
mrb_value
mrb_GLib_g_bookmark_file_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GBookmarkFile * native_return_value = g_bookmark_file_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBookmarkFile(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_bookmark_file_remove_application_FUNCTION
#define g_bookmark_file_remove_application_REQUIRED_ARGC 3
#define g_bookmark_file_remove_application_OPTIONAL_ARGC 0
/* g_bookmark_file_remove_application
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - name: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_remove_application(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_name = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &bookmark, &native_uri, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_remove_application(native_bookmark, native_uri, native_name, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_remove_group_FUNCTION
#define g_bookmark_file_remove_group_REQUIRED_ARGC 3
#define g_bookmark_file_remove_group_OPTIONAL_ARGC 0
/* g_bookmark_file_remove_group
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - group: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_remove_group(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_group = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &bookmark, &native_uri, &native_group);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_remove_group(native_bookmark, native_uri, native_group, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_remove_item_FUNCTION
#define g_bookmark_file_remove_item_REQUIRED_ARGC 2
#define g_bookmark_file_remove_item_OPTIONAL_ARGC 0
/* g_bookmark_file_remove_item
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_remove_item(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_uri);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_remove_item(native_bookmark, native_uri, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_set_added_FUNCTION
#define g_bookmark_file_set_added_REQUIRED_ARGC 3
#define g_bookmark_file_set_added_OPTIONAL_ARGC 0
/* g_bookmark_file_set_added
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - added: long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_set_added(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  mrb_int native_added;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &bookmark, &native_uri, &native_added);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_set_added(native_bookmark, native_uri, native_added);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_set_app_info_FUNCTION
#define g_bookmark_file_set_app_info_REQUIRED_ARGC 6
#define g_bookmark_file_set_app_info_OPTIONAL_ARGC 0
/* g_bookmark_file_set_app_info
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - name: const char *
 * - exec: const char *
 * - count: int
 * - stamp: long
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_set_app_info(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_name = NULL;
  char * native_exec = NULL;
  mrb_int native_count;
  mrb_int native_stamp;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!z!ii", &bookmark, &native_uri, &native_name, &native_exec, &native_count, &native_stamp);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_set_app_info(native_bookmark, native_uri, native_name, native_exec, native_count, native_stamp, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_set_description_FUNCTION
#define g_bookmark_file_set_description_REQUIRED_ARGC 3
#define g_bookmark_file_set_description_OPTIONAL_ARGC 0
/* g_bookmark_file_set_description
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - description: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_set_description(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_description = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &bookmark, &native_uri, &native_description);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_set_description(native_bookmark, native_uri, native_description);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_set_groups_FUNCTION
#define g_bookmark_file_set_groups_REQUIRED_ARGC 4
#define g_bookmark_file_set_groups_OPTIONAL_ARGC 0
/* g_bookmark_file_set_groups
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - groups: const char **
 * - length: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_set_groups(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  mrb_value groups;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!oi", &bookmark, &native_uri, &groups, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(groups);

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  const char ** native_groups = TODO_mruby_unbox_char_PTR_PTR(groups);

  /* Invocation */
  g_bookmark_file_set_groups(native_bookmark, native_uri, native_groups, native_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_set_icon_FUNCTION
#define g_bookmark_file_set_icon_REQUIRED_ARGC 4
#define g_bookmark_file_set_icon_OPTIONAL_ARGC 0
/* g_bookmark_file_set_icon
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - href: const char *
 * - mime_type: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_set_icon(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_href = NULL;
  char * native_mime_type = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!z!", &bookmark, &native_uri, &native_href, &native_mime_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_set_icon(native_bookmark, native_uri, native_href, native_mime_type);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_set_is_private_FUNCTION
#define g_bookmark_file_set_is_private_REQUIRED_ARGC 3
#define g_bookmark_file_set_is_private_OPTIONAL_ARGC 0
/* g_bookmark_file_set_is_private
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - is_private: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_set_is_private(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  mrb_int native_is_private;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &bookmark, &native_uri, &native_is_private);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_set_is_private(native_bookmark, native_uri, native_is_private);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_set_mime_type_FUNCTION
#define g_bookmark_file_set_mime_type_REQUIRED_ARGC 3
#define g_bookmark_file_set_mime_type_OPTIONAL_ARGC 0
/* g_bookmark_file_set_mime_type
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - mime_type: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_set_mime_type(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_mime_type = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &bookmark, &native_uri, &native_mime_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_set_mime_type(native_bookmark, native_uri, native_mime_type);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_set_modified_FUNCTION
#define g_bookmark_file_set_modified_REQUIRED_ARGC 3
#define g_bookmark_file_set_modified_OPTIONAL_ARGC 0
/* g_bookmark_file_set_modified
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - modified: long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_set_modified(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  mrb_int native_modified;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &bookmark, &native_uri, &native_modified);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_set_modified(native_bookmark, native_uri, native_modified);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_set_title_FUNCTION
#define g_bookmark_file_set_title_REQUIRED_ARGC 3
#define g_bookmark_file_set_title_OPTIONAL_ARGC 0
/* g_bookmark_file_set_title
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - title: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_set_title(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  char * native_title = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &bookmark, &native_uri, &native_title);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_set_title(native_bookmark, native_uri, native_title);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_set_visited_FUNCTION
#define g_bookmark_file_set_visited_REQUIRED_ARGC 3
#define g_bookmark_file_set_visited_OPTIONAL_ARGC 0
/* g_bookmark_file_set_visited
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - uri: const char *
 * - visited: long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bookmark_file_set_visited(mrb_state* mrb, mrb_value self) {
  mrb_value bookmark;
  char * native_uri = NULL;
  mrb_int native_visited;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &bookmark, &native_uri, &native_visited);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  g_bookmark_file_set_visited(native_bookmark, native_uri, native_visited);

  return mrb_nil_value();
}
#endif

#if BIND_g_bookmark_file_to_data_FUNCTION
#define g_bookmark_file_to_data_REQUIRED_ARGC 2
#define g_bookmark_file_to_data_OPTIONAL_ARGC 0
/* g_bookmark_file_to_data
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - length: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_bookmark_file_to_data(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &bookmark, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar * native_return_value = g_bookmark_file_to_data(native_bookmark, native_length, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_bookmark_file_to_file_FUNCTION
#define g_bookmark_file_to_file_REQUIRED_ARGC 2
#define g_bookmark_file_to_file_OPTIONAL_ARGC 0
/* g_bookmark_file_to_file
 *
 * Parameters:
 * - bookmark: struct _GBookmarkFile *
 * - filename: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bookmark_file_to_file(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value bookmark;
  char * native_filename = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &bookmark, &native_filename);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bookmark, GBookmarkFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBookmarkFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBookmarkFile * native_bookmark = (mrb_nil_p(bookmark) ? NULL : mruby_unbox__GBookmarkFile(bookmark));

  /* Invocation */
  gboolean native_return_value = g_bookmark_file_to_file(native_bookmark, native_filename, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_build_filename_FUNCTION
#define g_build_filename_REQUIRED_ARGC 1
#define g_build_filename_OPTIONAL_ARGC 0
/* g_build_filename
 *
 * Parameters:
 * - first_element: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_build_filename(mrb_state* mrb, mrb_value self) {
  char * native_first_element = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_first_element);

  /* Invocation */
  gchar * native_return_value = g_build_filename(native_first_element);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_build_filenamev_FUNCTION
#define g_build_filenamev_REQUIRED_ARGC 1
#define g_build_filenamev_OPTIONAL_ARGC 0
/* g_build_filenamev
 *
 * Parameters:
 * - args: char **
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_build_filenamev(mrb_state* mrb, mrb_value self) {
  mrb_value args;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &args);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(args);

  /* Unbox parameters */
  char ** native_args = TODO_mruby_unbox_char_PTR_PTR(args);

  /* Invocation */
  gchar * native_return_value = g_build_filenamev(native_args);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_build_path_FUNCTION
#define g_build_path_REQUIRED_ARGC 2
#define g_build_path_OPTIONAL_ARGC 0
/* g_build_path
 *
 * Parameters:
 * - separator: const char *
 * - first_element: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_build_path(mrb_state* mrb, mrb_value self) {
  char * native_separator = NULL;
  char * native_first_element = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_separator, &native_first_element);

  /* Invocation */
  gchar * native_return_value = g_build_path(native_separator, native_first_element);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_build_pathv_FUNCTION
#define g_build_pathv_REQUIRED_ARGC 2
#define g_build_pathv_OPTIONAL_ARGC 0
/* g_build_pathv
 *
 * Parameters:
 * - separator: const char *
 * - args: char **
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_build_pathv(mrb_state* mrb, mrb_value self) {
  char * native_separator = NULL;
  mrb_value args;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_separator, &args);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(args);

  /* Unbox parameters */
  char ** native_args = TODO_mruby_unbox_char_PTR_PTR(args);

  /* Invocation */
  gchar * native_return_value = g_build_pathv(native_separator, native_args);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_byte_array_append_FUNCTION
#define g_byte_array_append_REQUIRED_ARGC 3
#define g_byte_array_append_OPTIONAL_ARGC 0
/* g_byte_array_append
 *
 * Parameters:
 * - array: struct _GByteArray *
 * - data: const unsigned char *
 * - len: unsigned int
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_byte_array_append(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value data;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &array, &data, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_char_PTR(data);

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  const unsigned char * native_data = TODO_mruby_unbox_unsigned_char_PTR(data);

  /* Invocation */
  GByteArray * native_return_value = g_byte_array_append(native_array, native_data, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_free_FUNCTION
#define g_byte_array_free_REQUIRED_ARGC 2
#define g_byte_array_free_OPTIONAL_ARGC 0
/* g_byte_array_free
 *
 * Parameters:
 * - array: struct _GByteArray *
 * - free_segment: int
 * Return Type: guint8 *
 */
mrb_value
mrb_GLib_g_byte_array_free(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_free_segment;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_free_segment);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  /* Invocation */
  guint8 * native_return_value = g_byte_array_free(native_array, native_free_segment);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint8_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_byte_array_free_to_bytes_FUNCTION
#define g_byte_array_free_to_bytes_REQUIRED_ARGC 1
#define g_byte_array_free_to_bytes_OPTIONAL_ARGC 0
/* g_byte_array_free_to_bytes
 *
 * Parameters:
 * - array: struct _GByteArray *
 * Return Type: GBytes *
 */
mrb_value
mrb_GLib_g_byte_array_free_to_bytes(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  /* Invocation */
  GBytes * native_return_value = g_byte_array_free_to_bytes(native_array);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBytes(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_new_FUNCTION
#define g_byte_array_new_REQUIRED_ARGC 0
#define g_byte_array_new_OPTIONAL_ARGC 0
/* g_byte_array_new
 *
 * Parameters: None
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_byte_array_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GByteArray * native_return_value = g_byte_array_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_new_take_FUNCTION
#define g_byte_array_new_take_REQUIRED_ARGC 2
#define g_byte_array_new_take_OPTIONAL_ARGC 0
/* g_byte_array_new_take
 *
 * Parameters:
 * - data: unsigned char *
 * - len: unsigned long
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_byte_array_new_take(mrb_state* mrb, mrb_value self) {
  mrb_value data;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &data, &native_len);

  /* Type checking */
  TODO_type_check_unsigned_char_PTR(data);

  /* Unbox parameters */
  unsigned char * native_data = TODO_mruby_unbox_unsigned_char_PTR(data);

  /* Invocation */
  GByteArray * native_return_value = g_byte_array_new_take(native_data, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_prepend_FUNCTION
#define g_byte_array_prepend_REQUIRED_ARGC 3
#define g_byte_array_prepend_OPTIONAL_ARGC 0
/* g_byte_array_prepend
 *
 * Parameters:
 * - array: struct _GByteArray *
 * - data: const unsigned char *
 * - len: unsigned int
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_byte_array_prepend(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value data;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &array, &data, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_char_PTR(data);

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  const unsigned char * native_data = TODO_mruby_unbox_unsigned_char_PTR(data);

  /* Invocation */
  GByteArray * native_return_value = g_byte_array_prepend(native_array, native_data, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_ref_FUNCTION
#define g_byte_array_ref_REQUIRED_ARGC 1
#define g_byte_array_ref_OPTIONAL_ARGC 0
/* g_byte_array_ref
 *
 * Parameters:
 * - array: struct _GByteArray *
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_byte_array_ref(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  /* Invocation */
  GByteArray * native_return_value = g_byte_array_ref(native_array);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_remove_index_FUNCTION
#define g_byte_array_remove_index_REQUIRED_ARGC 2
#define g_byte_array_remove_index_OPTIONAL_ARGC 0
/* g_byte_array_remove_index
 *
 * Parameters:
 * - array: struct _GByteArray *
 * - index_: unsigned int
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_byte_array_remove_index(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_index_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  /* Invocation */
  GByteArray * native_return_value = g_byte_array_remove_index(native_array, native_index_);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_remove_index_fast_FUNCTION
#define g_byte_array_remove_index_fast_REQUIRED_ARGC 2
#define g_byte_array_remove_index_fast_OPTIONAL_ARGC 0
/* g_byte_array_remove_index_fast
 *
 * Parameters:
 * - array: struct _GByteArray *
 * - index_: unsigned int
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_byte_array_remove_index_fast(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_index_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  /* Invocation */
  GByteArray * native_return_value = g_byte_array_remove_index_fast(native_array, native_index_);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_remove_range_FUNCTION
#define g_byte_array_remove_range_REQUIRED_ARGC 3
#define g_byte_array_remove_range_OPTIONAL_ARGC 0
/* g_byte_array_remove_range
 *
 * Parameters:
 * - array: struct _GByteArray *
 * - index_: unsigned int
 * - length: unsigned int
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_byte_array_remove_range(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &array, &native_index_, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  /* Invocation */
  GByteArray * native_return_value = g_byte_array_remove_range(native_array, native_index_, native_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_set_size_FUNCTION
#define g_byte_array_set_size_REQUIRED_ARGC 2
#define g_byte_array_set_size_OPTIONAL_ARGC 0
/* g_byte_array_set_size
 *
 * Parameters:
 * - array: struct _GByteArray *
 * - length: unsigned int
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_byte_array_set_size(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  /* Invocation */
  GByteArray * native_return_value = g_byte_array_set_size(native_array, native_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_sized_new_FUNCTION
#define g_byte_array_sized_new_REQUIRED_ARGC 1
#define g_byte_array_sized_new_OPTIONAL_ARGC 0
/* g_byte_array_sized_new
 *
 * Parameters:
 * - reserved_size: unsigned int
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_byte_array_sized_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_reserved_size;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_reserved_size);

  /* Invocation */
  GByteArray * native_return_value = g_byte_array_sized_new(native_reserved_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_byte_array_sort_FUNCTION
#define g_byte_array_sort_REQUIRED_ARGC 2
#define g_byte_array_sort_OPTIONAL_ARGC 0
/* g_byte_array_sort
 *
 * Parameters:
 * - array: struct _GByteArray *
 * - compare_func: int (*)(const void *, const void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_byte_array_sort(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value compare_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &compare_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(compare_func);

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  int (*native_compare_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(compare_func);

  /* Invocation */
  g_byte_array_sort(native_array, native_compare_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_byte_array_sort_with_data_FUNCTION
#define g_byte_array_sort_with_data_REQUIRED_ARGC 3
#define g_byte_array_sort_with_data_OPTIONAL_ARGC 0
/* g_byte_array_sort_with_data
 *
 * Parameters:
 * - array: struct _GByteArray *
 * - compare_func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_byte_array_sort_with_data(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value compare_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &array, &compare_func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  int (*native_compare_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_byte_array_sort_with_data(native_array, native_compare_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_byte_array_unref_FUNCTION
#define g_byte_array_unref_REQUIRED_ARGC 1
#define g_byte_array_unref_OPTIONAL_ARGC 0
/* g_byte_array_unref
 *
 * Parameters:
 * - array: struct _GByteArray *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_byte_array_unref(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GByteArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GByteArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GByteArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GByteArray(array));

  /* Invocation */
  g_byte_array_unref(native_array);

  return mrb_nil_value();
}
#endif

#if BIND_g_bytes_compare_FUNCTION
#define g_bytes_compare_REQUIRED_ARGC 2
#define g_bytes_compare_OPTIONAL_ARGC 0
/* g_bytes_compare
 *
 * Parameters:
 * - bytes1: const void *
 * - bytes2: const void *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_bytes_compare(mrb_state* mrb, mrb_value self) {
  mrb_value bytes1;
  mrb_value bytes2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &bytes1, &bytes2);

  /* Type checking */
  TODO_type_check_void_PTR(bytes1);
  TODO_type_check_void_PTR(bytes2);

  /* Unbox parameters */
  const void * native_bytes1 = TODO_mruby_unbox_void_PTR(bytes1);

  const void * native_bytes2 = TODO_mruby_unbox_void_PTR(bytes2);

  /* Invocation */
  gint native_return_value = g_bytes_compare(native_bytes1, native_bytes2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bytes_equal_FUNCTION
#define g_bytes_equal_REQUIRED_ARGC 2
#define g_bytes_equal_OPTIONAL_ARGC 0
/* g_bytes_equal
 *
 * Parameters:
 * - bytes1: const void *
 * - bytes2: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_bytes_equal(mrb_state* mrb, mrb_value self) {
  mrb_value bytes1;
  mrb_value bytes2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &bytes1, &bytes2);

  /* Type checking */
  TODO_type_check_void_PTR(bytes1);
  TODO_type_check_void_PTR(bytes2);

  /* Unbox parameters */
  const void * native_bytes1 = TODO_mruby_unbox_void_PTR(bytes1);

  const void * native_bytes2 = TODO_mruby_unbox_void_PTR(bytes2);

  /* Invocation */
  gboolean native_return_value = g_bytes_equal(native_bytes1, native_bytes2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bytes_get_data_FUNCTION
#define g_bytes_get_data_REQUIRED_ARGC 2
#define g_bytes_get_data_OPTIONAL_ARGC 0
/* g_bytes_get_data
 *
 * Parameters:
 * - bytes: struct _GBytes *
 * - size: unsigned long *
 * Return Type: gconstpointer
 */
mrb_value
mrb_GLib_g_bytes_get_data(mrb_state* mrb, mrb_value self) {
  mrb_value bytes;
  mrb_value size;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &bytes, &size);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bytes, GBytes_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBytes expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(size);

  /* Unbox parameters */
  struct _GBytes * native_bytes = (mrb_nil_p(bytes) ? NULL : mruby_unbox__GBytes(bytes));

  unsigned long * native_size = TODO_mruby_unbox_unsigned_long_PTR(size);

  /* Invocation */
  gconstpointer native_return_value = g_bytes_get_data(native_bytes, native_size);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_void_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bytes_get_size_FUNCTION
#define g_bytes_get_size_REQUIRED_ARGC 1
#define g_bytes_get_size_OPTIONAL_ARGC 0
/* g_bytes_get_size
 *
 * Parameters:
 * - bytes: struct _GBytes *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_bytes_get_size(mrb_state* mrb, mrb_value self) {
  mrb_value bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bytes);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bytes, GBytes_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBytes expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBytes * native_bytes = (mrb_nil_p(bytes) ? NULL : mruby_unbox__GBytes(bytes));

  /* Invocation */
  gsize native_return_value = g_bytes_get_size(native_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bytes_hash_FUNCTION
#define g_bytes_hash_REQUIRED_ARGC 1
#define g_bytes_hash_OPTIONAL_ARGC 0
/* g_bytes_hash
 *
 * Parameters:
 * - bytes: const void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_bytes_hash(mrb_state* mrb, mrb_value self) {
  mrb_value bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bytes);

  /* Type checking */
  TODO_type_check_void_PTR(bytes);

  /* Unbox parameters */
  const void * native_bytes = TODO_mruby_unbox_void_PTR(bytes);

  /* Invocation */
  guint native_return_value = g_bytes_hash(native_bytes);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_bytes_new_FUNCTION
#define g_bytes_new_REQUIRED_ARGC 2
#define g_bytes_new_OPTIONAL_ARGC 0
/* g_bytes_new
 *
 * Parameters:
 * - data: const void *
 * - size: unsigned long
 * Return Type: GBytes *
 */
mrb_value
mrb_GLib_g_bytes_new(mrb_state* mrb, mrb_value self) {
  mrb_value data;
  mrb_int native_size;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &data, &native_size);

  /* Type checking */
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GBytes * native_return_value = g_bytes_new(native_data, native_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBytes(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_bytes_new_from_bytes_FUNCTION
#define g_bytes_new_from_bytes_REQUIRED_ARGC 3
#define g_bytes_new_from_bytes_OPTIONAL_ARGC 0
/* g_bytes_new_from_bytes
 *
 * Parameters:
 * - bytes: struct _GBytes *
 * - offset: unsigned long
 * - length: unsigned long
 * Return Type: GBytes *
 */
mrb_value
mrb_GLib_g_bytes_new_from_bytes(mrb_state* mrb, mrb_value self) {
  mrb_value bytes;
  mrb_int native_offset;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &bytes, &native_offset, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bytes, GBytes_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBytes expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBytes * native_bytes = (mrb_nil_p(bytes) ? NULL : mruby_unbox__GBytes(bytes));

  /* Invocation */
  GBytes * native_return_value = g_bytes_new_from_bytes(native_bytes, native_offset, native_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBytes(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_bytes_new_static_FUNCTION
#define g_bytes_new_static_REQUIRED_ARGC 2
#define g_bytes_new_static_OPTIONAL_ARGC 0
/* g_bytes_new_static
 *
 * Parameters:
 * - data: const void *
 * - size: unsigned long
 * Return Type: GBytes *
 */
mrb_value
mrb_GLib_g_bytes_new_static(mrb_state* mrb, mrb_value self) {
  mrb_value data;
  mrb_int native_size;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &data, &native_size);

  /* Type checking */
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GBytes * native_return_value = g_bytes_new_static(native_data, native_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBytes(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_bytes_new_take_FUNCTION
#define g_bytes_new_take_REQUIRED_ARGC 2
#define g_bytes_new_take_OPTIONAL_ARGC 0
/* g_bytes_new_take
 *
 * Parameters:
 * - data: void *
 * - size: unsigned long
 * Return Type: GBytes *
 */
mrb_value
mrb_GLib_g_bytes_new_take(mrb_state* mrb, mrb_value self) {
  mrb_value data;
  mrb_int native_size;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &data, &native_size);

  /* Type checking */
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GBytes * native_return_value = g_bytes_new_take(native_data, native_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBytes(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_bytes_new_with_free_func_FUNCTION
#define g_bytes_new_with_free_func_REQUIRED_ARGC 4
#define g_bytes_new_with_free_func_OPTIONAL_ARGC 0
/* g_bytes_new_with_free_func
 *
 * Parameters:
 * - data: const void *
 * - size: unsigned long
 * - free_func: void (*)(void *)
 * - user_data: void *
 * Return Type: GBytes *
 */
mrb_value
mrb_GLib_g_bytes_new_with_free_func(mrb_state* mrb, mrb_value self) {
  mrb_value data;
  mrb_int native_size;
  mrb_value free_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &data, &native_size, &free_func, &user_data);

  /* Type checking */
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(free_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_free_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(free_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GBytes * native_return_value = g_bytes_new_with_free_func(native_data, native_size, native_free_func, native_user_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBytes(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_bytes_ref_FUNCTION
#define g_bytes_ref_REQUIRED_ARGC 1
#define g_bytes_ref_OPTIONAL_ARGC 0
/* g_bytes_ref
 *
 * Parameters:
 * - bytes: struct _GBytes *
 * Return Type: GBytes *
 */
mrb_value
mrb_GLib_g_bytes_ref(mrb_state* mrb, mrb_value self) {
  mrb_value bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bytes);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bytes, GBytes_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBytes expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBytes * native_bytes = (mrb_nil_p(bytes) ? NULL : mruby_unbox__GBytes(bytes));

  /* Invocation */
  GBytes * native_return_value = g_bytes_ref(native_bytes);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBytes(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_bytes_unref_FUNCTION
#define g_bytes_unref_REQUIRED_ARGC 1
#define g_bytes_unref_OPTIONAL_ARGC 0
/* g_bytes_unref
 *
 * Parameters:
 * - bytes: struct _GBytes *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_bytes_unref(mrb_state* mrb, mrb_value self) {
  mrb_value bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bytes);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bytes, GBytes_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBytes expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBytes * native_bytes = (mrb_nil_p(bytes) ? NULL : mruby_unbox__GBytes(bytes));

  /* Invocation */
  g_bytes_unref(native_bytes);

  return mrb_nil_value();
}
#endif

#if BIND_g_bytes_unref_to_array_FUNCTION
#define g_bytes_unref_to_array_REQUIRED_ARGC 1
#define g_bytes_unref_to_array_OPTIONAL_ARGC 0
/* g_bytes_unref_to_array
 *
 * Parameters:
 * - bytes: struct _GBytes *
 * Return Type: GByteArray *
 */
mrb_value
mrb_GLib_g_bytes_unref_to_array(mrb_state* mrb, mrb_value self) {
  mrb_value bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &bytes);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bytes, GBytes_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBytes expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBytes * native_bytes = (mrb_nil_p(bytes) ? NULL : mruby_unbox__GBytes(bytes));

  /* Invocation */
  GByteArray * native_return_value = g_bytes_unref_to_array(native_bytes);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GByteArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_bytes_unref_to_data_FUNCTION
#define g_bytes_unref_to_data_REQUIRED_ARGC 2
#define g_bytes_unref_to_data_OPTIONAL_ARGC 0
/* g_bytes_unref_to_data
 *
 * Parameters:
 * - bytes: struct _GBytes *
 * - size: unsigned long *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_bytes_unref_to_data(mrb_state* mrb, mrb_value self) {
  mrb_value bytes;
  mrb_value size;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &bytes, &size);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, bytes, GBytes_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBytes expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(size);

  /* Unbox parameters */
  struct _GBytes * native_bytes = (mrb_nil_p(bytes) ? NULL : mruby_unbox__GBytes(bytes));

  unsigned long * native_size = TODO_mruby_unbox_unsigned_long_PTR(size);

  /* Invocation */
  gpointer native_return_value = g_bytes_unref_to_data(native_bytes, native_size);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_chdir_FUNCTION
#define g_chdir_REQUIRED_ARGC 1
#define g_chdir_OPTIONAL_ARGC 0
/* g_chdir
 *
 * Parameters:
 * - path: const char *
 * Return Type: int
 */
mrb_value
mrb_GLib_g_chdir(mrb_state* mrb, mrb_value self) {
  char * native_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_path);

  /* Invocation */
  int native_return_value = g_chdir(native_path);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_checksum_copy_FUNCTION
#define g_checksum_copy_REQUIRED_ARGC 1
#define g_checksum_copy_OPTIONAL_ARGC 0
/* g_checksum_copy
 *
 * Parameters:
 * - checksum: const struct _GChecksum *
 * Return Type: GChecksum *
 */
mrb_value
mrb_GLib_g_checksum_copy(mrb_state* mrb, mrb_value self) {
  mrb_value checksum;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &checksum);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, checksum, GChecksum_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GChecksum expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GChecksum * native_checksum = (mrb_nil_p(checksum) ? NULL : mruby_unbox__GChecksum(checksum));

  /* Invocation */
  GChecksum * native_return_value = g_checksum_copy(native_checksum);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GChecksum(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_checksum_free_FUNCTION
#define g_checksum_free_REQUIRED_ARGC 1
#define g_checksum_free_OPTIONAL_ARGC 0
/* g_checksum_free
 *
 * Parameters:
 * - checksum: struct _GChecksum *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_checksum_free(mrb_state* mrb, mrb_value self) {
  mrb_value checksum;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &checksum);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, checksum, GChecksum_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GChecksum expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GChecksum * native_checksum = (mrb_nil_p(checksum) ? NULL : mruby_unbox__GChecksum(checksum));

  /* Invocation */
  g_checksum_free(native_checksum);

  return mrb_nil_value();
}
#endif

#if BIND_g_checksum_get_digest_FUNCTION
#define g_checksum_get_digest_REQUIRED_ARGC 3
#define g_checksum_get_digest_OPTIONAL_ARGC 0
/* g_checksum_get_digest
 *
 * Parameters:
 * - checksum: struct _GChecksum *
 * - buffer: unsigned char *
 * - digest_len: unsigned long *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_checksum_get_digest(mrb_state* mrb, mrb_value self) {
  mrb_value checksum;
  mrb_value buffer;
  mrb_value digest_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &checksum, &buffer, &digest_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, checksum, GChecksum_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GChecksum expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_char_PTR(buffer);
  TODO_type_check_unsigned_long_PTR(digest_len);

  /* Unbox parameters */
  struct _GChecksum * native_checksum = (mrb_nil_p(checksum) ? NULL : mruby_unbox__GChecksum(checksum));

  unsigned char * native_buffer = TODO_mruby_unbox_unsigned_char_PTR(buffer);

  unsigned long * native_digest_len = TODO_mruby_unbox_unsigned_long_PTR(digest_len);

  /* Invocation */
  g_checksum_get_digest(native_checksum, native_buffer, native_digest_len);

  return mrb_nil_value();
}
#endif

#if BIND_g_checksum_get_string_FUNCTION
#define g_checksum_get_string_REQUIRED_ARGC 1
#define g_checksum_get_string_OPTIONAL_ARGC 0
/* g_checksum_get_string
 *
 * Parameters:
 * - checksum: struct _GChecksum *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_checksum_get_string(mrb_state* mrb, mrb_value self) {
  mrb_value checksum;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &checksum);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, checksum, GChecksum_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GChecksum expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GChecksum * native_checksum = (mrb_nil_p(checksum) ? NULL : mruby_unbox__GChecksum(checksum));

  /* Invocation */
  const gchar * native_return_value = g_checksum_get_string(native_checksum);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_checksum_new_FUNCTION
#define g_checksum_new_REQUIRED_ARGC 1
#define g_checksum_new_OPTIONAL_ARGC 0
/* g_checksum_new
 *
 * Parameters:
 * - checksum_type: GChecksumType
 * Return Type: GChecksum *
 */
mrb_value
mrb_GLib_g_checksum_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_checksum_type;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_checksum_type);

  /* Invocation */
  GChecksum * native_return_value = g_checksum_new(native_checksum_type);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GChecksum(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_checksum_reset_FUNCTION
#define g_checksum_reset_REQUIRED_ARGC 1
#define g_checksum_reset_OPTIONAL_ARGC 0
/* g_checksum_reset
 *
 * Parameters:
 * - checksum: struct _GChecksum *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_checksum_reset(mrb_state* mrb, mrb_value self) {
  mrb_value checksum;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &checksum);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, checksum, GChecksum_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GChecksum expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GChecksum * native_checksum = (mrb_nil_p(checksum) ? NULL : mruby_unbox__GChecksum(checksum));

  /* Invocation */
  g_checksum_reset(native_checksum);

  return mrb_nil_value();
}
#endif

#if BIND_g_checksum_type_get_length_FUNCTION
#define g_checksum_type_get_length_REQUIRED_ARGC 1
#define g_checksum_type_get_length_OPTIONAL_ARGC 0
/* g_checksum_type_get_length
 *
 * Parameters:
 * - checksum_type: GChecksumType
 * Return Type: gssize
 */
mrb_value
mrb_GLib_g_checksum_type_get_length(mrb_state* mrb, mrb_value self) {
  mrb_int native_checksum_type;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_checksum_type);

  /* Invocation */
  gssize native_return_value = g_checksum_type_get_length(native_checksum_type);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gssize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_checksum_update_FUNCTION
#define g_checksum_update_REQUIRED_ARGC 3
#define g_checksum_update_OPTIONAL_ARGC 0
/* g_checksum_update
 *
 * Parameters:
 * - checksum: struct _GChecksum *
 * - data: const unsigned char *
 * - length: long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_checksum_update(mrb_state* mrb, mrb_value self) {
  mrb_value checksum;
  mrb_value data;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &checksum, &data, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, checksum, GChecksum_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GChecksum expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_char_PTR(data);

  /* Unbox parameters */
  struct _GChecksum * native_checksum = (mrb_nil_p(checksum) ? NULL : mruby_unbox__GChecksum(checksum));

  const unsigned char * native_data = TODO_mruby_unbox_unsigned_char_PTR(data);

  /* Invocation */
  g_checksum_update(native_checksum, native_data, native_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_child_watch_add_FUNCTION
#define g_child_watch_add_REQUIRED_ARGC 3
#define g_child_watch_add_OPTIONAL_ARGC 0
/* g_child_watch_add
 *
 * Parameters:
 * - pid: int
 * - function: void (*)(int, int, void *)
 * - data: void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_child_watch_add(mrb_state* mrb, mrb_value self) {
  mrb_int native_pid;
  mrb_value function;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "ioo", &native_pid, &function, &data);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_intCOMMA_intCOMMA_void_PTR_RPAREN(function);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  void (*native_function)(int, int, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_intCOMMA_intCOMMA_void_PTR_RPAREN(function);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  guint native_return_value = g_child_watch_add(native_pid, native_function, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_child_watch_add_full_FUNCTION
#define g_child_watch_add_full_REQUIRED_ARGC 5
#define g_child_watch_add_full_OPTIONAL_ARGC 0
/* g_child_watch_add_full
 *
 * Parameters:
 * - priority: int
 * - pid: int
 * - function: void (*)(int, int, void *)
 * - data: void *
 * - notify: void (*)(void *)
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_child_watch_add_full(mrb_state* mrb, mrb_value self) {
  mrb_int native_priority;
  mrb_int native_pid;
  mrb_value function;
  mrb_value data;
  mrb_value notify;

  /* Fetch the args */
  mrb_get_args(mrb, "iiooo", &native_priority, &native_pid, &function, &data, &notify);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_intCOMMA_intCOMMA_void_PTR_RPAREN(function);
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Unbox parameters */
  void (*native_function)(int, int, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_intCOMMA_intCOMMA_void_PTR_RPAREN(function);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_notify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Invocation */
  guint native_return_value = g_child_watch_add_full(native_priority, native_pid, native_function, native_data, native_notify);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_child_watch_source_new_FUNCTION
#define g_child_watch_source_new_REQUIRED_ARGC 1
#define g_child_watch_source_new_OPTIONAL_ARGC 0
/* g_child_watch_source_new
 *
 * Parameters:
 * - pid: int
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_child_watch_source_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_pid;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_pid);

  /* Invocation */
  GSource * native_return_value = g_child_watch_source_new(native_pid);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_clear_error_FUNCTION
#define g_clear_error_REQUIRED_ARGC 0
#define g_clear_error_OPTIONAL_ARGC 0
/* g_clear_error
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_GLib_g_clear_error(mrb_state* mrb, mrb_value self) {
  struct GError * native_err = NULL;


  /* Invocation */
  g_clear_error(&native_err);

  /* Box the out parameters */
  mrb_value err = (native_err == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_err));

  return err;
}
#endif

#if BIND_g_clear_pointer_FUNCTION
#define g_clear_pointer_REQUIRED_ARGC 2
#define g_clear_pointer_OPTIONAL_ARGC 0
/* g_clear_pointer
 *
 * Parameters:
 * - pp: void **
 * - destroy: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_clear_pointer(mrb_state* mrb, mrb_value self) {
  mrb_value pp;
  mrb_value destroy;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &pp, &destroy);

  /* Type checking */
  TODO_type_check_void_PTR_PTR(pp);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy);

  /* Unbox parameters */
  void ** native_pp = TODO_mruby_unbox_void_PTR_PTR(pp);

  void (*native_destroy)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy);

  /* Invocation */
  g_clear_pointer(native_pp, native_destroy);

  return mrb_nil_value();
}
#endif

#if BIND_g_close_FUNCTION
#define g_close_REQUIRED_ARGC 1
#define g_close_OPTIONAL_ARGC 0
/* g_close
 *
 * Parameters:
 * - fd: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_close(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_int native_fd;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_fd);

  /* Invocation */
  gboolean native_return_value = g_close(native_fd, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_compute_checksum_for_bytes_FUNCTION
#define g_compute_checksum_for_bytes_REQUIRED_ARGC 2
#define g_compute_checksum_for_bytes_OPTIONAL_ARGC 0
/* g_compute_checksum_for_bytes
 *
 * Parameters:
 * - checksum_type: GChecksumType
 * - data: struct _GBytes *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_compute_checksum_for_bytes(mrb_state* mrb, mrb_value self) {
  mrb_int native_checksum_type;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "io", &native_checksum_type, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, data, GBytes_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBytes expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GBytes * native_data = (mrb_nil_p(data) ? NULL : mruby_unbox__GBytes(data));

  /* Invocation */
  gchar * native_return_value = g_compute_checksum_for_bytes(native_checksum_type, native_data);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_compute_checksum_for_data_FUNCTION
#define g_compute_checksum_for_data_REQUIRED_ARGC 3
#define g_compute_checksum_for_data_OPTIONAL_ARGC 0
/* g_compute_checksum_for_data
 *
 * Parameters:
 * - checksum_type: GChecksumType
 * - data: const unsigned char *
 * - length: unsigned long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_compute_checksum_for_data(mrb_state* mrb, mrb_value self) {
  mrb_int native_checksum_type;
  mrb_value data;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "ioi", &native_checksum_type, &data, &native_length);

  /* Type checking */
  TODO_type_check_unsigned_char_PTR(data);

  /* Unbox parameters */
  const unsigned char * native_data = TODO_mruby_unbox_unsigned_char_PTR(data);

  /* Invocation */
  gchar * native_return_value = g_compute_checksum_for_data(native_checksum_type, native_data, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_compute_checksum_for_string_FUNCTION
#define g_compute_checksum_for_string_REQUIRED_ARGC 3
#define g_compute_checksum_for_string_OPTIONAL_ARGC 0
/* g_compute_checksum_for_string
 *
 * Parameters:
 * - checksum_type: GChecksumType
 * - str: const char *
 * - length: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_compute_checksum_for_string(mrb_state* mrb, mrb_value self) {
  mrb_int native_checksum_type;
  char * native_str = NULL;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "iz!i", &native_checksum_type, &native_str, &native_length);

  /* Invocation */
  gchar * native_return_value = g_compute_checksum_for_string(native_checksum_type, native_str, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_compute_hmac_for_data_FUNCTION
#define g_compute_hmac_for_data_REQUIRED_ARGC 5
#define g_compute_hmac_for_data_OPTIONAL_ARGC 0
/* g_compute_hmac_for_data
 *
 * Parameters:
 * - digest_type: GChecksumType
 * - key: const unsigned char *
 * - key_len: unsigned long
 * - data: const unsigned char *
 * - length: unsigned long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_compute_hmac_for_data(mrb_state* mrb, mrb_value self) {
  mrb_int native_digest_type;
  mrb_value key;
  mrb_int native_key_len;
  mrb_value data;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "ioioi", &native_digest_type, &key, &native_key_len, &data, &native_length);

  /* Type checking */
  TODO_type_check_unsigned_char_PTR(key);
  TODO_type_check_unsigned_char_PTR(data);

  /* Unbox parameters */
  const unsigned char * native_key = TODO_mruby_unbox_unsigned_char_PTR(key);

  const unsigned char * native_data = TODO_mruby_unbox_unsigned_char_PTR(data);

  /* Invocation */
  gchar * native_return_value = g_compute_hmac_for_data(native_digest_type, native_key, native_key_len, native_data, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_compute_hmac_for_string_FUNCTION
#define g_compute_hmac_for_string_REQUIRED_ARGC 5
#define g_compute_hmac_for_string_OPTIONAL_ARGC 0
/* g_compute_hmac_for_string
 *
 * Parameters:
 * - digest_type: GChecksumType
 * - key: const unsigned char *
 * - key_len: unsigned long
 * - str: const char *
 * - length: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_compute_hmac_for_string(mrb_state* mrb, mrb_value self) {
  mrb_int native_digest_type;
  mrb_value key;
  mrb_int native_key_len;
  char * native_str = NULL;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "ioiz!i", &native_digest_type, &key, &native_key_len, &native_str, &native_length);

  /* Type checking */
  TODO_type_check_unsigned_char_PTR(key);

  /* Unbox parameters */
  const unsigned char * native_key = TODO_mruby_unbox_unsigned_char_PTR(key);

  /* Invocation */
  gchar * native_return_value = g_compute_hmac_for_string(native_digest_type, native_key, native_key_len, native_str, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_cond_broadcast_FUNCTION
#define g_cond_broadcast_REQUIRED_ARGC 1
#define g_cond_broadcast_OPTIONAL_ARGC 0
/* g_cond_broadcast
 *
 * Parameters:
 * - cond: struct _GCond *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_cond_broadcast(mrb_state* mrb, mrb_value self) {
  mrb_value cond;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cond);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cond, GCond_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GCond expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GCond * native_cond = (mrb_nil_p(cond) ? NULL : mruby_unbox__GCond(cond));

  /* Invocation */
  g_cond_broadcast(native_cond);

  return mrb_nil_value();
}
#endif

#if BIND_g_cond_clear_FUNCTION
#define g_cond_clear_REQUIRED_ARGC 1
#define g_cond_clear_OPTIONAL_ARGC 0
/* g_cond_clear
 *
 * Parameters:
 * - cond: struct _GCond *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_cond_clear(mrb_state* mrb, mrb_value self) {
  mrb_value cond;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cond);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cond, GCond_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GCond expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GCond * native_cond = (mrb_nil_p(cond) ? NULL : mruby_unbox__GCond(cond));

  /* Invocation */
  g_cond_clear(native_cond);

  return mrb_nil_value();
}
#endif

#if BIND_g_cond_init_FUNCTION
#define g_cond_init_REQUIRED_ARGC 1
#define g_cond_init_OPTIONAL_ARGC 0
/* g_cond_init
 *
 * Parameters:
 * - cond: struct _GCond *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_cond_init(mrb_state* mrb, mrb_value self) {
  mrb_value cond;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cond);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cond, GCond_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GCond expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GCond * native_cond = (mrb_nil_p(cond) ? NULL : mruby_unbox__GCond(cond));

  /* Invocation */
  g_cond_init(native_cond);

  return mrb_nil_value();
}
#endif

#if BIND_g_cond_signal_FUNCTION
#define g_cond_signal_REQUIRED_ARGC 1
#define g_cond_signal_OPTIONAL_ARGC 0
/* g_cond_signal
 *
 * Parameters:
 * - cond: struct _GCond *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_cond_signal(mrb_state* mrb, mrb_value self) {
  mrb_value cond;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &cond);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cond, GCond_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GCond expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GCond * native_cond = (mrb_nil_p(cond) ? NULL : mruby_unbox__GCond(cond));

  /* Invocation */
  g_cond_signal(native_cond);

  return mrb_nil_value();
}
#endif

#if BIND_g_cond_wait_FUNCTION
#define g_cond_wait_REQUIRED_ARGC 2
#define g_cond_wait_OPTIONAL_ARGC 0
/* g_cond_wait
 *
 * Parameters:
 * - cond: struct _GCond *
 * - mutex: union _GMutex *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_cond_wait(mrb_state* mrb, mrb_value self) {
  mrb_value cond;
  mrb_value mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &cond, &mutex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cond, GCond_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GCond expected");
    return mrb_nil_value();
  }
  TODO_type_check_union__GMutex_PTR(mutex);

  /* Unbox parameters */
  struct _GCond * native_cond = (mrb_nil_p(cond) ? NULL : mruby_unbox__GCond(cond));

  union _GMutex * native_mutex = TODO_mruby_unbox_union__GMutex_PTR(mutex);

  /* Invocation */
  g_cond_wait(native_cond, native_mutex);

  return mrb_nil_value();
}
#endif

#if BIND_g_cond_wait_until_FUNCTION
#define g_cond_wait_until_REQUIRED_ARGC 3
#define g_cond_wait_until_OPTIONAL_ARGC 0
/* g_cond_wait_until
 *
 * Parameters:
 * - cond: struct _GCond *
 * - mutex: union _GMutex *
 * - end_time: long
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_cond_wait_until(mrb_state* mrb, mrb_value self) {
  mrb_value cond;
  mrb_value mutex;
  mrb_int native_end_time;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &cond, &mutex, &native_end_time);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, cond, GCond_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GCond expected");
    return mrb_nil_value();
  }
  TODO_type_check_union__GMutex_PTR(mutex);

  /* Unbox parameters */
  struct _GCond * native_cond = (mrb_nil_p(cond) ? NULL : mruby_unbox__GCond(cond));

  union _GMutex * native_mutex = TODO_mruby_unbox_union__GMutex_PTR(mutex);

  /* Invocation */
  gboolean native_return_value = g_cond_wait_until(native_cond, native_mutex, native_end_time);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_convert_FUNCTION
#define g_convert_REQUIRED_ARGC 6
#define g_convert_OPTIONAL_ARGC 0
/* g_convert
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * - to_codeset: const char *
 * - from_codeset: const char *
 * - bytes_read: unsigned long *
 * - bytes_written: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_convert(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_str = NULL;
  mrb_int native_len;
  char * native_to_codeset = NULL;
  char * native_from_codeset = NULL;
  mrb_value bytes_read;
  mrb_value bytes_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!z!oo", &native_str, &native_len, &native_to_codeset, &native_from_codeset, &bytes_read, &bytes_written);

  /* Type checking */
  TODO_type_check_unsigned_long_PTR(bytes_read);
  TODO_type_check_unsigned_long_PTR(bytes_written);

  /* Unbox parameters */
  unsigned long * native_bytes_read = TODO_mruby_unbox_unsigned_long_PTR(bytes_read);

  unsigned long * native_bytes_written = TODO_mruby_unbox_unsigned_long_PTR(bytes_written);

  /* Invocation */
  gchar * native_return_value = g_convert(native_str, native_len, native_to_codeset, native_from_codeset, native_bytes_read, native_bytes_written, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_convert_error_quark_FUNCTION
#define g_convert_error_quark_REQUIRED_ARGC 0
#define g_convert_error_quark_OPTIONAL_ARGC 0
/* g_convert_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_convert_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_convert_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_convert_with_fallback_FUNCTION
#define g_convert_with_fallback_REQUIRED_ARGC 7
#define g_convert_with_fallback_OPTIONAL_ARGC 0
/* g_convert_with_fallback
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * - to_codeset: const char *
 * - from_codeset: const char *
 * - fallback: const char *
 * - bytes_read: unsigned long *
 * - bytes_written: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_convert_with_fallback(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_str = NULL;
  mrb_int native_len;
  char * native_to_codeset = NULL;
  char * native_from_codeset = NULL;
  char * native_fallback = NULL;
  mrb_value bytes_read;
  mrb_value bytes_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!z!z!oo", &native_str, &native_len, &native_to_codeset, &native_from_codeset, &native_fallback, &bytes_read, &bytes_written);

  /* Type checking */
  TODO_type_check_unsigned_long_PTR(bytes_read);
  TODO_type_check_unsigned_long_PTR(bytes_written);

  /* Unbox parameters */
  unsigned long * native_bytes_read = TODO_mruby_unbox_unsigned_long_PTR(bytes_read);

  unsigned long * native_bytes_written = TODO_mruby_unbox_unsigned_long_PTR(bytes_written);

  /* Invocation */
  gchar * native_return_value = g_convert_with_fallback(native_str, native_len, native_to_codeset, native_from_codeset, native_fallback, native_bytes_read, native_bytes_written, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_convert_with_iconv_FUNCTION
#define g_convert_with_iconv_REQUIRED_ARGC 5
#define g_convert_with_iconv_OPTIONAL_ARGC 0
/* g_convert_with_iconv
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * - converter: struct _GIConv *
 * - bytes_read: unsigned long *
 * - bytes_written: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_convert_with_iconv(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_str = NULL;
  mrb_int native_len;
  mrb_value converter;
  mrb_value bytes_read;
  mrb_value bytes_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iooo", &native_str, &native_len, &converter, &bytes_read, &bytes_written);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, converter, GIConv_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIConv expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(bytes_read);
  TODO_type_check_unsigned_long_PTR(bytes_written);

  /* Unbox parameters */
  struct _GIConv * native_converter = (mrb_nil_p(converter) ? NULL : mruby_unbox__GIConv(converter));

  unsigned long * native_bytes_read = TODO_mruby_unbox_unsigned_long_PTR(bytes_read);

  unsigned long * native_bytes_written = TODO_mruby_unbox_unsigned_long_PTR(bytes_written);

  /* Invocation */
  gchar * native_return_value = g_convert_with_iconv(native_str, native_len, native_converter, native_bytes_read, native_bytes_written, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_datalist_clear_FUNCTION
#define g_datalist_clear_REQUIRED_ARGC 1
#define g_datalist_clear_OPTIONAL_ARGC 0
/* g_datalist_clear
 *
 * Parameters:
 * - datalist: struct _GData **
 * Return Type: void
 */
mrb_value
mrb_GLib_g_datalist_clear(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datalist);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  /* Invocation */
  g_datalist_clear(native_datalist);

  return mrb_nil_value();
}
#endif

#if BIND_g_datalist_foreach_FUNCTION
#define g_datalist_foreach_REQUIRED_ARGC 3
#define g_datalist_foreach_OPTIONAL_ARGC 0
/* g_datalist_foreach
 *
 * Parameters:
 * - datalist: struct _GData **
 * - func: void (*)(unsigned int, void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_datalist_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &datalist, &func, &user_data);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_unsigned_intCOMMA_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  void (*native_func)(unsigned int, void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_unsigned_intCOMMA_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_datalist_foreach(native_datalist, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_datalist_get_data_FUNCTION
#define g_datalist_get_data_REQUIRED_ARGC 2
#define g_datalist_get_data_OPTIONAL_ARGC 0
/* g_datalist_get_data
 *
 * Parameters:
 * - datalist: struct _GData **
 * - key: const char *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_datalist_get_data(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;
  char * native_key = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &datalist, &native_key);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  /* Invocation */
  gpointer native_return_value = g_datalist_get_data(native_datalist, native_key);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_datalist_get_flags_FUNCTION
#define g_datalist_get_flags_REQUIRED_ARGC 1
#define g_datalist_get_flags_OPTIONAL_ARGC 0
/* g_datalist_get_flags
 *
 * Parameters:
 * - datalist: struct _GData **
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_datalist_get_flags(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datalist);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  /* Invocation */
  guint native_return_value = g_datalist_get_flags(native_datalist);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_datalist_id_dup_data_FUNCTION
#define g_datalist_id_dup_data_REQUIRED_ARGC 4
#define g_datalist_id_dup_data_OPTIONAL_ARGC 0
/* g_datalist_id_dup_data
 *
 * Parameters:
 * - datalist: struct _GData **
 * - key_id: unsigned int
 * - dup_func: void *(*)(void *, void *)
 * - user_data: void *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_datalist_id_dup_data(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;
  mrb_int native_key_id;
  mrb_value dup_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &datalist, &native_key_id, &dup_func, &user_data);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);
  TODO_type_check_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(dup_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  void *(*native_dup_func)(void *, void *) = TODO_mruby_unbox_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(dup_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  gpointer native_return_value = g_datalist_id_dup_data(native_datalist, native_key_id, native_dup_func, native_user_data);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_datalist_id_get_data_FUNCTION
#define g_datalist_id_get_data_REQUIRED_ARGC 2
#define g_datalist_id_get_data_OPTIONAL_ARGC 0
/* g_datalist_id_get_data
 *
 * Parameters:
 * - datalist: struct _GData **
 * - key_id: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_datalist_id_get_data(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;
  mrb_int native_key_id;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datalist, &native_key_id);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  /* Invocation */
  gpointer native_return_value = g_datalist_id_get_data(native_datalist, native_key_id);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_datalist_id_remove_no_notify_FUNCTION
#define g_datalist_id_remove_no_notify_REQUIRED_ARGC 2
#define g_datalist_id_remove_no_notify_OPTIONAL_ARGC 0
/* g_datalist_id_remove_no_notify
 *
 * Parameters:
 * - datalist: struct _GData **
 * - key_id: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_datalist_id_remove_no_notify(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;
  mrb_int native_key_id;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datalist, &native_key_id);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  /* Invocation */
  gpointer native_return_value = g_datalist_id_remove_no_notify(native_datalist, native_key_id);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_datalist_id_replace_data_FUNCTION
#define g_datalist_id_replace_data_REQUIRED_ARGC 6
#define g_datalist_id_replace_data_OPTIONAL_ARGC 0
/* g_datalist_id_replace_data
 *
 * Parameters:
 * - datalist: struct _GData **
 * - key_id: unsigned int
 * - oldval: void *
 * - newval: void *
 * - destroy: void (*)(void *)
 * - old_destroy: void (**)(void *)
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_datalist_id_replace_data(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;
  mrb_int native_key_id;
  mrb_value oldval;
  mrb_value newval;
  mrb_value destroy;
  mrb_value old_destroy;

  /* Fetch the args */
  mrb_get_args(mrb, "oioooo", &datalist, &native_key_id, &oldval, &newval, &destroy, &old_destroy);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);
  TODO_type_check_void_PTR(oldval);
  TODO_type_check_void_PTR(newval);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy);
  TODO_type_check_void_LPAREN_PTR_PTR_RPAREN_LPAREN_void_PTR_RPAREN(old_destroy);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  void * native_oldval = TODO_mruby_unbox_void_PTR(oldval);

  void * native_newval = TODO_mruby_unbox_void_PTR(newval);

  void (*native_destroy)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy);

  void (**)(void *) native_old_destroy = TODO_mruby_unbox_void_LPAREN_PTR_PTR_RPAREN_LPAREN_void_PTR_RPAREN(old_destroy);

  /* Invocation */
  gboolean native_return_value = g_datalist_id_replace_data(native_datalist, native_key_id, native_oldval, native_newval, native_destroy, native_old_destroy);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_datalist_id_set_data_full_FUNCTION
#define g_datalist_id_set_data_full_REQUIRED_ARGC 4
#define g_datalist_id_set_data_full_OPTIONAL_ARGC 0
/* g_datalist_id_set_data_full
 *
 * Parameters:
 * - datalist: struct _GData **
 * - key_id: unsigned int
 * - data: void *
 * - destroy_func: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_datalist_id_set_data_full(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;
  mrb_int native_key_id;
  mrb_value data;
  mrb_value destroy_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &datalist, &native_key_id, &data, &destroy_func);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy_func);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_destroy_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy_func);

  /* Invocation */
  g_datalist_id_set_data_full(native_datalist, native_key_id, native_data, native_destroy_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_datalist_init_FUNCTION
#define g_datalist_init_REQUIRED_ARGC 1
#define g_datalist_init_OPTIONAL_ARGC 0
/* g_datalist_init
 *
 * Parameters:
 * - datalist: struct _GData **
 * Return Type: void
 */
mrb_value
mrb_GLib_g_datalist_init(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datalist);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  /* Invocation */
  g_datalist_init(native_datalist);

  return mrb_nil_value();
}
#endif

#if BIND_g_datalist_set_flags_FUNCTION
#define g_datalist_set_flags_REQUIRED_ARGC 2
#define g_datalist_set_flags_OPTIONAL_ARGC 0
/* g_datalist_set_flags
 *
 * Parameters:
 * - datalist: struct _GData **
 * - flags: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_datalist_set_flags(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;
  mrb_int native_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datalist, &native_flags);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  /* Invocation */
  g_datalist_set_flags(native_datalist, native_flags);

  return mrb_nil_value();
}
#endif

#if BIND_g_datalist_unset_flags_FUNCTION
#define g_datalist_unset_flags_REQUIRED_ARGC 2
#define g_datalist_unset_flags_OPTIONAL_ARGC 0
/* g_datalist_unset_flags
 *
 * Parameters:
 * - datalist: struct _GData **
 * - flags: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_datalist_unset_flags(mrb_state* mrb, mrb_value self) {
  mrb_value datalist;
  mrb_int native_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datalist, &native_flags);

  /* Type checking */
  TODO_type_check__GData_PTR_PTR(datalist);

  /* Unbox parameters */
  struct _GData ** native_datalist = TODO_mruby_unbox__GData_PTR_PTR(datalist);

  /* Invocation */
  g_datalist_unset_flags(native_datalist, native_flags);

  return mrb_nil_value();
}
#endif

#if BIND_g_dataset_destroy_FUNCTION
#define g_dataset_destroy_REQUIRED_ARGC 1
#define g_dataset_destroy_OPTIONAL_ARGC 0
/* g_dataset_destroy
 *
 * Parameters:
 * - dataset_location: const void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_dataset_destroy(mrb_state* mrb, mrb_value self) {
  mrb_value dataset_location;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &dataset_location);

  /* Type checking */
  TODO_type_check_void_PTR(dataset_location);

  /* Unbox parameters */
  const void * native_dataset_location = TODO_mruby_unbox_void_PTR(dataset_location);

  /* Invocation */
  g_dataset_destroy(native_dataset_location);

  return mrb_nil_value();
}
#endif

#if BIND_g_dataset_foreach_FUNCTION
#define g_dataset_foreach_REQUIRED_ARGC 3
#define g_dataset_foreach_OPTIONAL_ARGC 0
/* g_dataset_foreach
 *
 * Parameters:
 * - dataset_location: const void *
 * - func: void (*)(unsigned int, void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_dataset_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value dataset_location;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &dataset_location, &func, &user_data);

  /* Type checking */
  TODO_type_check_void_PTR(dataset_location);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_unsigned_intCOMMA_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  const void * native_dataset_location = TODO_mruby_unbox_void_PTR(dataset_location);

  void (*native_func)(unsigned int, void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_unsigned_intCOMMA_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_dataset_foreach(native_dataset_location, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_dataset_id_get_data_FUNCTION
#define g_dataset_id_get_data_REQUIRED_ARGC 2
#define g_dataset_id_get_data_OPTIONAL_ARGC 0
/* g_dataset_id_get_data
 *
 * Parameters:
 * - dataset_location: const void *
 * - key_id: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_dataset_id_get_data(mrb_state* mrb, mrb_value self) {
  mrb_value dataset_location;
  mrb_int native_key_id;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &dataset_location, &native_key_id);

  /* Type checking */
  TODO_type_check_void_PTR(dataset_location);

  /* Unbox parameters */
  const void * native_dataset_location = TODO_mruby_unbox_void_PTR(dataset_location);

  /* Invocation */
  gpointer native_return_value = g_dataset_id_get_data(native_dataset_location, native_key_id);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_dataset_id_remove_no_notify_FUNCTION
#define g_dataset_id_remove_no_notify_REQUIRED_ARGC 2
#define g_dataset_id_remove_no_notify_OPTIONAL_ARGC 0
/* g_dataset_id_remove_no_notify
 *
 * Parameters:
 * - dataset_location: const void *
 * - key_id: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_dataset_id_remove_no_notify(mrb_state* mrb, mrb_value self) {
  mrb_value dataset_location;
  mrb_int native_key_id;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &dataset_location, &native_key_id);

  /* Type checking */
  TODO_type_check_void_PTR(dataset_location);

  /* Unbox parameters */
  const void * native_dataset_location = TODO_mruby_unbox_void_PTR(dataset_location);

  /* Invocation */
  gpointer native_return_value = g_dataset_id_remove_no_notify(native_dataset_location, native_key_id);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_dataset_id_set_data_full_FUNCTION
#define g_dataset_id_set_data_full_REQUIRED_ARGC 4
#define g_dataset_id_set_data_full_OPTIONAL_ARGC 0
/* g_dataset_id_set_data_full
 *
 * Parameters:
 * - dataset_location: const void *
 * - key_id: unsigned int
 * - data: void *
 * - destroy_func: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_dataset_id_set_data_full(mrb_state* mrb, mrb_value self) {
  mrb_value dataset_location;
  mrb_int native_key_id;
  mrb_value data;
  mrb_value destroy_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &dataset_location, &native_key_id, &data, &destroy_func);

  /* Type checking */
  TODO_type_check_void_PTR(dataset_location);
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy_func);

  /* Unbox parameters */
  const void * native_dataset_location = TODO_mruby_unbox_void_PTR(dataset_location);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_destroy_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy_func);

  /* Invocation */
  g_dataset_id_set_data_full(native_dataset_location, native_key_id, native_data, native_destroy_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_add_days_FUNCTION
#define g_date_add_days_REQUIRED_ARGC 2
#define g_date_add_days_OPTIONAL_ARGC 0
/* g_date_add_days
 *
 * Parameters:
 * - date: struct _GDate *
 * - n_days: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_add_days(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_n_days;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_n_days);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_add_days(native_date, native_n_days);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_add_months_FUNCTION
#define g_date_add_months_REQUIRED_ARGC 2
#define g_date_add_months_OPTIONAL_ARGC 0
/* g_date_add_months
 *
 * Parameters:
 * - date: struct _GDate *
 * - n_months: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_add_months(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_n_months;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_n_months);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_add_months(native_date, native_n_months);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_add_years_FUNCTION
#define g_date_add_years_REQUIRED_ARGC 2
#define g_date_add_years_OPTIONAL_ARGC 0
/* g_date_add_years
 *
 * Parameters:
 * - date: struct _GDate *
 * - n_years: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_add_years(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_n_years;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_n_years);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_add_years(native_date, native_n_years);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_clamp_FUNCTION
#define g_date_clamp_REQUIRED_ARGC 3
#define g_date_clamp_OPTIONAL_ARGC 0
/* g_date_clamp
 *
 * Parameters:
 * - date: struct _GDate *
 * - min_date: const struct _GDate *
 * - max_date: const struct _GDate *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_clamp(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_value min_date;
  mrb_value max_date;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &date, &min_date, &max_date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, min_date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, max_date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  const struct _GDate * native_min_date = (mrb_nil_p(min_date) ? NULL : mruby_unbox__GDate(min_date));

  const struct _GDate * native_max_date = (mrb_nil_p(max_date) ? NULL : mruby_unbox__GDate(max_date));

  /* Invocation */
  g_date_clamp(native_date, native_min_date, native_max_date);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_clear_FUNCTION
#define g_date_clear_REQUIRED_ARGC 2
#define g_date_clear_OPTIONAL_ARGC 0
/* g_date_clear
 *
 * Parameters:
 * - date: struct _GDate *
 * - n_dates: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_clear(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_n_dates;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_n_dates);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_clear(native_date, native_n_dates);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_compare_FUNCTION
#define g_date_compare_REQUIRED_ARGC 2
#define g_date_compare_OPTIONAL_ARGC 0
/* g_date_compare
 *
 * Parameters:
 * - lhs: const struct _GDate *
 * - rhs: const struct _GDate *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_compare(mrb_state* mrb, mrb_value self) {
  mrb_value lhs;
  mrb_value rhs;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &lhs, &rhs);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, lhs, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, rhs, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_lhs = (mrb_nil_p(lhs) ? NULL : mruby_unbox__GDate(lhs));

  const struct _GDate * native_rhs = (mrb_nil_p(rhs) ? NULL : mruby_unbox__GDate(rhs));

  /* Invocation */
  gint native_return_value = g_date_compare(native_lhs, native_rhs);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_days_between_FUNCTION
#define g_date_days_between_REQUIRED_ARGC 2
#define g_date_days_between_OPTIONAL_ARGC 0
/* g_date_days_between
 *
 * Parameters:
 * - date1: const struct _GDate *
 * - date2: const struct _GDate *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_days_between(mrb_state* mrb, mrb_value self) {
  mrb_value date1;
  mrb_value date2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &date1, &date2);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date1, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, date2, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date1 = (mrb_nil_p(date1) ? NULL : mruby_unbox__GDate(date1));

  const struct _GDate * native_date2 = (mrb_nil_p(date2) ? NULL : mruby_unbox__GDate(date2));

  /* Invocation */
  gint native_return_value = g_date_days_between(native_date1, native_date2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_free_FUNCTION
#define g_date_free_REQUIRED_ARGC 1
#define g_date_free_OPTIONAL_ARGC 0
/* g_date_free
 *
 * Parameters:
 * - date: struct _GDate *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_free(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_free(native_date);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_get_day_FUNCTION
#define g_date_get_day_REQUIRED_ARGC 1
#define g_date_get_day_OPTIONAL_ARGC 0
/* g_date_get_day
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: GDateDay
 */
mrb_value
mrb_GLib_g_date_get_day(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  GDateDay native_return_value = g_date_get_day(native_date);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GDateDay(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_day_of_year_FUNCTION
#define g_date_get_day_of_year_REQUIRED_ARGC 1
#define g_date_get_day_of_year_OPTIONAL_ARGC 0
/* g_date_get_day_of_year
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_date_get_day_of_year(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  guint native_return_value = g_date_get_day_of_year(native_date);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_days_in_month_FUNCTION
#define g_date_get_days_in_month_REQUIRED_ARGC 2
#define g_date_get_days_in_month_OPTIONAL_ARGC 0
/* g_date_get_days_in_month
 *
 * Parameters:
 * - month: GDateMonth
 * - year: unsigned short
 * Return Type: guint8
 */
mrb_value
mrb_GLib_g_date_get_days_in_month(mrb_state* mrb, mrb_value self) {
  mrb_int native_month;
  mrb_int native_year;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_month, &native_year);

  /* Invocation */
  guint8 native_return_value = g_date_get_days_in_month(native_month, native_year);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint8(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_iso8601_week_of_year_FUNCTION
#define g_date_get_iso8601_week_of_year_REQUIRED_ARGC 1
#define g_date_get_iso8601_week_of_year_OPTIONAL_ARGC 0
/* g_date_get_iso8601_week_of_year
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_date_get_iso8601_week_of_year(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  guint native_return_value = g_date_get_iso8601_week_of_year(native_date);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_julian_FUNCTION
#define g_date_get_julian_REQUIRED_ARGC 1
#define g_date_get_julian_OPTIONAL_ARGC 0
/* g_date_get_julian
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: guint32
 */
mrb_value
mrb_GLib_g_date_get_julian(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  guint32 native_return_value = g_date_get_julian(native_date);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_monday_week_of_year_FUNCTION
#define g_date_get_monday_week_of_year_REQUIRED_ARGC 1
#define g_date_get_monday_week_of_year_OPTIONAL_ARGC 0
/* g_date_get_monday_week_of_year
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_date_get_monday_week_of_year(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  guint native_return_value = g_date_get_monday_week_of_year(native_date);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_monday_weeks_in_year_FUNCTION
#define g_date_get_monday_weeks_in_year_REQUIRED_ARGC 1
#define g_date_get_monday_weeks_in_year_OPTIONAL_ARGC 0
/* g_date_get_monday_weeks_in_year
 *
 * Parameters:
 * - year: unsigned short
 * Return Type: guint8
 */
mrb_value
mrb_GLib_g_date_get_monday_weeks_in_year(mrb_state* mrb, mrb_value self) {
  mrb_int native_year;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_year);

  /* Invocation */
  guint8 native_return_value = g_date_get_monday_weeks_in_year(native_year);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint8(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_month_FUNCTION
#define g_date_get_month_REQUIRED_ARGC 1
#define g_date_get_month_OPTIONAL_ARGC 0
/* g_date_get_month
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: GDateMonth
 */
mrb_value
mrb_GLib_g_date_get_month(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  GDateMonth native_return_value = g_date_get_month(native_date);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_sunday_week_of_year_FUNCTION
#define g_date_get_sunday_week_of_year_REQUIRED_ARGC 1
#define g_date_get_sunday_week_of_year_OPTIONAL_ARGC 0
/* g_date_get_sunday_week_of_year
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_date_get_sunday_week_of_year(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  guint native_return_value = g_date_get_sunday_week_of_year(native_date);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_sunday_weeks_in_year_FUNCTION
#define g_date_get_sunday_weeks_in_year_REQUIRED_ARGC 1
#define g_date_get_sunday_weeks_in_year_OPTIONAL_ARGC 0
/* g_date_get_sunday_weeks_in_year
 *
 * Parameters:
 * - year: unsigned short
 * Return Type: guint8
 */
mrb_value
mrb_GLib_g_date_get_sunday_weeks_in_year(mrb_state* mrb, mrb_value self) {
  mrb_int native_year;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_year);

  /* Invocation */
  guint8 native_return_value = g_date_get_sunday_weeks_in_year(native_year);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint8(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_weekday_FUNCTION
#define g_date_get_weekday_REQUIRED_ARGC 1
#define g_date_get_weekday_OPTIONAL_ARGC 0
/* g_date_get_weekday
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: GDateWeekday
 */
mrb_value
mrb_GLib_g_date_get_weekday(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  GDateWeekday native_return_value = g_date_get_weekday(native_date);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_get_year_FUNCTION
#define g_date_get_year_REQUIRED_ARGC 1
#define g_date_get_year_OPTIONAL_ARGC 0
/* g_date_get_year
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: GDateYear
 */
mrb_value
mrb_GLib_g_date_get_year(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  GDateYear native_return_value = g_date_get_year(native_date);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GDateYear(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_is_first_of_month_FUNCTION
#define g_date_is_first_of_month_REQUIRED_ARGC 1
#define g_date_is_first_of_month_OPTIONAL_ARGC 0
/* g_date_is_first_of_month
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_is_first_of_month(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  gboolean native_return_value = g_date_is_first_of_month(native_date);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_is_last_of_month_FUNCTION
#define g_date_is_last_of_month_REQUIRED_ARGC 1
#define g_date_is_last_of_month_OPTIONAL_ARGC 0
/* g_date_is_last_of_month
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_is_last_of_month(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  gboolean native_return_value = g_date_is_last_of_month(native_date);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_is_leap_year_FUNCTION
#define g_date_is_leap_year_REQUIRED_ARGC 1
#define g_date_is_leap_year_OPTIONAL_ARGC 0
/* g_date_is_leap_year
 *
 * Parameters:
 * - year: unsigned short
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_is_leap_year(mrb_state* mrb, mrb_value self) {
  mrb_int native_year;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_year);

  /* Invocation */
  gboolean native_return_value = g_date_is_leap_year(native_year);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_new_FUNCTION
#define g_date_new_REQUIRED_ARGC 0
#define g_date_new_OPTIONAL_ARGC 0
/* g_date_new
 *
 * Parameters: None
 * Return Type: GDate *
 */
mrb_value
mrb_GLib_g_date_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GDate * native_return_value = g_date_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDate(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_new_dmy_FUNCTION
#define g_date_new_dmy_REQUIRED_ARGC 3
#define g_date_new_dmy_OPTIONAL_ARGC 0
/* g_date_new_dmy
 *
 * Parameters:
 * - day: unsigned char
 * - month: GDateMonth
 * - year: unsigned short
 * Return Type: GDate *
 */
mrb_value
mrb_GLib_g_date_new_dmy(mrb_state* mrb, mrb_value self) {
  mrb_int native_day;
  mrb_int native_month;
  mrb_int native_year;

  /* Fetch the args */
  mrb_get_args(mrb, "iii", &native_day, &native_month, &native_year);

  /* Invocation */
  GDate * native_return_value = g_date_new_dmy(native_day, native_month, native_year);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDate(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_new_julian_FUNCTION
#define g_date_new_julian_REQUIRED_ARGC 1
#define g_date_new_julian_OPTIONAL_ARGC 0
/* g_date_new_julian
 *
 * Parameters:
 * - julian_day: unsigned int
 * Return Type: GDate *
 */
mrb_value
mrb_GLib_g_date_new_julian(mrb_state* mrb, mrb_value self) {
  mrb_int native_julian_day;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_julian_day);

  /* Invocation */
  GDate * native_return_value = g_date_new_julian(native_julian_day);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDate(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_order_FUNCTION
#define g_date_order_REQUIRED_ARGC 2
#define g_date_order_OPTIONAL_ARGC 0
/* g_date_order
 *
 * Parameters:
 * - date1: struct _GDate *
 * - date2: struct _GDate *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_order(mrb_state* mrb, mrb_value self) {
  mrb_value date1;
  mrb_value date2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &date1, &date2);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date1, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, date2, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date1 = (mrb_nil_p(date1) ? NULL : mruby_unbox__GDate(date1));

  struct _GDate * native_date2 = (mrb_nil_p(date2) ? NULL : mruby_unbox__GDate(date2));

  /* Invocation */
  g_date_order(native_date1, native_date2);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_set_day_FUNCTION
#define g_date_set_day_REQUIRED_ARGC 2
#define g_date_set_day_OPTIONAL_ARGC 0
/* g_date_set_day
 *
 * Parameters:
 * - date: struct _GDate *
 * - day: unsigned char
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_set_day(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_day;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_day);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_set_day(native_date, native_day);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_set_dmy_FUNCTION
#define g_date_set_dmy_REQUIRED_ARGC 4
#define g_date_set_dmy_OPTIONAL_ARGC 0
/* g_date_set_dmy
 *
 * Parameters:
 * - date: struct _GDate *
 * - day: unsigned char
 * - month: GDateMonth
 * - y: unsigned short
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_set_dmy(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_day;
  mrb_int native_month;
  mrb_int native_y;

  /* Fetch the args */
  mrb_get_args(mrb, "oiii", &date, &native_day, &native_month, &native_y);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_set_dmy(native_date, native_day, native_month, native_y);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_set_julian_FUNCTION
#define g_date_set_julian_REQUIRED_ARGC 2
#define g_date_set_julian_OPTIONAL_ARGC 0
/* g_date_set_julian
 *
 * Parameters:
 * - date: struct _GDate *
 * - julian_date: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_set_julian(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_julian_date;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_julian_date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_set_julian(native_date, native_julian_date);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_set_month_FUNCTION
#define g_date_set_month_REQUIRED_ARGC 2
#define g_date_set_month_OPTIONAL_ARGC 0
/* g_date_set_month
 *
 * Parameters:
 * - date: struct _GDate *
 * - month: GDateMonth
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_set_month(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_month;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_month);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_set_month(native_date, native_month);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_set_parse_FUNCTION
#define g_date_set_parse_REQUIRED_ARGC 2
#define g_date_set_parse_OPTIONAL_ARGC 0
/* g_date_set_parse
 *
 * Parameters:
 * - date: struct _GDate *
 * - str: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_set_parse(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &date, &native_str);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_set_parse(native_date, native_str);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_set_time_FUNCTION
#define g_date_set_time_REQUIRED_ARGC 2
#define g_date_set_time_OPTIONAL_ARGC 0
/* g_date_set_time
 *
 * Parameters:
 * - date: struct _GDate *
 * - time_: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_set_time(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_time_;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_time_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_set_time(native_date, native_time_);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_set_time_t_FUNCTION
#define g_date_set_time_t_REQUIRED_ARGC 2
#define g_date_set_time_t_OPTIONAL_ARGC 0
/* g_date_set_time_t
 *
 * Parameters:
 * - date: struct _GDate *
 * - timet: long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_set_time_t(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_timet;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_timet);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_set_time_t(native_date, native_timet);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_set_time_val_FUNCTION
#define g_date_set_time_val_REQUIRED_ARGC 2
#define g_date_set_time_val_OPTIONAL_ARGC 0
/* g_date_set_time_val
 *
 * Parameters:
 * - date: struct _GDate *
 * - timeval: struct _GTimeVal *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_set_time_val(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_value timeval;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &date, &timeval);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, timeval, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  struct _GTimeVal * native_timeval = (mrb_nil_p(timeval) ? NULL : mruby_unbox__GTimeVal(timeval));

  /* Invocation */
  g_date_set_time_val(native_date, native_timeval);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_set_year_FUNCTION
#define g_date_set_year_REQUIRED_ARGC 2
#define g_date_set_year_OPTIONAL_ARGC 0
/* g_date_set_year
 *
 * Parameters:
 * - date: struct _GDate *
 * - year: unsigned short
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_set_year(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_year;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_year);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_set_year(native_date, native_year);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_strftime_FUNCTION
#define g_date_strftime_REQUIRED_ARGC 4
#define g_date_strftime_OPTIONAL_ARGC 0
/* g_date_strftime
 *
 * Parameters:
 * - s: char *
 * - slen: unsigned long
 * - format: const char *
 * - date: const struct _GDate *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_date_strftime(mrb_state* mrb, mrb_value self) {
  char * s = NULL;
  mrb_int native_slen;
  char * native_format = NULL;
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!o", &s, &native_slen, &native_format, &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_s = strdup(s);

  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  gsize native_return_value = g_date_strftime(native_s, native_slen, native_format, native_date);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_s);
  native_s = NULL;

  return return_value;
}
#endif

#if BIND_g_date_subtract_days_FUNCTION
#define g_date_subtract_days_REQUIRED_ARGC 2
#define g_date_subtract_days_OPTIONAL_ARGC 0
/* g_date_subtract_days
 *
 * Parameters:
 * - date: struct _GDate *
 * - n_days: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_subtract_days(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_n_days;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_n_days);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_subtract_days(native_date, native_n_days);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_subtract_months_FUNCTION
#define g_date_subtract_months_REQUIRED_ARGC 2
#define g_date_subtract_months_OPTIONAL_ARGC 0
/* g_date_subtract_months
 *
 * Parameters:
 * - date: struct _GDate *
 * - n_months: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_subtract_months(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_n_months;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_n_months);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_subtract_months(native_date, native_n_months);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_subtract_years_FUNCTION
#define g_date_subtract_years_REQUIRED_ARGC 2
#define g_date_subtract_years_OPTIONAL_ARGC 0
/* g_date_subtract_years
 *
 * Parameters:
 * - date: struct _GDate *
 * - n_years: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_subtract_years(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_int native_n_years;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &date, &native_n_years);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  g_date_subtract_years(native_date, native_n_years);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_time_add_FUNCTION
#define g_date_time_add_REQUIRED_ARGC 2
#define g_date_time_add_OPTIONAL_ARGC 0
/* g_date_time_add
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - timespan: long
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_add(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_int native_timespan;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datetime, &native_timespan);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_add(native_datetime, native_timespan);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_add_days_FUNCTION
#define g_date_time_add_days_REQUIRED_ARGC 2
#define g_date_time_add_days_OPTIONAL_ARGC 0
/* g_date_time_add_days
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - days: int
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_add_days(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_int native_days;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datetime, &native_days);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_add_days(native_datetime, native_days);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_add_full_FUNCTION
#define g_date_time_add_full_REQUIRED_ARGC 7
#define g_date_time_add_full_OPTIONAL_ARGC 0
/* g_date_time_add_full
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - years: int
 * - months: int
 * - days: int
 * - hours: int
 * - minutes: int
 * - seconds: double
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_add_full(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_int native_years;
  mrb_int native_months;
  mrb_int native_days;
  mrb_int native_hours;
  mrb_int native_minutes;
  double native_seconds;

  /* Fetch the args */
  mrb_get_args(mrb, "oiiiiif", &datetime, &native_years, &native_months, &native_days, &native_hours, &native_minutes, &native_seconds);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_add_full(native_datetime, native_years, native_months, native_days, native_hours, native_minutes, native_seconds);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_add_hours_FUNCTION
#define g_date_time_add_hours_REQUIRED_ARGC 2
#define g_date_time_add_hours_OPTIONAL_ARGC 0
/* g_date_time_add_hours
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - hours: int
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_add_hours(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_int native_hours;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datetime, &native_hours);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_add_hours(native_datetime, native_hours);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_add_minutes_FUNCTION
#define g_date_time_add_minutes_REQUIRED_ARGC 2
#define g_date_time_add_minutes_OPTIONAL_ARGC 0
/* g_date_time_add_minutes
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - minutes: int
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_add_minutes(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_int native_minutes;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datetime, &native_minutes);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_add_minutes(native_datetime, native_minutes);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_add_months_FUNCTION
#define g_date_time_add_months_REQUIRED_ARGC 2
#define g_date_time_add_months_OPTIONAL_ARGC 0
/* g_date_time_add_months
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - months: int
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_add_months(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_int native_months;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datetime, &native_months);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_add_months(native_datetime, native_months);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_add_seconds_FUNCTION
#define g_date_time_add_seconds_REQUIRED_ARGC 2
#define g_date_time_add_seconds_OPTIONAL_ARGC 0
/* g_date_time_add_seconds
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - seconds: double
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_add_seconds(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  double native_seconds;

  /* Fetch the args */
  mrb_get_args(mrb, "of", &datetime, &native_seconds);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_add_seconds(native_datetime, native_seconds);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_add_weeks_FUNCTION
#define g_date_time_add_weeks_REQUIRED_ARGC 2
#define g_date_time_add_weeks_OPTIONAL_ARGC 0
/* g_date_time_add_weeks
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - weeks: int
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_add_weeks(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_int native_weeks;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datetime, &native_weeks);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_add_weeks(native_datetime, native_weeks);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_add_years_FUNCTION
#define g_date_time_add_years_REQUIRED_ARGC 2
#define g_date_time_add_years_OPTIONAL_ARGC 0
/* g_date_time_add_years
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - years: int
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_add_years(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_int native_years;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &datetime, &native_years);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_add_years(native_datetime, native_years);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_compare_FUNCTION
#define g_date_time_compare_REQUIRED_ARGC 2
#define g_date_time_compare_OPTIONAL_ARGC 0
/* g_date_time_compare
 *
 * Parameters:
 * - dt1: const void *
 * - dt2: const void *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_compare(mrb_state* mrb, mrb_value self) {
  mrb_value dt1;
  mrb_value dt2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &dt1, &dt2);

  /* Type checking */
  TODO_type_check_void_PTR(dt1);
  TODO_type_check_void_PTR(dt2);

  /* Unbox parameters */
  const void * native_dt1 = TODO_mruby_unbox_void_PTR(dt1);

  const void * native_dt2 = TODO_mruby_unbox_void_PTR(dt2);

  /* Invocation */
  gint native_return_value = g_date_time_compare(native_dt1, native_dt2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_difference_FUNCTION
#define g_date_time_difference_REQUIRED_ARGC 2
#define g_date_time_difference_OPTIONAL_ARGC 0
/* g_date_time_difference
 *
 * Parameters:
 * - end: struct _GDateTime *
 * - begin: struct _GDateTime *
 * Return Type: GTimeSpan
 */
mrb_value
mrb_GLib_g_date_time_difference(mrb_state* mrb, mrb_value self) {
  mrb_value end;
  mrb_value begin;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &end, &begin);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, end, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, begin, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_end = (mrb_nil_p(end) ? NULL : mruby_unbox__GDateTime(end));

  struct _GDateTime * native_begin = (mrb_nil_p(begin) ? NULL : mruby_unbox__GDateTime(begin));

  /* Invocation */
  GTimeSpan native_return_value = g_date_time_difference(native_end, native_begin);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GTimeSpan(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_equal_FUNCTION
#define g_date_time_equal_REQUIRED_ARGC 2
#define g_date_time_equal_OPTIONAL_ARGC 0
/* g_date_time_equal
 *
 * Parameters:
 * - dt1: const void *
 * - dt2: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_time_equal(mrb_state* mrb, mrb_value self) {
  mrb_value dt1;
  mrb_value dt2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &dt1, &dt2);

  /* Type checking */
  TODO_type_check_void_PTR(dt1);
  TODO_type_check_void_PTR(dt2);

  /* Unbox parameters */
  const void * native_dt1 = TODO_mruby_unbox_void_PTR(dt1);

  const void * native_dt2 = TODO_mruby_unbox_void_PTR(dt2);

  /* Invocation */
  gboolean native_return_value = g_date_time_equal(native_dt1, native_dt2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_format_FUNCTION
#define g_date_time_format_REQUIRED_ARGC 2
#define g_date_time_format_OPTIONAL_ARGC 0
/* g_date_time_format
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - format: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_date_time_format(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &datetime, &native_format);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gchar * native_return_value = g_date_time_format(native_datetime, native_format);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_day_of_month_FUNCTION
#define g_date_time_get_day_of_month_REQUIRED_ARGC 1
#define g_date_time_get_day_of_month_OPTIONAL_ARGC 0
/* g_date_time_get_day_of_month
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_day_of_month(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_day_of_month(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_day_of_week_FUNCTION
#define g_date_time_get_day_of_week_REQUIRED_ARGC 1
#define g_date_time_get_day_of_week_OPTIONAL_ARGC 0
/* g_date_time_get_day_of_week
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_day_of_week(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_day_of_week(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_day_of_year_FUNCTION
#define g_date_time_get_day_of_year_REQUIRED_ARGC 1
#define g_date_time_get_day_of_year_OPTIONAL_ARGC 0
/* g_date_time_get_day_of_year
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_day_of_year(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_day_of_year(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_hour_FUNCTION
#define g_date_time_get_hour_REQUIRED_ARGC 1
#define g_date_time_get_hour_OPTIONAL_ARGC 0
/* g_date_time_get_hour
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_hour(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_hour(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_microsecond_FUNCTION
#define g_date_time_get_microsecond_REQUIRED_ARGC 1
#define g_date_time_get_microsecond_OPTIONAL_ARGC 0
/* g_date_time_get_microsecond
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_microsecond(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_microsecond(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_minute_FUNCTION
#define g_date_time_get_minute_REQUIRED_ARGC 1
#define g_date_time_get_minute_OPTIONAL_ARGC 0
/* g_date_time_get_minute
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_minute(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_minute(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_month_FUNCTION
#define g_date_time_get_month_REQUIRED_ARGC 1
#define g_date_time_get_month_OPTIONAL_ARGC 0
/* g_date_time_get_month
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_month(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_month(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_second_FUNCTION
#define g_date_time_get_second_REQUIRED_ARGC 1
#define g_date_time_get_second_OPTIONAL_ARGC 0
/* g_date_time_get_second
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_second(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_second(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_seconds_FUNCTION
#define g_date_time_get_seconds_REQUIRED_ARGC 1
#define g_date_time_get_seconds_OPTIONAL_ARGC 0
/* g_date_time_get_seconds
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gdouble
 */
mrb_value
mrb_GLib_g_date_time_get_seconds(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gdouble native_return_value = g_date_time_get_seconds(native_datetime);

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_timezone_abbreviation_FUNCTION
#define g_date_time_get_timezone_abbreviation_REQUIRED_ARGC 1
#define g_date_time_get_timezone_abbreviation_OPTIONAL_ARGC 0
/* g_date_time_get_timezone_abbreviation
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_date_time_get_timezone_abbreviation(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  const gchar * native_return_value = g_date_time_get_timezone_abbreviation(native_datetime);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_utc_offset_FUNCTION
#define g_date_time_get_utc_offset_REQUIRED_ARGC 1
#define g_date_time_get_utc_offset_OPTIONAL_ARGC 0
/* g_date_time_get_utc_offset
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: GTimeSpan
 */
mrb_value
mrb_GLib_g_date_time_get_utc_offset(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GTimeSpan native_return_value = g_date_time_get_utc_offset(native_datetime);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GTimeSpan(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_week_numbering_year_FUNCTION
#define g_date_time_get_week_numbering_year_REQUIRED_ARGC 1
#define g_date_time_get_week_numbering_year_OPTIONAL_ARGC 0
/* g_date_time_get_week_numbering_year
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_week_numbering_year(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_week_numbering_year(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_week_of_year_FUNCTION
#define g_date_time_get_week_of_year_REQUIRED_ARGC 1
#define g_date_time_get_week_of_year_OPTIONAL_ARGC 0
/* g_date_time_get_week_of_year
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_week_of_year(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_week_of_year(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_year_FUNCTION
#define g_date_time_get_year_REQUIRED_ARGC 1
#define g_date_time_get_year_OPTIONAL_ARGC 0
/* g_date_time_get_year
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_date_time_get_year(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint native_return_value = g_date_time_get_year(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_get_ymd_FUNCTION
#define g_date_time_get_ymd_REQUIRED_ARGC 4
#define g_date_time_get_ymd_OPTIONAL_ARGC 0
/* g_date_time_get_ymd
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - year: int *
 * - month: int *
 * - day: int *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_time_get_ymd(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_value year;
  mrb_value month;
  mrb_value day;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &datetime, &year, &month, &day);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_PTR(year);
  TODO_type_check_int_PTR(month);
  TODO_type_check_int_PTR(day);

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  int * native_year = TODO_mruby_unbox_int_PTR(year);

  int * native_month = TODO_mruby_unbox_int_PTR(month);

  int * native_day = TODO_mruby_unbox_int_PTR(day);

  /* Invocation */
  g_date_time_get_ymd(native_datetime, native_year, native_month, native_day);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_time_hash_FUNCTION
#define g_date_time_hash_REQUIRED_ARGC 1
#define g_date_time_hash_OPTIONAL_ARGC 0
/* g_date_time_hash
 *
 * Parameters:
 * - datetime: const void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_date_time_hash(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  TODO_type_check_void_PTR(datetime);

  /* Unbox parameters */
  const void * native_datetime = TODO_mruby_unbox_void_PTR(datetime);

  /* Invocation */
  guint native_return_value = g_date_time_hash(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_is_daylight_savings_FUNCTION
#define g_date_time_is_daylight_savings_REQUIRED_ARGC 1
#define g_date_time_is_daylight_savings_OPTIONAL_ARGC 0
/* g_date_time_is_daylight_savings
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_time_is_daylight_savings(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gboolean native_return_value = g_date_time_is_daylight_savings(native_datetime);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_new_FUNCTION
#define g_date_time_new_REQUIRED_ARGC 7
#define g_date_time_new_OPTIONAL_ARGC 0
/* g_date_time_new
 *
 * Parameters:
 * - tz: struct _GTimeZone *
 * - year: int
 * - month: int
 * - day: int
 * - hour: int
 * - minute: int
 * - seconds: double
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_new(mrb_state* mrb, mrb_value self) {
  mrb_value tz;
  mrb_int native_year;
  mrb_int native_month;
  mrb_int native_day;
  mrb_int native_hour;
  mrb_int native_minute;
  double native_seconds;

  /* Fetch the args */
  mrb_get_args(mrb, "oiiiiif", &tz, &native_year, &native_month, &native_day, &native_hour, &native_minute, &native_seconds);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tz, GTimeZone_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeZone expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeZone * native_tz = (mrb_nil_p(tz) ? NULL : mruby_unbox__GTimeZone(tz));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_new(native_tz, native_year, native_month, native_day, native_hour, native_minute, native_seconds);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_new_from_timeval_local_FUNCTION
#define g_date_time_new_from_timeval_local_REQUIRED_ARGC 1
#define g_date_time_new_from_timeval_local_OPTIONAL_ARGC 0
/* g_date_time_new_from_timeval_local
 *
 * Parameters:
 * - tv: const struct _GTimeVal *
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_new_from_timeval_local(mrb_state* mrb, mrb_value self) {
  mrb_value tv;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tv);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tv, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GTimeVal * native_tv = (mrb_nil_p(tv) ? NULL : mruby_unbox__GTimeVal(tv));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_new_from_timeval_local(native_tv);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_new_from_timeval_utc_FUNCTION
#define g_date_time_new_from_timeval_utc_REQUIRED_ARGC 1
#define g_date_time_new_from_timeval_utc_OPTIONAL_ARGC 0
/* g_date_time_new_from_timeval_utc
 *
 * Parameters:
 * - tv: const struct _GTimeVal *
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_new_from_timeval_utc(mrb_state* mrb, mrb_value self) {
  mrb_value tv;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tv);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tv, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GTimeVal * native_tv = (mrb_nil_p(tv) ? NULL : mruby_unbox__GTimeVal(tv));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_new_from_timeval_utc(native_tv);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_new_from_unix_local_FUNCTION
#define g_date_time_new_from_unix_local_REQUIRED_ARGC 1
#define g_date_time_new_from_unix_local_OPTIONAL_ARGC 0
/* g_date_time_new_from_unix_local
 *
 * Parameters:
 * - t: long
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_new_from_unix_local(mrb_state* mrb, mrb_value self) {
  mrb_int native_t;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_t);

  /* Invocation */
  GDateTime * native_return_value = g_date_time_new_from_unix_local(native_t);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_new_from_unix_utc_FUNCTION
#define g_date_time_new_from_unix_utc_REQUIRED_ARGC 1
#define g_date_time_new_from_unix_utc_OPTIONAL_ARGC 0
/* g_date_time_new_from_unix_utc
 *
 * Parameters:
 * - t: long
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_new_from_unix_utc(mrb_state* mrb, mrb_value self) {
  mrb_int native_t;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_t);

  /* Invocation */
  GDateTime * native_return_value = g_date_time_new_from_unix_utc(native_t);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_new_local_FUNCTION
#define g_date_time_new_local_REQUIRED_ARGC 6
#define g_date_time_new_local_OPTIONAL_ARGC 0
/* g_date_time_new_local
 *
 * Parameters:
 * - year: int
 * - month: int
 * - day: int
 * - hour: int
 * - minute: int
 * - seconds: double
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_new_local(mrb_state* mrb, mrb_value self) {
  mrb_int native_year;
  mrb_int native_month;
  mrb_int native_day;
  mrb_int native_hour;
  mrb_int native_minute;
  double native_seconds;

  /* Fetch the args */
  mrb_get_args(mrb, "iiiiif", &native_year, &native_month, &native_day, &native_hour, &native_minute, &native_seconds);

  /* Invocation */
  GDateTime * native_return_value = g_date_time_new_local(native_year, native_month, native_day, native_hour, native_minute, native_seconds);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_new_now_FUNCTION
#define g_date_time_new_now_REQUIRED_ARGC 1
#define g_date_time_new_now_OPTIONAL_ARGC 0
/* g_date_time_new_now
 *
 * Parameters:
 * - tz: struct _GTimeZone *
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_new_now(mrb_state* mrb, mrb_value self) {
  mrb_value tz;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tz);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tz, GTimeZone_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeZone expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeZone * native_tz = (mrb_nil_p(tz) ? NULL : mruby_unbox__GTimeZone(tz));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_new_now(native_tz);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_new_now_local_FUNCTION
#define g_date_time_new_now_local_REQUIRED_ARGC 0
#define g_date_time_new_now_local_OPTIONAL_ARGC 0
/* g_date_time_new_now_local
 *
 * Parameters: None
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_new_now_local(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GDateTime * native_return_value = g_date_time_new_now_local();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_new_now_utc_FUNCTION
#define g_date_time_new_now_utc_REQUIRED_ARGC 0
#define g_date_time_new_now_utc_OPTIONAL_ARGC 0
/* g_date_time_new_now_utc
 *
 * Parameters: None
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_new_now_utc(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GDateTime * native_return_value = g_date_time_new_now_utc();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_new_utc_FUNCTION
#define g_date_time_new_utc_REQUIRED_ARGC 6
#define g_date_time_new_utc_OPTIONAL_ARGC 0
/* g_date_time_new_utc
 *
 * Parameters:
 * - year: int
 * - month: int
 * - day: int
 * - hour: int
 * - minute: int
 * - seconds: double
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_new_utc(mrb_state* mrb, mrb_value self) {
  mrb_int native_year;
  mrb_int native_month;
  mrb_int native_day;
  mrb_int native_hour;
  mrb_int native_minute;
  double native_seconds;

  /* Fetch the args */
  mrb_get_args(mrb, "iiiiif", &native_year, &native_month, &native_day, &native_hour, &native_minute, &native_seconds);

  /* Invocation */
  GDateTime * native_return_value = g_date_time_new_utc(native_year, native_month, native_day, native_hour, native_minute, native_seconds);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_ref_FUNCTION
#define g_date_time_ref_REQUIRED_ARGC 1
#define g_date_time_ref_OPTIONAL_ARGC 0
/* g_date_time_ref
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_ref(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_ref(native_datetime);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_to_local_FUNCTION
#define g_date_time_to_local_REQUIRED_ARGC 1
#define g_date_time_to_local_OPTIONAL_ARGC 0
/* g_date_time_to_local
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_to_local(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_to_local(native_datetime);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_to_timeval_FUNCTION
#define g_date_time_to_timeval_REQUIRED_ARGC 2
#define g_date_time_to_timeval_OPTIONAL_ARGC 0
/* g_date_time_to_timeval
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - tv: struct _GTimeVal *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_time_to_timeval(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_value tv;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &datetime, &tv);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tv, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  struct _GTimeVal * native_tv = (mrb_nil_p(tv) ? NULL : mruby_unbox__GTimeVal(tv));

  /* Invocation */
  gboolean native_return_value = g_date_time_to_timeval(native_datetime, native_tv);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_to_timezone_FUNCTION
#define g_date_time_to_timezone_REQUIRED_ARGC 2
#define g_date_time_to_timezone_OPTIONAL_ARGC 0
/* g_date_time_to_timezone
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * - tz: struct _GTimeZone *
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_to_timezone(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;
  mrb_value tz;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &datetime, &tz);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, tz, GTimeZone_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeZone expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  struct _GTimeZone * native_tz = (mrb_nil_p(tz) ? NULL : mruby_unbox__GTimeZone(tz));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_to_timezone(native_datetime, native_tz);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_to_unix_FUNCTION
#define g_date_time_to_unix_REQUIRED_ARGC 1
#define g_date_time_to_unix_OPTIONAL_ARGC 0
/* g_date_time_to_unix
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: gint64
 */
mrb_value
mrb_GLib_g_date_time_to_unix(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  gint64 native_return_value = g_date_time_to_unix(native_datetime);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint64(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_time_to_utc_FUNCTION
#define g_date_time_to_utc_REQUIRED_ARGC 1
#define g_date_time_to_utc_OPTIONAL_ARGC 0
/* g_date_time_to_utc
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: GDateTime *
 */
mrb_value
mrb_GLib_g_date_time_to_utc(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  GDateTime * native_return_value = g_date_time_to_utc(native_datetime);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDateTime(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_date_time_unref_FUNCTION
#define g_date_time_unref_REQUIRED_ARGC 1
#define g_date_time_unref_OPTIONAL_ARGC 0
/* g_date_time_unref
 *
 * Parameters:
 * - datetime: struct _GDateTime *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_time_unref(mrb_state* mrb, mrb_value self) {
  mrb_value datetime;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &datetime);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, datetime, GDateTime_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDateTime expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDateTime * native_datetime = (mrb_nil_p(datetime) ? NULL : mruby_unbox__GDateTime(datetime));

  /* Invocation */
  g_date_time_unref(native_datetime);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_to_struct_tm_FUNCTION
#define g_date_to_struct_tm_REQUIRED_ARGC 2
#define g_date_to_struct_tm_OPTIONAL_ARGC 0
/* g_date_to_struct_tm
 *
 * Parameters:
 * - date: const struct _GDate *
 * - tm: struct tm *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_date_to_struct_tm(mrb_state* mrb, mrb_value self) {
  mrb_value date;
  mrb_value tm;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &date, &tm);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }
  TODO_type_check_tm_PTR(tm);

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  struct tm * native_tm = TODO_mruby_unbox_tm_PTR(tm);

  /* Invocation */
  g_date_to_struct_tm(native_date, native_tm);

  return mrb_nil_value();
}
#endif

#if BIND_g_date_valid_FUNCTION
#define g_date_valid_REQUIRED_ARGC 1
#define g_date_valid_OPTIONAL_ARGC 0
/* g_date_valid
 *
 * Parameters:
 * - date: const struct _GDate *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_valid(mrb_state* mrb, mrb_value self) {
  mrb_value date;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &date);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, date, GDate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDate * native_date = (mrb_nil_p(date) ? NULL : mruby_unbox__GDate(date));

  /* Invocation */
  gboolean native_return_value = g_date_valid(native_date);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_valid_day_FUNCTION
#define g_date_valid_day_REQUIRED_ARGC 1
#define g_date_valid_day_OPTIONAL_ARGC 0
/* g_date_valid_day
 *
 * Parameters:
 * - day: unsigned char
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_valid_day(mrb_state* mrb, mrb_value self) {
  mrb_int native_day;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_day);

  /* Invocation */
  gboolean native_return_value = g_date_valid_day(native_day);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_valid_dmy_FUNCTION
#define g_date_valid_dmy_REQUIRED_ARGC 3
#define g_date_valid_dmy_OPTIONAL_ARGC 0
/* g_date_valid_dmy
 *
 * Parameters:
 * - day: unsigned char
 * - month: GDateMonth
 * - year: unsigned short
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_valid_dmy(mrb_state* mrb, mrb_value self) {
  mrb_int native_day;
  mrb_int native_month;
  mrb_int native_year;

  /* Fetch the args */
  mrb_get_args(mrb, "iii", &native_day, &native_month, &native_year);

  /* Invocation */
  gboolean native_return_value = g_date_valid_dmy(native_day, native_month, native_year);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_valid_julian_FUNCTION
#define g_date_valid_julian_REQUIRED_ARGC 1
#define g_date_valid_julian_OPTIONAL_ARGC 0
/* g_date_valid_julian
 *
 * Parameters:
 * - julian_date: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_valid_julian(mrb_state* mrb, mrb_value self) {
  mrb_int native_julian_date;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_julian_date);

  /* Invocation */
  gboolean native_return_value = g_date_valid_julian(native_julian_date);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_valid_month_FUNCTION
#define g_date_valid_month_REQUIRED_ARGC 1
#define g_date_valid_month_OPTIONAL_ARGC 0
/* g_date_valid_month
 *
 * Parameters:
 * - month: GDateMonth
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_valid_month(mrb_state* mrb, mrb_value self) {
  mrb_int native_month;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_month);

  /* Invocation */
  gboolean native_return_value = g_date_valid_month(native_month);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_valid_weekday_FUNCTION
#define g_date_valid_weekday_REQUIRED_ARGC 1
#define g_date_valid_weekday_OPTIONAL_ARGC 0
/* g_date_valid_weekday
 *
 * Parameters:
 * - weekday: GDateWeekday
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_valid_weekday(mrb_state* mrb, mrb_value self) {
  mrb_int native_weekday;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_weekday);

  /* Invocation */
  gboolean native_return_value = g_date_valid_weekday(native_weekday);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_date_valid_year_FUNCTION
#define g_date_valid_year_REQUIRED_ARGC 1
#define g_date_valid_year_OPTIONAL_ARGC 0
/* g_date_valid_year
 *
 * Parameters:
 * - year: unsigned short
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_date_valid_year(mrb_state* mrb, mrb_value self) {
  mrb_int native_year;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_year);

  /* Invocation */
  gboolean native_return_value = g_date_valid_year(native_year);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_dcgettext_FUNCTION
#define g_dcgettext_REQUIRED_ARGC 3
#define g_dcgettext_OPTIONAL_ARGC 0
/* g_dcgettext
 *
 * Parameters:
 * - domain: const char *
 * - msgid: const char *
 * - category: int
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_dcgettext(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_msgid = NULL;
  mrb_int native_category;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &native_domain, &native_msgid, &native_category);

  /* Invocation */
  const gchar * native_return_value = g_dcgettext(native_domain, native_msgid, native_category);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_dgettext_FUNCTION
#define g_dgettext_REQUIRED_ARGC 2
#define g_dgettext_OPTIONAL_ARGC 0
/* g_dgettext
 *
 * Parameters:
 * - domain: const char *
 * - msgid: const char *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_dgettext(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_msgid = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_domain, &native_msgid);

  /* Invocation */
  const gchar * native_return_value = g_dgettext(native_domain, native_msgid);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_dir_close_FUNCTION
#define g_dir_close_REQUIRED_ARGC 1
#define g_dir_close_OPTIONAL_ARGC 0
/* g_dir_close
 *
 * Parameters:
 * - dir: struct _GDir *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_dir_close(mrb_state* mrb, mrb_value self) {
  mrb_value dir;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &dir);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dir, GDir_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDir expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDir * native_dir = (mrb_nil_p(dir) ? NULL : mruby_unbox__GDir(dir));

  /* Invocation */
  g_dir_close(native_dir);

  return mrb_nil_value();
}
#endif

#if BIND_g_dir_make_tmp_FUNCTION
#define g_dir_make_tmp_REQUIRED_ARGC 1
#define g_dir_make_tmp_OPTIONAL_ARGC 0
/* g_dir_make_tmp
 *
 * Parameters:
 * - tmpl: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_dir_make_tmp(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_tmpl = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_tmpl);

  /* Invocation */
  gchar * native_return_value = g_dir_make_tmp(native_tmpl, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_dir_open_FUNCTION
#define g_dir_open_REQUIRED_ARGC 2
#define g_dir_open_OPTIONAL_ARGC 0
/* g_dir_open
 *
 * Parameters:
 * - path: const char *
 * - flags: unsigned int
 * Return Type: GDir *
 */
mrb_value
mrb_GLib_g_dir_open(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_path = NULL;
  mrb_int native_flags;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_path, &native_flags);

  /* Invocation */
  GDir * native_return_value = g_dir_open(native_path, native_flags, &native_error);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GDir(mrb, native_return_value));
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_dir_read_name_FUNCTION
#define g_dir_read_name_REQUIRED_ARGC 1
#define g_dir_read_name_OPTIONAL_ARGC 0
/* g_dir_read_name
 *
 * Parameters:
 * - dir: struct _GDir *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_dir_read_name(mrb_state* mrb, mrb_value self) {
  mrb_value dir;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &dir);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dir, GDir_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDir expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDir * native_dir = (mrb_nil_p(dir) ? NULL : mruby_unbox__GDir(dir));

  /* Invocation */
  const gchar * native_return_value = g_dir_read_name(native_dir);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_dir_rewind_FUNCTION
#define g_dir_rewind_REQUIRED_ARGC 1
#define g_dir_rewind_OPTIONAL_ARGC 0
/* g_dir_rewind
 *
 * Parameters:
 * - dir: struct _GDir *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_dir_rewind(mrb_state* mrb, mrb_value self) {
  mrb_value dir;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &dir);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dir, GDir_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDir expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GDir * native_dir = (mrb_nil_p(dir) ? NULL : mruby_unbox__GDir(dir));

  /* Invocation */
  g_dir_rewind(native_dir);

  return mrb_nil_value();
}
#endif

#if BIND_g_direct_equal_FUNCTION
#define g_direct_equal_REQUIRED_ARGC 2
#define g_direct_equal_OPTIONAL_ARGC 0
/* g_direct_equal
 *
 * Parameters:
 * - v1: const void *
 * - v2: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_direct_equal(mrb_state* mrb, mrb_value self) {
  mrb_value v1;
  mrb_value v2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &v1, &v2);

  /* Type checking */
  TODO_type_check_void_PTR(v1);
  TODO_type_check_void_PTR(v2);

  /* Unbox parameters */
  const void * native_v1 = TODO_mruby_unbox_void_PTR(v1);

  const void * native_v2 = TODO_mruby_unbox_void_PTR(v2);

  /* Invocation */
  gboolean native_return_value = g_direct_equal(native_v1, native_v2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_direct_hash_FUNCTION
#define g_direct_hash_REQUIRED_ARGC 1
#define g_direct_hash_OPTIONAL_ARGC 0
/* g_direct_hash
 *
 * Parameters:
 * - v: const void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_direct_hash(mrb_state* mrb, mrb_value self) {
  mrb_value v;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &v);

  /* Type checking */
  TODO_type_check_void_PTR(v);

  /* Unbox parameters */
  const void * native_v = TODO_mruby_unbox_void_PTR(v);

  /* Invocation */
  guint native_return_value = g_direct_hash(native_v);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_dngettext_FUNCTION
#define g_dngettext_REQUIRED_ARGC 4
#define g_dngettext_OPTIONAL_ARGC 0
/* g_dngettext
 *
 * Parameters:
 * - domain: const char *
 * - msgid: const char *
 * - msgid_plural: const char *
 * - n: unsigned long
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_dngettext(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_msgid = NULL;
  char * native_msgid_plural = NULL;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!z!i", &native_domain, &native_msgid, &native_msgid_plural, &native_n);

  /* Invocation */
  const gchar * native_return_value = g_dngettext(native_domain, native_msgid, native_msgid_plural, native_n);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_double_equal_FUNCTION
#define g_double_equal_REQUIRED_ARGC 2
#define g_double_equal_OPTIONAL_ARGC 0
/* g_double_equal
 *
 * Parameters:
 * - v1: const void *
 * - v2: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_double_equal(mrb_state* mrb, mrb_value self) {
  mrb_value v1;
  mrb_value v2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &v1, &v2);

  /* Type checking */
  TODO_type_check_void_PTR(v1);
  TODO_type_check_void_PTR(v2);

  /* Unbox parameters */
  const void * native_v1 = TODO_mruby_unbox_void_PTR(v1);

  const void * native_v2 = TODO_mruby_unbox_void_PTR(v2);

  /* Invocation */
  gboolean native_return_value = g_double_equal(native_v1, native_v2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_double_hash_FUNCTION
#define g_double_hash_REQUIRED_ARGC 1
#define g_double_hash_OPTIONAL_ARGC 0
/* g_double_hash
 *
 * Parameters:
 * - v: const void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_double_hash(mrb_state* mrb, mrb_value self) {
  mrb_value v;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &v);

  /* Type checking */
  TODO_type_check_void_PTR(v);

  /* Unbox parameters */
  const void * native_v = TODO_mruby_unbox_void_PTR(v);

  /* Invocation */
  guint native_return_value = g_double_hash(native_v);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_dpgettext_FUNCTION
#define g_dpgettext_REQUIRED_ARGC 3
#define g_dpgettext_OPTIONAL_ARGC 0
/* g_dpgettext
 *
 * Parameters:
 * - domain: const char *
 * - msgctxtid: const char *
 * - msgidoffset: unsigned long
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_dpgettext(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_msgctxtid = NULL;
  mrb_int native_msgidoffset;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &native_domain, &native_msgctxtid, &native_msgidoffset);

  /* Invocation */
  const gchar * native_return_value = g_dpgettext(native_domain, native_msgctxtid, native_msgidoffset);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_dpgettext2_FUNCTION
#define g_dpgettext2_REQUIRED_ARGC 3
#define g_dpgettext2_OPTIONAL_ARGC 0
/* g_dpgettext2
 *
 * Parameters:
 * - domain: const char *
 * - context: const char *
 * - msgid: const char *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_dpgettext2(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_context = NULL;
  char * native_msgid = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!z!", &native_domain, &native_context, &native_msgid);

  /* Invocation */
  const gchar * native_return_value = g_dpgettext2(native_domain, native_context, native_msgid);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_environ_getenv_FUNCTION
#define g_environ_getenv_REQUIRED_ARGC 2
#define g_environ_getenv_OPTIONAL_ARGC 0
/* g_environ_getenv
 *
 * Parameters:
 * - envp: char **
 * - variable: const char *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_environ_getenv(mrb_state* mrb, mrb_value self) {
  mrb_value envp;
  char * native_variable = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &envp, &native_variable);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(envp);

  /* Unbox parameters */
  char ** native_envp = TODO_mruby_unbox_char_PTR_PTR(envp);

  /* Invocation */
  const gchar * native_return_value = g_environ_getenv(native_envp, native_variable);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_environ_setenv_FUNCTION
#define g_environ_setenv_REQUIRED_ARGC 4
#define g_environ_setenv_OPTIONAL_ARGC 0
/* g_environ_setenv
 *
 * Parameters:
 * - envp: char **
 * - variable: const char *
 * - value: const char *
 * - overwrite: int
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_environ_setenv(mrb_state* mrb, mrb_value self) {
  mrb_value envp;
  char * native_variable = NULL;
  char * native_value = NULL;
  mrb_int native_overwrite;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!i", &envp, &native_variable, &native_value, &native_overwrite);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(envp);

  /* Unbox parameters */
  char ** native_envp = TODO_mruby_unbox_char_PTR_PTR(envp);

  /* Invocation */
  gchar ** native_return_value = g_environ_setenv(native_envp, native_variable, native_value, native_overwrite);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_environ_unsetenv_FUNCTION
#define g_environ_unsetenv_REQUIRED_ARGC 2
#define g_environ_unsetenv_OPTIONAL_ARGC 0
/* g_environ_unsetenv
 *
 * Parameters:
 * - envp: char **
 * - variable: const char *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_environ_unsetenv(mrb_state* mrb, mrb_value self) {
  mrb_value envp;
  char * native_variable = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &envp, &native_variable);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(envp);

  /* Unbox parameters */
  char ** native_envp = TODO_mruby_unbox_char_PTR_PTR(envp);

  /* Invocation */
  gchar ** native_return_value = g_environ_unsetenv(native_envp, native_variable);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_error_copy_FUNCTION
#define g_error_copy_REQUIRED_ARGC 1
#define g_error_copy_OPTIONAL_ARGC 0
/* g_error_copy
 *
 * Parameters:
 * - error: const struct _GError *
 * Return Type: GError *
 */
mrb_value
mrb_GLib_g_error_copy(mrb_state* mrb, mrb_value self) {
  mrb_value error;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &error);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, error, GError_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GError expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GError * native_error = (mrb_nil_p(error) ? NULL : mruby_unbox__GError(error));

  /* Invocation */
  GError * native_return_value = g_error_copy(native_error);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_error_free_FUNCTION
#define g_error_free_REQUIRED_ARGC 1
#define g_error_free_OPTIONAL_ARGC 0
/* g_error_free
 *
 * Parameters:
 * - error: struct _GError *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_error_free(mrb_state* mrb, mrb_value self) {
  mrb_value error;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &error);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, error, GError_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GError expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GError * native_error = (mrb_nil_p(error) ? NULL : mruby_unbox__GError(error));

  /* Invocation */
  g_error_free(native_error);

  return mrb_nil_value();
}
#endif

#if BIND_g_error_matches_FUNCTION
#define g_error_matches_REQUIRED_ARGC 3
#define g_error_matches_OPTIONAL_ARGC 0
/* g_error_matches
 *
 * Parameters:
 * - error: const struct _GError *
 * - domain: unsigned int
 * - code: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_error_matches(mrb_state* mrb, mrb_value self) {
  mrb_value error;
  mrb_int native_domain;
  mrb_int native_code;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &error, &native_domain, &native_code);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, error, GError_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GError expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GError * native_error = (mrb_nil_p(error) ? NULL : mruby_unbox__GError(error));

  /* Invocation */
  gboolean native_return_value = g_error_matches(native_error, native_domain, native_code);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_error_new_FUNCTION
#define g_error_new_REQUIRED_ARGC 3
#define g_error_new_OPTIONAL_ARGC 0
/* g_error_new
 *
 * Parameters:
 * - domain: unsigned int
 * - code: int
 * - format: const char *
 * Return Type: GError *
 */
mrb_value
mrb_GLib_g_error_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_domain;
  mrb_int native_code;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "iiz!", &native_domain, &native_code, &native_format);

  /* Invocation */
  GError * native_return_value = g_error_new(native_domain, native_code, native_format);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_error_new_literal_FUNCTION
#define g_error_new_literal_REQUIRED_ARGC 3
#define g_error_new_literal_OPTIONAL_ARGC 0
/* g_error_new_literal
 *
 * Parameters:
 * - domain: unsigned int
 * - code: int
 * - message: const char *
 * Return Type: GError *
 */
mrb_value
mrb_GLib_g_error_new_literal(mrb_state* mrb, mrb_value self) {
  mrb_int native_domain;
  mrb_int native_code;
  char * native_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "iiz!", &native_domain, &native_code, &native_message);

  /* Invocation */
  GError * native_return_value = g_error_new_literal(native_domain, native_code, native_message);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_error_new_valist_FUNCTION
#define g_error_new_valist_REQUIRED_ARGC 4
#define g_error_new_valist_OPTIONAL_ARGC 0
/* g_error_new_valist
 *
 * Parameters:
 * - domain: unsigned int
 * - code: int
 * - format: const char *
 * - args: int
 * Return Type: GError *
 */
mrb_value
mrb_GLib_g_error_new_valist(mrb_state* mrb, mrb_value self) {
  mrb_int native_domain;
  mrb_int native_code;
  char * native_format = NULL;
  mrb_int native_args;

  /* Fetch the args */
  mrb_get_args(mrb, "iiz!i", &native_domain, &native_code, &native_format, &native_args);

  /* Invocation */
  GError * native_return_value = g_error_new_valist(native_domain, native_code, native_format, native_args);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_file_error_from_errno_FUNCTION
#define g_file_error_from_errno_REQUIRED_ARGC 1
#define g_file_error_from_errno_OPTIONAL_ARGC 0
/* g_file_error_from_errno
 *
 * Parameters:
 * - err_no: int
 * Return Type: GFileError
 */
mrb_value
mrb_GLib_g_file_error_from_errno(mrb_state* mrb, mrb_value self) {
  mrb_int native_err_no;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_err_no);

  /* Invocation */
  GFileError native_return_value = g_file_error_from_errno(native_err_no);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_file_error_quark_FUNCTION
#define g_file_error_quark_REQUIRED_ARGC 0
#define g_file_error_quark_OPTIONAL_ARGC 0
/* g_file_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_file_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_file_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_file_get_contents_FUNCTION
#define g_file_get_contents_REQUIRED_ARGC 1
#define g_file_get_contents_OPTIONAL_ARGC 0
/* g_file_get_contents
 *
 * Parameters:
 * - filename: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_file_get_contents(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_filename = NULL;
  char * native_contents = NULL;
  int native_length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_filename);

  /* Invocation */
  gboolean native_return_value = g_file_get_contents(native_filename, &native_contents, &native_length, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value contents = mrb_str_new_cstr(mrb, native_contents);
  free(native_contents);
  mrb_ary_push(mrb, results, contents);
  mrb_value length = mrb_fixnum_value(native_length);
  mrb_ary_push(mrb, results, length);
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_file_open_tmp_FUNCTION
#define g_file_open_tmp_REQUIRED_ARGC 2
#define g_file_open_tmp_OPTIONAL_ARGC 0
/* g_file_open_tmp
 *
 * Parameters:
 * - tmpl: const char *
 * - name_used: char **
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_file_open_tmp(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_tmpl = NULL;
  mrb_value name_used;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_tmpl, &name_used);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(name_used);

  /* Unbox parameters */
  char ** native_name_used = TODO_mruby_unbox_char_PTR_PTR(name_used);

  /* Invocation */
  gint native_return_value = g_file_open_tmp(native_tmpl, native_name_used, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_file_read_link_FUNCTION
#define g_file_read_link_REQUIRED_ARGC 1
#define g_file_read_link_OPTIONAL_ARGC 0
/* g_file_read_link
 *
 * Parameters:
 * - filename: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_file_read_link(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_filename = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_filename);

  /* Invocation */
  gchar * native_return_value = g_file_read_link(native_filename, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_file_set_contents_FUNCTION
#define g_file_set_contents_REQUIRED_ARGC 3
#define g_file_set_contents_OPTIONAL_ARGC 0
/* g_file_set_contents
 *
 * Parameters:
 * - filename: const char *
 * - contents: const char *
 * - length: long
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_file_set_contents(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_filename = NULL;
  char * native_contents = NULL;
  mrb_int native_length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &native_filename, &native_contents, &native_length);

  /* Invocation */
  gboolean native_return_value = g_file_set_contents(native_filename, native_contents, native_length, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_file_test_FUNCTION
#define g_file_test_REQUIRED_ARGC 2
#define g_file_test_OPTIONAL_ARGC 0
/* g_file_test
 *
 * Parameters:
 * - filename: const char *
 * - test: GFileTest
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_file_test(mrb_state* mrb, mrb_value self) {
  char * native_filename = NULL;
  mrb_int native_test;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_filename, &native_test);

  /* Invocation */
  gboolean native_return_value = g_file_test(native_filename, native_test);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_filename_display_basename_FUNCTION
#define g_filename_display_basename_REQUIRED_ARGC 1
#define g_filename_display_basename_OPTIONAL_ARGC 0
/* g_filename_display_basename
 *
 * Parameters:
 * - filename: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_filename_display_basename(mrb_state* mrb, mrb_value self) {
  char * native_filename = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_filename);

  /* Invocation */
  gchar * native_return_value = g_filename_display_basename(native_filename);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_filename_display_name_FUNCTION
#define g_filename_display_name_REQUIRED_ARGC 1
#define g_filename_display_name_OPTIONAL_ARGC 0
/* g_filename_display_name
 *
 * Parameters:
 * - filename: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_filename_display_name(mrb_state* mrb, mrb_value self) {
  char * native_filename = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_filename);

  /* Invocation */
  gchar * native_return_value = g_filename_display_name(native_filename);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_filename_from_uri_FUNCTION
#define g_filename_from_uri_REQUIRED_ARGC 2
#define g_filename_from_uri_OPTIONAL_ARGC 0
/* g_filename_from_uri
 *
 * Parameters:
 * - uri: const char *
 * - hostname: char **
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_filename_from_uri(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_uri = NULL;
  mrb_value hostname;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_uri, &hostname);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(hostname);

  /* Unbox parameters */
  char ** native_hostname = TODO_mruby_unbox_char_PTR_PTR(hostname);

  /* Invocation */
  gchar * native_return_value = g_filename_from_uri(native_uri, native_hostname, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_filename_from_utf8_FUNCTION
#define g_filename_from_utf8_REQUIRED_ARGC 4
#define g_filename_from_utf8_OPTIONAL_ARGC 0
/* g_filename_from_utf8
 *
 * Parameters:
 * - utf8string: const char *
 * - len: long
 * - bytes_read: unsigned long *
 * - bytes_written: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_filename_from_utf8(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_utf8string = NULL;
  mrb_int native_len;
  mrb_value bytes_read;
  mrb_value bytes_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ioo", &native_utf8string, &native_len, &bytes_read, &bytes_written);

  /* Type checking */
  TODO_type_check_unsigned_long_PTR(bytes_read);
  TODO_type_check_unsigned_long_PTR(bytes_written);

  /* Unbox parameters */
  unsigned long * native_bytes_read = TODO_mruby_unbox_unsigned_long_PTR(bytes_read);

  unsigned long * native_bytes_written = TODO_mruby_unbox_unsigned_long_PTR(bytes_written);

  /* Invocation */
  gchar * native_return_value = g_filename_from_utf8(native_utf8string, native_len, native_bytes_read, native_bytes_written, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_filename_to_uri_FUNCTION
#define g_filename_to_uri_REQUIRED_ARGC 2
#define g_filename_to_uri_OPTIONAL_ARGC 0
/* g_filename_to_uri
 *
 * Parameters:
 * - filename: const char *
 * - hostname: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_filename_to_uri(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_filename = NULL;
  char * native_hostname = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_filename, &native_hostname);

  /* Invocation */
  gchar * native_return_value = g_filename_to_uri(native_filename, native_hostname, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_filename_to_utf8_FUNCTION
#define g_filename_to_utf8_REQUIRED_ARGC 4
#define g_filename_to_utf8_OPTIONAL_ARGC 0
/* g_filename_to_utf8
 *
 * Parameters:
 * - opsysstring: const char *
 * - len: long
 * - bytes_read: unsigned long *
 * - bytes_written: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_filename_to_utf8(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_opsysstring = NULL;
  mrb_int native_len;
  mrb_value bytes_read;
  mrb_value bytes_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ioo", &native_opsysstring, &native_len, &bytes_read, &bytes_written);

  /* Type checking */
  TODO_type_check_unsigned_long_PTR(bytes_read);
  TODO_type_check_unsigned_long_PTR(bytes_written);

  /* Unbox parameters */
  unsigned long * native_bytes_read = TODO_mruby_unbox_unsigned_long_PTR(bytes_read);

  unsigned long * native_bytes_written = TODO_mruby_unbox_unsigned_long_PTR(bytes_written);

  /* Invocation */
  gchar * native_return_value = g_filename_to_utf8(native_opsysstring, native_len, native_bytes_read, native_bytes_written, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_find_program_in_path_FUNCTION
#define g_find_program_in_path_REQUIRED_ARGC 1
#define g_find_program_in_path_OPTIONAL_ARGC 0
/* g_find_program_in_path
 *
 * Parameters:
 * - program: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_find_program_in_path(mrb_state* mrb, mrb_value self) {
  char * native_program = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_program);

  /* Invocation */
  gchar * native_return_value = g_find_program_in_path(native_program);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_format_size_FUNCTION
#define g_format_size_REQUIRED_ARGC 1
#define g_format_size_OPTIONAL_ARGC 0
/* g_format_size
 *
 * Parameters:
 * - size: unsigned long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_format_size(mrb_state* mrb, mrb_value self) {
  mrb_int native_size;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_size);

  /* Invocation */
  gchar * native_return_value = g_format_size(native_size);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_format_size_for_display_FUNCTION
#define g_format_size_for_display_REQUIRED_ARGC 1
#define g_format_size_for_display_OPTIONAL_ARGC 0
/* g_format_size_for_display
 *
 * Parameters:
 * - size: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_format_size_for_display(mrb_state* mrb, mrb_value self) {
  mrb_int native_size;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_size);

  /* Invocation */
  gchar * native_return_value = g_format_size_for_display(native_size);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_format_size_full_FUNCTION
#define g_format_size_full_REQUIRED_ARGC 2
#define g_format_size_full_OPTIONAL_ARGC 0
/* g_format_size_full
 *
 * Parameters:
 * - size: unsigned long
 * - flags: GFormatSizeFlags
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_format_size_full(mrb_state* mrb, mrb_value self) {
  mrb_int native_size;
  mrb_int native_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_size, &native_flags);

  /* Invocation */
  gchar * native_return_value = g_format_size_full(native_size, native_flags);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_fprintf_FUNCTION
#define g_fprintf_REQUIRED_ARGC 2
#define g_fprintf_OPTIONAL_ARGC 0
/* g_fprintf
 *
 * Parameters:
 * - file: struct __sFILE *
 * - format: const char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_fprintf(mrb_state* mrb, mrb_value self) {
  mrb_value file;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &file, &native_format);

  /* Type checking */
  TODO_type_check___sFILE_PTR(file);

  /* Unbox parameters */
  struct __sFILE * native_file = TODO_mruby_unbox___sFILE_PTR(file);

  /* Invocation */
  gint native_return_value = g_fprintf(native_file, native_format);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_free_FUNCTION
#define g_free_REQUIRED_ARGC 1
#define g_free_OPTIONAL_ARGC 0
/* g_free
 *
 * Parameters:
 * - mem: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_free(mrb_state* mrb, mrb_value self) {
  mrb_value mem;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &mem);

  /* Type checking */
  TODO_type_check_void_PTR(mem);

  /* Unbox parameters */
  void * native_mem = TODO_mruby_unbox_void_PTR(mem);

  /* Invocation */
  g_free(native_mem);

  return mrb_nil_value();
}
#endif

#if BIND_g_get_application_name_FUNCTION
#define g_get_application_name_REQUIRED_ARGC 0
#define g_get_application_name_OPTIONAL_ARGC 0
/* g_get_application_name
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_application_name(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_application_name();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_charset_FUNCTION
#define g_get_charset_REQUIRED_ARGC 1
#define g_get_charset_OPTIONAL_ARGC 0
/* g_get_charset
 *
 * Parameters:
 * - charset: const char **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_get_charset(mrb_state* mrb, mrb_value self) {
  mrb_value charset;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &charset);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(charset);

  /* Unbox parameters */
  const char ** native_charset = TODO_mruby_unbox_char_PTR_PTR(charset);

  /* Invocation */
  gboolean native_return_value = g_get_charset(native_charset);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_codeset_FUNCTION
#define g_get_codeset_REQUIRED_ARGC 0
#define g_get_codeset_OPTIONAL_ARGC 0
/* g_get_codeset
 *
 * Parameters: None
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_get_codeset(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gchar * native_return_value = g_get_codeset();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_current_dir_FUNCTION
#define g_get_current_dir_REQUIRED_ARGC 0
#define g_get_current_dir_OPTIONAL_ARGC 0
/* g_get_current_dir
 *
 * Parameters: None
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_get_current_dir(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gchar * native_return_value = g_get_current_dir();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_current_time_FUNCTION
#define g_get_current_time_REQUIRED_ARGC 1
#define g_get_current_time_OPTIONAL_ARGC 0
/* g_get_current_time
 *
 * Parameters:
 * - result: struct _GTimeVal *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_get_current_time(mrb_state* mrb, mrb_value self) {
  mrb_value result;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &result);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, result, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeVal * native_result = (mrb_nil_p(result) ? NULL : mruby_unbox__GTimeVal(result));

  /* Invocation */
  g_get_current_time(native_result);

  return mrb_nil_value();
}
#endif

#if BIND_g_get_environ_FUNCTION
#define g_get_environ_REQUIRED_ARGC 0
#define g_get_environ_OPTIONAL_ARGC 0
/* g_get_environ
 *
 * Parameters: None
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_get_environ(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gchar ** native_return_value = g_get_environ();

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_filename_charsets_FUNCTION
#define g_get_filename_charsets_REQUIRED_ARGC 1
#define g_get_filename_charsets_OPTIONAL_ARGC 0
/* g_get_filename_charsets
 *
 * Parameters:
 * - charsets: const char ***
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_get_filename_charsets(mrb_state* mrb, mrb_value self) {
  mrb_value charsets;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &charsets);

  /* Type checking */
  TODO_type_check_char_PTR_PTR_PTR(charsets);

  /* Unbox parameters */
  const char *** native_charsets = TODO_mruby_unbox_char_PTR_PTR_PTR(charsets);

  /* Invocation */
  gboolean native_return_value = g_get_filename_charsets(native_charsets);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_home_dir_FUNCTION
#define g_get_home_dir_REQUIRED_ARGC 0
#define g_get_home_dir_OPTIONAL_ARGC 0
/* g_get_home_dir
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_home_dir(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_home_dir();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_host_name_FUNCTION
#define g_get_host_name_REQUIRED_ARGC 0
#define g_get_host_name_OPTIONAL_ARGC 0
/* g_get_host_name
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_host_name(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_host_name();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_language_names_FUNCTION
#define g_get_language_names_REQUIRED_ARGC 0
#define g_get_language_names_OPTIONAL_ARGC 0
/* g_get_language_names
 *
 * Parameters: None
 * Return Type: const gchar *const *
 */
mrb_value
mrb_GLib_g_get_language_names(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar *const * native_return_value = g_get_language_names();

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_const_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_locale_variants_FUNCTION
#define g_get_locale_variants_REQUIRED_ARGC 1
#define g_get_locale_variants_OPTIONAL_ARGC 0
/* g_get_locale_variants
 *
 * Parameters:
 * - locale: const char *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_get_locale_variants(mrb_state* mrb, mrb_value self) {
  char * native_locale = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_locale);

  /* Invocation */
  gchar ** native_return_value = g_get_locale_variants(native_locale);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_monotonic_time_FUNCTION
#define g_get_monotonic_time_REQUIRED_ARGC 0
#define g_get_monotonic_time_OPTIONAL_ARGC 0
/* g_get_monotonic_time
 *
 * Parameters: None
 * Return Type: gint64
 */
mrb_value
mrb_GLib_g_get_monotonic_time(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gint64 native_return_value = g_get_monotonic_time();

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint64(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_num_processors_FUNCTION
#define g_get_num_processors_REQUIRED_ARGC 0
#define g_get_num_processors_OPTIONAL_ARGC 0
/* g_get_num_processors
 *
 * Parameters: None
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_get_num_processors(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  guint native_return_value = g_get_num_processors();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_prgname_FUNCTION
#define g_get_prgname_REQUIRED_ARGC 0
#define g_get_prgname_OPTIONAL_ARGC 0
/* g_get_prgname
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_prgname(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_prgname();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_real_name_FUNCTION
#define g_get_real_name_REQUIRED_ARGC 0
#define g_get_real_name_OPTIONAL_ARGC 0
/* g_get_real_name
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_real_name(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_real_name();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_real_time_FUNCTION
#define g_get_real_time_REQUIRED_ARGC 0
#define g_get_real_time_OPTIONAL_ARGC 0
/* g_get_real_time
 *
 * Parameters: None
 * Return Type: gint64
 */
mrb_value
mrb_GLib_g_get_real_time(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gint64 native_return_value = g_get_real_time();

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint64(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_system_config_dirs_FUNCTION
#define g_get_system_config_dirs_REQUIRED_ARGC 0
#define g_get_system_config_dirs_OPTIONAL_ARGC 0
/* g_get_system_config_dirs
 *
 * Parameters: None
 * Return Type: const gchar *const *
 */
mrb_value
mrb_GLib_g_get_system_config_dirs(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar *const * native_return_value = g_get_system_config_dirs();

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_const_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_system_data_dirs_FUNCTION
#define g_get_system_data_dirs_REQUIRED_ARGC 0
#define g_get_system_data_dirs_OPTIONAL_ARGC 0
/* g_get_system_data_dirs
 *
 * Parameters: None
 * Return Type: const gchar *const *
 */
mrb_value
mrb_GLib_g_get_system_data_dirs(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar *const * native_return_value = g_get_system_data_dirs();

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_const_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_tmp_dir_FUNCTION
#define g_get_tmp_dir_REQUIRED_ARGC 0
#define g_get_tmp_dir_OPTIONAL_ARGC 0
/* g_get_tmp_dir
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_tmp_dir(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_tmp_dir();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_user_cache_dir_FUNCTION
#define g_get_user_cache_dir_REQUIRED_ARGC 0
#define g_get_user_cache_dir_OPTIONAL_ARGC 0
/* g_get_user_cache_dir
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_user_cache_dir(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_user_cache_dir();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_user_config_dir_FUNCTION
#define g_get_user_config_dir_REQUIRED_ARGC 0
#define g_get_user_config_dir_OPTIONAL_ARGC 0
/* g_get_user_config_dir
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_user_config_dir(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_user_config_dir();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_user_data_dir_FUNCTION
#define g_get_user_data_dir_REQUIRED_ARGC 0
#define g_get_user_data_dir_OPTIONAL_ARGC 0
/* g_get_user_data_dir
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_user_data_dir(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_user_data_dir();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_user_name_FUNCTION
#define g_get_user_name_REQUIRED_ARGC 0
#define g_get_user_name_OPTIONAL_ARGC 0
/* g_get_user_name
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_user_name(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_user_name();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_user_runtime_dir_FUNCTION
#define g_get_user_runtime_dir_REQUIRED_ARGC 0
#define g_get_user_runtime_dir_OPTIONAL_ARGC 0
/* g_get_user_runtime_dir
 *
 * Parameters: None
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_user_runtime_dir(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  const gchar * native_return_value = g_get_user_runtime_dir();

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_get_user_special_dir_FUNCTION
#define g_get_user_special_dir_REQUIRED_ARGC 1
#define g_get_user_special_dir_OPTIONAL_ARGC 0
/* g_get_user_special_dir
 *
 * Parameters:
 * - directory: GUserDirectory
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_get_user_special_dir(mrb_state* mrb, mrb_value self) {
  mrb_int native_directory;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_directory);

  /* Invocation */
  const gchar * native_return_value = g_get_user_special_dir(native_directory);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_getenv_FUNCTION
#define g_getenv_REQUIRED_ARGC 1
#define g_getenv_OPTIONAL_ARGC 0
/* g_getenv
 *
 * Parameters:
 * - variable: const char *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_getenv(mrb_state* mrb, mrb_value self) {
  char * native_variable = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_variable);

  /* Invocation */
  const gchar * native_return_value = g_getenv(native_variable);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_add_FUNCTION
#define g_hash_table_add_REQUIRED_ARGC 2
#define g_hash_table_add_OPTIONAL_ARGC 0
/* g_hash_table_add
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - key: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hash_table_add(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value key;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hash_table, &key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  void * native_key = TODO_mruby_unbox_void_PTR(key);

  /* Invocation */
  gboolean native_return_value = g_hash_table_add(native_hash_table, native_key);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_contains_FUNCTION
#define g_hash_table_contains_REQUIRED_ARGC 2
#define g_hash_table_contains_OPTIONAL_ARGC 0
/* g_hash_table_contains
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - key: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hash_table_contains(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value key;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hash_table, &key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  const void * native_key = TODO_mruby_unbox_void_PTR(key);

  /* Invocation */
  gboolean native_return_value = g_hash_table_contains(native_hash_table, native_key);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_destroy_FUNCTION
#define g_hash_table_destroy_REQUIRED_ARGC 1
#define g_hash_table_destroy_OPTIONAL_ARGC 0
/* g_hash_table_destroy
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hash_table_destroy(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hash_table);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  /* Invocation */
  g_hash_table_destroy(native_hash_table);

  return mrb_nil_value();
}
#endif

#if BIND_g_hash_table_find_FUNCTION
#define g_hash_table_find_REQUIRED_ARGC 3
#define g_hash_table_find_OPTIONAL_ARGC 0
/* g_hash_table_find
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - predicate: int (*)(void *, void *, void *)
 * - user_data: void *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_hash_table_find(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value predicate;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &hash_table, &predicate, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(predicate);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  int (*native_predicate)(void *, void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(predicate);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  gpointer native_return_value = g_hash_table_find(native_hash_table, native_predicate, native_user_data);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_foreach_FUNCTION
#define g_hash_table_foreach_REQUIRED_ARGC 3
#define g_hash_table_foreach_OPTIONAL_ARGC 0
/* g_hash_table_foreach
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - func: void (*)(void *, void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hash_table_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &hash_table, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  void (*native_func)(void *, void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_hash_table_foreach(native_hash_table, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_hash_table_foreach_remove_FUNCTION
#define g_hash_table_foreach_remove_REQUIRED_ARGC 3
#define g_hash_table_foreach_remove_OPTIONAL_ARGC 0
/* g_hash_table_foreach_remove
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - func: int (*)(void *, void *, void *)
 * - user_data: void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_hash_table_foreach_remove(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &hash_table, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  int (*native_func)(void *, void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  guint native_return_value = g_hash_table_foreach_remove(native_hash_table, native_func, native_user_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_foreach_steal_FUNCTION
#define g_hash_table_foreach_steal_REQUIRED_ARGC 3
#define g_hash_table_foreach_steal_OPTIONAL_ARGC 0
/* g_hash_table_foreach_steal
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - func: int (*)(void *, void *, void *)
 * - user_data: void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_hash_table_foreach_steal(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &hash_table, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  int (*native_func)(void *, void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  guint native_return_value = g_hash_table_foreach_steal(native_hash_table, native_func, native_user_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_get_keys_FUNCTION
#define g_hash_table_get_keys_REQUIRED_ARGC 1
#define g_hash_table_get_keys_OPTIONAL_ARGC 0
/* g_hash_table_get_keys
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_hash_table_get_keys(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hash_table);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  /* Invocation */
  GList * native_return_value = g_hash_table_get_keys(native_hash_table);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hash_table_get_keys_as_array_FUNCTION
#define g_hash_table_get_keys_as_array_REQUIRED_ARGC 2
#define g_hash_table_get_keys_as_array_OPTIONAL_ARGC 0
/* g_hash_table_get_keys_as_array
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - length: unsigned int *
 * Return Type: gpointer *
 */
mrb_value
mrb_GLib_g_hash_table_get_keys_as_array(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hash_table, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_int_PTR(length);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  unsigned int * native_length = TODO_mruby_unbox_unsigned_int_PTR(length);

  /* Invocation */
  gpointer * native_return_value = g_hash_table_get_keys_as_array(native_hash_table, native_length);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_get_values_FUNCTION
#define g_hash_table_get_values_REQUIRED_ARGC 1
#define g_hash_table_get_values_OPTIONAL_ARGC 0
/* g_hash_table_get_values
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_hash_table_get_values(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hash_table);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  /* Invocation */
  GList * native_return_value = g_hash_table_get_values(native_hash_table);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hash_table_insert_FUNCTION
#define g_hash_table_insert_REQUIRED_ARGC 3
#define g_hash_table_insert_OPTIONAL_ARGC 0
/* g_hash_table_insert
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - key: void *
 * - value: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hash_table_insert(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &hash_table, &key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);
  TODO_type_check_void_PTR(value);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  void * native_key = TODO_mruby_unbox_void_PTR(key);

  void * native_value = TODO_mruby_unbox_void_PTR(value);

  /* Invocation */
  gboolean native_return_value = g_hash_table_insert(native_hash_table, native_key, native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_iter_get_hash_table_FUNCTION
#define g_hash_table_iter_get_hash_table_REQUIRED_ARGC 1
#define g_hash_table_iter_get_hash_table_OPTIONAL_ARGC 0
/* g_hash_table_iter_get_hash_table
 *
 * Parameters:
 * - iter: struct _GHashTableIter *
 * Return Type: GHashTable *
 */
mrb_value
mrb_GLib_g_hash_table_iter_get_hash_table(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GHashTableIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTableIter expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTableIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GHashTableIter(iter));

  /* Invocation */
  GHashTable * native_return_value = g_hash_table_iter_get_hash_table(native_iter);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHashTable(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hash_table_iter_init_FUNCTION
#define g_hash_table_iter_init_REQUIRED_ARGC 2
#define g_hash_table_iter_init_OPTIONAL_ARGC 0
/* g_hash_table_iter_init
 *
 * Parameters:
 * - iter: struct _GHashTableIter *
 * - hash_table: struct _GHashTable *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hash_table_iter_init(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  mrb_value hash_table;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &iter, &hash_table);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GHashTableIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTableIter expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTableIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GHashTableIter(iter));

  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  /* Invocation */
  g_hash_table_iter_init(native_iter, native_hash_table);

  return mrb_nil_value();
}
#endif

#if BIND_g_hash_table_iter_next_FUNCTION
#define g_hash_table_iter_next_REQUIRED_ARGC 3
#define g_hash_table_iter_next_OPTIONAL_ARGC 0
/* g_hash_table_iter_next
 *
 * Parameters:
 * - iter: struct _GHashTableIter *
 * - key: void **
 * - value: void **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hash_table_iter_next(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  mrb_value key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &iter, &key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GHashTableIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTableIter expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR_PTR(key);
  TODO_type_check_void_PTR_PTR(value);

  /* Unbox parameters */
  struct _GHashTableIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GHashTableIter(iter));

  void ** native_key = TODO_mruby_unbox_void_PTR_PTR(key);

  void ** native_value = TODO_mruby_unbox_void_PTR_PTR(value);

  /* Invocation */
  gboolean native_return_value = g_hash_table_iter_next(native_iter, native_key, native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_iter_remove_FUNCTION
#define g_hash_table_iter_remove_REQUIRED_ARGC 1
#define g_hash_table_iter_remove_OPTIONAL_ARGC 0
/* g_hash_table_iter_remove
 *
 * Parameters:
 * - iter: struct _GHashTableIter *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hash_table_iter_remove(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GHashTableIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTableIter expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTableIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GHashTableIter(iter));

  /* Invocation */
  g_hash_table_iter_remove(native_iter);

  return mrb_nil_value();
}
#endif

#if BIND_g_hash_table_iter_replace_FUNCTION
#define g_hash_table_iter_replace_REQUIRED_ARGC 2
#define g_hash_table_iter_replace_OPTIONAL_ARGC 0
/* g_hash_table_iter_replace
 *
 * Parameters:
 * - iter: struct _GHashTableIter *
 * - value: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hash_table_iter_replace(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &iter, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GHashTableIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTableIter expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(value);

  /* Unbox parameters */
  struct _GHashTableIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GHashTableIter(iter));

  void * native_value = TODO_mruby_unbox_void_PTR(value);

  /* Invocation */
  g_hash_table_iter_replace(native_iter, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_hash_table_iter_steal_FUNCTION
#define g_hash_table_iter_steal_REQUIRED_ARGC 1
#define g_hash_table_iter_steal_OPTIONAL_ARGC 0
/* g_hash_table_iter_steal
 *
 * Parameters:
 * - iter: struct _GHashTableIter *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hash_table_iter_steal(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GHashTableIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTableIter expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTableIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GHashTableIter(iter));

  /* Invocation */
  g_hash_table_iter_steal(native_iter);

  return mrb_nil_value();
}
#endif

#if BIND_g_hash_table_lookup_FUNCTION
#define g_hash_table_lookup_REQUIRED_ARGC 2
#define g_hash_table_lookup_OPTIONAL_ARGC 0
/* g_hash_table_lookup
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - key: const void *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_hash_table_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value key;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hash_table, &key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  const void * native_key = TODO_mruby_unbox_void_PTR(key);

  /* Invocation */
  gpointer native_return_value = g_hash_table_lookup(native_hash_table, native_key);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_lookup_extended_FUNCTION
#define g_hash_table_lookup_extended_REQUIRED_ARGC 4
#define g_hash_table_lookup_extended_OPTIONAL_ARGC 0
/* g_hash_table_lookup_extended
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - lookup_key: const void *
 * - orig_key: void **
 * - value: void **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hash_table_lookup_extended(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value lookup_key;
  mrb_value orig_key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &hash_table, &lookup_key, &orig_key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(lookup_key);
  TODO_type_check_void_PTR_PTR(orig_key);
  TODO_type_check_void_PTR_PTR(value);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  const void * native_lookup_key = TODO_mruby_unbox_void_PTR(lookup_key);

  void ** native_orig_key = TODO_mruby_unbox_void_PTR_PTR(orig_key);

  void ** native_value = TODO_mruby_unbox_void_PTR_PTR(value);

  /* Invocation */
  gboolean native_return_value = g_hash_table_lookup_extended(native_hash_table, native_lookup_key, native_orig_key, native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_new_FUNCTION
#define g_hash_table_new_REQUIRED_ARGC 2
#define g_hash_table_new_OPTIONAL_ARGC 0
/* g_hash_table_new
 *
 * Parameters:
 * - hash_func: unsigned int (*)(const void *)
 * - key_equal_func: int (*)(const void *, const void *)
 * Return Type: GHashTable *
 */
mrb_value
mrb_GLib_g_hash_table_new(mrb_state* mrb, mrb_value self) {
  mrb_value hash_func;
  mrb_value key_equal_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hash_func, &key_equal_func);

  /* Type checking */
  TODO_type_check_unsigned_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(hash_func);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(key_equal_func);

  /* Unbox parameters */
  unsigned int (*native_hash_func)(const void *) = TODO_mruby_unbox_unsigned_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(hash_func);

  int (*native_key_equal_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(key_equal_func);

  /* Invocation */
  GHashTable * native_return_value = g_hash_table_new(native_hash_func, native_key_equal_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHashTable(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hash_table_new_full_FUNCTION
#define g_hash_table_new_full_REQUIRED_ARGC 4
#define g_hash_table_new_full_OPTIONAL_ARGC 0
/* g_hash_table_new_full
 *
 * Parameters:
 * - hash_func: unsigned int (*)(const void *)
 * - key_equal_func: int (*)(const void *, const void *)
 * - key_destroy_func: void (*)(void *)
 * - value_destroy_func: void (*)(void *)
 * Return Type: GHashTable *
 */
mrb_value
mrb_GLib_g_hash_table_new_full(mrb_state* mrb, mrb_value self) {
  mrb_value hash_func;
  mrb_value key_equal_func;
  mrb_value key_destroy_func;
  mrb_value value_destroy_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &hash_func, &key_equal_func, &key_destroy_func, &value_destroy_func);

  /* Type checking */
  TODO_type_check_unsigned_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(hash_func);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(key_equal_func);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(key_destroy_func);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(value_destroy_func);

  /* Unbox parameters */
  unsigned int (*native_hash_func)(const void *) = TODO_mruby_unbox_unsigned_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(hash_func);

  int (*native_key_equal_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(key_equal_func);

  void (*native_key_destroy_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(key_destroy_func);

  void (*native_value_destroy_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(value_destroy_func);

  /* Invocation */
  GHashTable * native_return_value = g_hash_table_new_full(native_hash_func, native_key_equal_func, native_key_destroy_func, native_value_destroy_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHashTable(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hash_table_ref_FUNCTION
#define g_hash_table_ref_REQUIRED_ARGC 1
#define g_hash_table_ref_OPTIONAL_ARGC 0
/* g_hash_table_ref
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * Return Type: GHashTable *
 */
mrb_value
mrb_GLib_g_hash_table_ref(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hash_table);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  /* Invocation */
  GHashTable * native_return_value = g_hash_table_ref(native_hash_table);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHashTable(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hash_table_remove_FUNCTION
#define g_hash_table_remove_REQUIRED_ARGC 2
#define g_hash_table_remove_OPTIONAL_ARGC 0
/* g_hash_table_remove
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - key: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hash_table_remove(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value key;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hash_table, &key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  const void * native_key = TODO_mruby_unbox_void_PTR(key);

  /* Invocation */
  gboolean native_return_value = g_hash_table_remove(native_hash_table, native_key);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_remove_all_FUNCTION
#define g_hash_table_remove_all_REQUIRED_ARGC 1
#define g_hash_table_remove_all_OPTIONAL_ARGC 0
/* g_hash_table_remove_all
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hash_table_remove_all(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hash_table);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  /* Invocation */
  g_hash_table_remove_all(native_hash_table);

  return mrb_nil_value();
}
#endif

#if BIND_g_hash_table_replace_FUNCTION
#define g_hash_table_replace_REQUIRED_ARGC 3
#define g_hash_table_replace_OPTIONAL_ARGC 0
/* g_hash_table_replace
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - key: void *
 * - value: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hash_table_replace(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &hash_table, &key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);
  TODO_type_check_void_PTR(value);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  void * native_key = TODO_mruby_unbox_void_PTR(key);

  void * native_value = TODO_mruby_unbox_void_PTR(value);

  /* Invocation */
  gboolean native_return_value = g_hash_table_replace(native_hash_table, native_key, native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_size_FUNCTION
#define g_hash_table_size_REQUIRED_ARGC 1
#define g_hash_table_size_OPTIONAL_ARGC 0
/* g_hash_table_size
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_hash_table_size(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hash_table);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  /* Invocation */
  guint native_return_value = g_hash_table_size(native_hash_table);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_steal_FUNCTION
#define g_hash_table_steal_REQUIRED_ARGC 2
#define g_hash_table_steal_OPTIONAL_ARGC 0
/* g_hash_table_steal
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * - key: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hash_table_steal(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;
  mrb_value key;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hash_table, &key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  const void * native_key = TODO_mruby_unbox_void_PTR(key);

  /* Invocation */
  gboolean native_return_value = g_hash_table_steal(native_hash_table, native_key);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hash_table_steal_all_FUNCTION
#define g_hash_table_steal_all_REQUIRED_ARGC 1
#define g_hash_table_steal_all_OPTIONAL_ARGC 0
/* g_hash_table_steal_all
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hash_table_steal_all(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hash_table);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  /* Invocation */
  g_hash_table_steal_all(native_hash_table);

  return mrb_nil_value();
}
#endif

#if BIND_g_hash_table_unref_FUNCTION
#define g_hash_table_unref_REQUIRED_ARGC 1
#define g_hash_table_unref_OPTIONAL_ARGC 0
/* g_hash_table_unref
 *
 * Parameters:
 * - hash_table: struct _GHashTable *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hash_table_unref(mrb_state* mrb, mrb_value self) {
  mrb_value hash_table;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hash_table);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hash_table, GHashTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHashTable expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHashTable * native_hash_table = (mrb_nil_p(hash_table) ? NULL : mruby_unbox__GHashTable(hash_table));

  /* Invocation */
  g_hash_table_unref(native_hash_table);

  return mrb_nil_value();
}
#endif

#if BIND_g_hmac_copy_FUNCTION
#define g_hmac_copy_REQUIRED_ARGC 1
#define g_hmac_copy_OPTIONAL_ARGC 0
/* g_hmac_copy
 *
 * Parameters:
 * - hmac: const struct _GHmac *
 * Return Type: GHmac *
 */
mrb_value
mrb_GLib_g_hmac_copy(mrb_state* mrb, mrb_value self) {
  mrb_value hmac;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hmac);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hmac, GHmac_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHmac expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GHmac * native_hmac = (mrb_nil_p(hmac) ? NULL : mruby_unbox__GHmac(hmac));

  /* Invocation */
  GHmac * native_return_value = g_hmac_copy(native_hmac);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHmac(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hmac_get_digest_FUNCTION
#define g_hmac_get_digest_REQUIRED_ARGC 3
#define g_hmac_get_digest_OPTIONAL_ARGC 0
/* g_hmac_get_digest
 *
 * Parameters:
 * - hmac: struct _GHmac *
 * - buffer: unsigned char *
 * - digest_len: unsigned long *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hmac_get_digest(mrb_state* mrb, mrb_value self) {
  mrb_value hmac;
  mrb_value buffer;
  mrb_value digest_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &hmac, &buffer, &digest_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hmac, GHmac_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHmac expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_char_PTR(buffer);
  TODO_type_check_unsigned_long_PTR(digest_len);

  /* Unbox parameters */
  struct _GHmac * native_hmac = (mrb_nil_p(hmac) ? NULL : mruby_unbox__GHmac(hmac));

  unsigned char * native_buffer = TODO_mruby_unbox_unsigned_char_PTR(buffer);

  unsigned long * native_digest_len = TODO_mruby_unbox_unsigned_long_PTR(digest_len);

  /* Invocation */
  g_hmac_get_digest(native_hmac, native_buffer, native_digest_len);

  return mrb_nil_value();
}
#endif

#if BIND_g_hmac_get_string_FUNCTION
#define g_hmac_get_string_REQUIRED_ARGC 1
#define g_hmac_get_string_OPTIONAL_ARGC 0
/* g_hmac_get_string
 *
 * Parameters:
 * - hmac: struct _GHmac *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_hmac_get_string(mrb_state* mrb, mrb_value self) {
  mrb_value hmac;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hmac);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hmac, GHmac_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHmac expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHmac * native_hmac = (mrb_nil_p(hmac) ? NULL : mruby_unbox__GHmac(hmac));

  /* Invocation */
  const gchar * native_return_value = g_hmac_get_string(native_hmac);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hmac_new_FUNCTION
#define g_hmac_new_REQUIRED_ARGC 3
#define g_hmac_new_OPTIONAL_ARGC 0
/* g_hmac_new
 *
 * Parameters:
 * - digest_type: GChecksumType
 * - key: const unsigned char *
 * - key_len: unsigned long
 * Return Type: GHmac *
 */
mrb_value
mrb_GLib_g_hmac_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_digest_type;
  mrb_value key;
  mrb_int native_key_len;

  /* Fetch the args */
  mrb_get_args(mrb, "ioi", &native_digest_type, &key, &native_key_len);

  /* Type checking */
  TODO_type_check_unsigned_char_PTR(key);

  /* Unbox parameters */
  const unsigned char * native_key = TODO_mruby_unbox_unsigned_char_PTR(key);

  /* Invocation */
  GHmac * native_return_value = g_hmac_new(native_digest_type, native_key, native_key_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHmac(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hmac_ref_FUNCTION
#define g_hmac_ref_REQUIRED_ARGC 1
#define g_hmac_ref_OPTIONAL_ARGC 0
/* g_hmac_ref
 *
 * Parameters:
 * - hmac: struct _GHmac *
 * Return Type: GHmac *
 */
mrb_value
mrb_GLib_g_hmac_ref(mrb_state* mrb, mrb_value self) {
  mrb_value hmac;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hmac);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hmac, GHmac_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHmac expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHmac * native_hmac = (mrb_nil_p(hmac) ? NULL : mruby_unbox__GHmac(hmac));

  /* Invocation */
  GHmac * native_return_value = g_hmac_ref(native_hmac);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHmac(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hmac_unref_FUNCTION
#define g_hmac_unref_REQUIRED_ARGC 1
#define g_hmac_unref_OPTIONAL_ARGC 0
/* g_hmac_unref
 *
 * Parameters:
 * - hmac: struct _GHmac *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hmac_unref(mrb_state* mrb, mrb_value self) {
  mrb_value hmac;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hmac);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hmac, GHmac_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHmac expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHmac * native_hmac = (mrb_nil_p(hmac) ? NULL : mruby_unbox__GHmac(hmac));

  /* Invocation */
  g_hmac_unref(native_hmac);

  return mrb_nil_value();
}
#endif

#if BIND_g_hmac_update_FUNCTION
#define g_hmac_update_REQUIRED_ARGC 3
#define g_hmac_update_OPTIONAL_ARGC 0
/* g_hmac_update
 *
 * Parameters:
 * - hmac: struct _GHmac *
 * - data: const unsigned char *
 * - length: long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hmac_update(mrb_state* mrb, mrb_value self) {
  mrb_value hmac;
  mrb_value data;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &hmac, &data, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hmac, GHmac_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHmac expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_char_PTR(data);

  /* Unbox parameters */
  struct _GHmac * native_hmac = (mrb_nil_p(hmac) ? NULL : mruby_unbox__GHmac(hmac));

  const unsigned char * native_data = TODO_mruby_unbox_unsigned_char_PTR(data);

  /* Invocation */
  g_hmac_update(native_hmac, native_data, native_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_alloc_FUNCTION
#define g_hook_alloc_REQUIRED_ARGC 1
#define g_hook_alloc_OPTIONAL_ARGC 0
/* g_hook_alloc
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * Return Type: GHook *
 */
mrb_value
mrb_GLib_g_hook_alloc(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hook_list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  /* Invocation */
  GHook * native_return_value = g_hook_alloc(native_hook_list);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHook(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hook_compare_ids_FUNCTION
#define g_hook_compare_ids_REQUIRED_ARGC 2
#define g_hook_compare_ids_OPTIONAL_ARGC 0
/* g_hook_compare_ids
 *
 * Parameters:
 * - new_hook: struct _GHook *
 * - sibling: struct _GHook *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_hook_compare_ids(mrb_state* mrb, mrb_value self) {
  mrb_value new_hook;
  mrb_value sibling;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &new_hook, &sibling);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, new_hook, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sibling, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHook * native_new_hook = (mrb_nil_p(new_hook) ? NULL : mruby_unbox__GHook(new_hook));

  struct _GHook * native_sibling = (mrb_nil_p(sibling) ? NULL : mruby_unbox__GHook(sibling));

  /* Invocation */
  gint native_return_value = g_hook_compare_ids(native_new_hook, native_sibling);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hook_destroy_FUNCTION
#define g_hook_destroy_REQUIRED_ARGC 2
#define g_hook_destroy_OPTIONAL_ARGC 0
/* g_hook_destroy
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - hook_id: unsigned long
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hook_destroy(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_hook_id;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &hook_list, &native_hook_id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  /* Invocation */
  gboolean native_return_value = g_hook_destroy(native_hook_list, native_hook_id);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hook_destroy_link_FUNCTION
#define g_hook_destroy_link_REQUIRED_ARGC 2
#define g_hook_destroy_link_OPTIONAL_ARGC 0
/* g_hook_destroy_link
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - hook: struct _GHook *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_destroy_link(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_value hook;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hook_list, &hook);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, hook, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  struct _GHook * native_hook = (mrb_nil_p(hook) ? NULL : mruby_unbox__GHook(hook));

  /* Invocation */
  g_hook_destroy_link(native_hook_list, native_hook);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_find_FUNCTION
#define g_hook_find_REQUIRED_ARGC 4
#define g_hook_find_OPTIONAL_ARGC 0
/* g_hook_find
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - need_valids: int
 * - func: int (*)(struct _GHook *, void *)
 * - data: void *
 * Return Type: GHook *
 */
mrb_value
mrb_GLib_g_hook_find(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_need_valids;
  mrb_value func;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &hook_list, &native_need_valids, &func, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GHook_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  int (*native_func)(struct _GHook *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GHook_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GHook * native_return_value = g_hook_find(native_hook_list, native_need_valids, native_func, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHook(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hook_find_data_FUNCTION
#define g_hook_find_data_REQUIRED_ARGC 3
#define g_hook_find_data_OPTIONAL_ARGC 0
/* g_hook_find_data
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - need_valids: int
 * - data: void *
 * Return Type: GHook *
 */
mrb_value
mrb_GLib_g_hook_find_data(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_need_valids;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &hook_list, &native_need_valids, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GHook * native_return_value = g_hook_find_data(native_hook_list, native_need_valids, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHook(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hook_find_func_FUNCTION
#define g_hook_find_func_REQUIRED_ARGC 3
#define g_hook_find_func_OPTIONAL_ARGC 0
/* g_hook_find_func
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - need_valids: int
 * - func: void *
 * Return Type: GHook *
 */
mrb_value
mrb_GLib_g_hook_find_func(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_need_valids;
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &hook_list, &native_need_valids, &func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(func);

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  void * native_func = TODO_mruby_unbox_void_PTR(func);

  /* Invocation */
  GHook * native_return_value = g_hook_find_func(native_hook_list, native_need_valids, native_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHook(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hook_find_func_data_FUNCTION
#define g_hook_find_func_data_REQUIRED_ARGC 4
#define g_hook_find_func_data_OPTIONAL_ARGC 0
/* g_hook_find_func_data
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - need_valids: int
 * - func: void *
 * - data: void *
 * Return Type: GHook *
 */
mrb_value
mrb_GLib_g_hook_find_func_data(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_need_valids;
  mrb_value func;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &hook_list, &native_need_valids, &func, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(func);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  void * native_func = TODO_mruby_unbox_void_PTR(func);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GHook * native_return_value = g_hook_find_func_data(native_hook_list, native_need_valids, native_func, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHook(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hook_first_valid_FUNCTION
#define g_hook_first_valid_REQUIRED_ARGC 2
#define g_hook_first_valid_OPTIONAL_ARGC 0
/* g_hook_first_valid
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - may_be_in_call: int
 * Return Type: GHook *
 */
mrb_value
mrb_GLib_g_hook_first_valid(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_may_be_in_call;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &hook_list, &native_may_be_in_call);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  /* Invocation */
  GHook * native_return_value = g_hook_first_valid(native_hook_list, native_may_be_in_call);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHook(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hook_free_FUNCTION
#define g_hook_free_REQUIRED_ARGC 2
#define g_hook_free_OPTIONAL_ARGC 0
/* g_hook_free
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - hook: struct _GHook *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_free(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_value hook;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hook_list, &hook);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, hook, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  struct _GHook * native_hook = (mrb_nil_p(hook) ? NULL : mruby_unbox__GHook(hook));

  /* Invocation */
  g_hook_free(native_hook_list, native_hook);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_get_FUNCTION
#define g_hook_get_REQUIRED_ARGC 2
#define g_hook_get_OPTIONAL_ARGC 0
/* g_hook_get
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - hook_id: unsigned long
 * Return Type: GHook *
 */
mrb_value
mrb_GLib_g_hook_get(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_hook_id;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &hook_list, &native_hook_id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  /* Invocation */
  GHook * native_return_value = g_hook_get(native_hook_list, native_hook_id);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHook(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hook_insert_before_FUNCTION
#define g_hook_insert_before_REQUIRED_ARGC 3
#define g_hook_insert_before_OPTIONAL_ARGC 0
/* g_hook_insert_before
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - sibling: struct _GHook *
 * - hook: struct _GHook *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_insert_before(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_value sibling;
  mrb_value hook;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &hook_list, &sibling, &hook);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sibling, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, hook, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  struct _GHook * native_sibling = (mrb_nil_p(sibling) ? NULL : mruby_unbox__GHook(sibling));

  struct _GHook * native_hook = (mrb_nil_p(hook) ? NULL : mruby_unbox__GHook(hook));

  /* Invocation */
  g_hook_insert_before(native_hook_list, native_sibling, native_hook);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_insert_sorted_FUNCTION
#define g_hook_insert_sorted_REQUIRED_ARGC 3
#define g_hook_insert_sorted_OPTIONAL_ARGC 0
/* g_hook_insert_sorted
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - hook: struct _GHook *
 * - func: int (*)(struct _GHook *, struct _GHook *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_insert_sorted(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_value hook;
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &hook_list, &hook, &func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, hook, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GHook_PTR_COMMA_struct__GHook_PTR_RPAREN(func);

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  struct _GHook * native_hook = (mrb_nil_p(hook) ? NULL : mruby_unbox__GHook(hook));

  int (*native_func)(struct _GHook *, struct _GHook *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GHook_PTR_COMMA_struct__GHook_PTR_RPAREN(func);

  /* Invocation */
  g_hook_insert_sorted(native_hook_list, native_hook, native_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_list_clear_FUNCTION
#define g_hook_list_clear_REQUIRED_ARGC 1
#define g_hook_list_clear_OPTIONAL_ARGC 0
/* g_hook_list_clear
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_list_clear(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &hook_list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  /* Invocation */
  g_hook_list_clear(native_hook_list);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_list_init_FUNCTION
#define g_hook_list_init_REQUIRED_ARGC 2
#define g_hook_list_init_OPTIONAL_ARGC 0
/* g_hook_list_init
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - hook_size: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_list_init(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_hook_size;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &hook_list, &native_hook_size);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  /* Invocation */
  g_hook_list_init(native_hook_list, native_hook_size);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_list_invoke_FUNCTION
#define g_hook_list_invoke_REQUIRED_ARGC 2
#define g_hook_list_invoke_OPTIONAL_ARGC 0
/* g_hook_list_invoke
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - may_recurse: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_list_invoke(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_may_recurse;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &hook_list, &native_may_recurse);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  /* Invocation */
  g_hook_list_invoke(native_hook_list, native_may_recurse);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_list_invoke_check_FUNCTION
#define g_hook_list_invoke_check_REQUIRED_ARGC 2
#define g_hook_list_invoke_check_OPTIONAL_ARGC 0
/* g_hook_list_invoke_check
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - may_recurse: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_list_invoke_check(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_may_recurse;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &hook_list, &native_may_recurse);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  /* Invocation */
  g_hook_list_invoke_check(native_hook_list, native_may_recurse);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_list_marshal_FUNCTION
#define g_hook_list_marshal_REQUIRED_ARGC 4
#define g_hook_list_marshal_OPTIONAL_ARGC 0
/* g_hook_list_marshal
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - may_recurse: int
 * - marshaller: void (*)(struct _GHook *, void *)
 * - marshal_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_list_marshal(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_may_recurse;
  mrb_value marshaller;
  mrb_value marshal_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &hook_list, &native_may_recurse, &marshaller, &marshal_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN__GHook_PTR_COMMA_void_PTR_RPAREN(marshaller);
  TODO_type_check_void_PTR(marshal_data);

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  void (*native_marshaller)(struct _GHook *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN__GHook_PTR_COMMA_void_PTR_RPAREN(marshaller);

  void * native_marshal_data = TODO_mruby_unbox_void_PTR(marshal_data);

  /* Invocation */
  g_hook_list_marshal(native_hook_list, native_may_recurse, native_marshaller, native_marshal_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_list_marshal_check_FUNCTION
#define g_hook_list_marshal_check_REQUIRED_ARGC 4
#define g_hook_list_marshal_check_OPTIONAL_ARGC 0
/* g_hook_list_marshal_check
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - may_recurse: int
 * - marshaller: int (*)(struct _GHook *, void *)
 * - marshal_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_list_marshal_check(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_int native_may_recurse;
  mrb_value marshaller;
  mrb_value marshal_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &hook_list, &native_may_recurse, &marshaller, &marshal_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GHook_PTR_COMMA_void_PTR_RPAREN(marshaller);
  TODO_type_check_void_PTR(marshal_data);

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  int (*native_marshaller)(struct _GHook *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GHook_PTR_COMMA_void_PTR_RPAREN(marshaller);

  void * native_marshal_data = TODO_mruby_unbox_void_PTR(marshal_data);

  /* Invocation */
  g_hook_list_marshal_check(native_hook_list, native_may_recurse, native_marshaller, native_marshal_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_next_valid_FUNCTION
#define g_hook_next_valid_REQUIRED_ARGC 3
#define g_hook_next_valid_OPTIONAL_ARGC 0
/* g_hook_next_valid
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - hook: struct _GHook *
 * - may_be_in_call: int
 * Return Type: GHook *
 */
mrb_value
mrb_GLib_g_hook_next_valid(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_value hook;
  mrb_int native_may_be_in_call;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &hook_list, &hook, &native_may_be_in_call);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, hook, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  struct _GHook * native_hook = (mrb_nil_p(hook) ? NULL : mruby_unbox__GHook(hook));

  /* Invocation */
  GHook * native_return_value = g_hook_next_valid(native_hook_list, native_hook, native_may_be_in_call);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHook(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hook_prepend_FUNCTION
#define g_hook_prepend_REQUIRED_ARGC 2
#define g_hook_prepend_OPTIONAL_ARGC 0
/* g_hook_prepend
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - hook: struct _GHook *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_prepend(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_value hook;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hook_list, &hook);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, hook, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  struct _GHook * native_hook = (mrb_nil_p(hook) ? NULL : mruby_unbox__GHook(hook));

  /* Invocation */
  g_hook_prepend(native_hook_list, native_hook);

  return mrb_nil_value();
}
#endif

#if BIND_g_hook_ref_FUNCTION
#define g_hook_ref_REQUIRED_ARGC 2
#define g_hook_ref_OPTIONAL_ARGC 0
/* g_hook_ref
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - hook: struct _GHook *
 * Return Type: GHook *
 */
mrb_value
mrb_GLib_g_hook_ref(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_value hook;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hook_list, &hook);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, hook, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  struct _GHook * native_hook = (mrb_nil_p(hook) ? NULL : mruby_unbox__GHook(hook));

  /* Invocation */
  GHook * native_return_value = g_hook_ref(native_hook_list, native_hook);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GHook(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_hook_unref_FUNCTION
#define g_hook_unref_REQUIRED_ARGC 2
#define g_hook_unref_OPTIONAL_ARGC 0
/* g_hook_unref
 *
 * Parameters:
 * - hook_list: struct _GHookList *
 * - hook: struct _GHook *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_hook_unref(mrb_state* mrb, mrb_value self) {
  mrb_value hook_list;
  mrb_value hook;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &hook_list, &hook);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, hook_list, GHookList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHookList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, hook, GHook_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GHook expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GHookList * native_hook_list = (mrb_nil_p(hook_list) ? NULL : mruby_unbox__GHookList(hook_list));

  struct _GHook * native_hook = (mrb_nil_p(hook) ? NULL : mruby_unbox__GHook(hook));

  /* Invocation */
  g_hook_unref(native_hook_list, native_hook);

  return mrb_nil_value();
}
#endif

#if BIND_g_hostname_is_ascii_encoded_FUNCTION
#define g_hostname_is_ascii_encoded_REQUIRED_ARGC 1
#define g_hostname_is_ascii_encoded_OPTIONAL_ARGC 0
/* g_hostname_is_ascii_encoded
 *
 * Parameters:
 * - hostname: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hostname_is_ascii_encoded(mrb_state* mrb, mrb_value self) {
  char * native_hostname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_hostname);

  /* Invocation */
  gboolean native_return_value = g_hostname_is_ascii_encoded(native_hostname);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hostname_is_ip_address_FUNCTION
#define g_hostname_is_ip_address_REQUIRED_ARGC 1
#define g_hostname_is_ip_address_OPTIONAL_ARGC 0
/* g_hostname_is_ip_address
 *
 * Parameters:
 * - hostname: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hostname_is_ip_address(mrb_state* mrb, mrb_value self) {
  char * native_hostname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_hostname);

  /* Invocation */
  gboolean native_return_value = g_hostname_is_ip_address(native_hostname);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hostname_is_non_ascii_FUNCTION
#define g_hostname_is_non_ascii_REQUIRED_ARGC 1
#define g_hostname_is_non_ascii_OPTIONAL_ARGC 0
/* g_hostname_is_non_ascii
 *
 * Parameters:
 * - hostname: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_hostname_is_non_ascii(mrb_state* mrb, mrb_value self) {
  char * native_hostname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_hostname);

  /* Invocation */
  gboolean native_return_value = g_hostname_is_non_ascii(native_hostname);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hostname_to_ascii_FUNCTION
#define g_hostname_to_ascii_REQUIRED_ARGC 1
#define g_hostname_to_ascii_OPTIONAL_ARGC 0
/* g_hostname_to_ascii
 *
 * Parameters:
 * - hostname: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_hostname_to_ascii(mrb_state* mrb, mrb_value self) {
  char * native_hostname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_hostname);

  /* Invocation */
  gchar * native_return_value = g_hostname_to_ascii(native_hostname);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_hostname_to_unicode_FUNCTION
#define g_hostname_to_unicode_REQUIRED_ARGC 1
#define g_hostname_to_unicode_OPTIONAL_ARGC 0
/* g_hostname_to_unicode
 *
 * Parameters:
 * - hostname: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_hostname_to_unicode(mrb_state* mrb, mrb_value self) {
  char * native_hostname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_hostname);

  /* Invocation */
  gchar * native_return_value = g_hostname_to_unicode(native_hostname);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_iconv_FUNCTION
#define g_iconv_REQUIRED_ARGC 5
#define g_iconv_OPTIONAL_ARGC 0
/* g_iconv
 *
 * Parameters:
 * - converter: struct _GIConv *
 * - inbuf: char **
 * - inbytes_left: unsigned long *
 * - outbuf: char **
 * - outbytes_left: unsigned long *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_iconv(mrb_state* mrb, mrb_value self) {
  mrb_value converter;
  mrb_value inbuf;
  mrb_value inbytes_left;
  mrb_value outbuf;
  mrb_value outbytes_left;

  /* Fetch the args */
  mrb_get_args(mrb, "ooooo", &converter, &inbuf, &inbytes_left, &outbuf, &outbytes_left);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, converter, GIConv_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIConv expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(inbuf);
  TODO_type_check_unsigned_long_PTR(inbytes_left);
  TODO_type_check_char_PTR_PTR(outbuf);
  TODO_type_check_unsigned_long_PTR(outbytes_left);

  /* Unbox parameters */
  struct _GIConv * native_converter = (mrb_nil_p(converter) ? NULL : mruby_unbox__GIConv(converter));

  char ** native_inbuf = TODO_mruby_unbox_char_PTR_PTR(inbuf);

  unsigned long * native_inbytes_left = TODO_mruby_unbox_unsigned_long_PTR(inbytes_left);

  char ** native_outbuf = TODO_mruby_unbox_char_PTR_PTR(outbuf);

  unsigned long * native_outbytes_left = TODO_mruby_unbox_unsigned_long_PTR(outbytes_left);

  /* Invocation */
  gsize native_return_value = g_iconv(native_converter, native_inbuf, native_inbytes_left, native_outbuf, native_outbytes_left);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_iconv_close_FUNCTION
#define g_iconv_close_REQUIRED_ARGC 1
#define g_iconv_close_OPTIONAL_ARGC 0
/* g_iconv_close
 *
 * Parameters:
 * - converter: struct _GIConv *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_iconv_close(mrb_state* mrb, mrb_value self) {
  mrb_value converter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &converter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, converter, GIConv_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIConv expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIConv * native_converter = (mrb_nil_p(converter) ? NULL : mruby_unbox__GIConv(converter));

  /* Invocation */
  gint native_return_value = g_iconv_close(native_converter);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_iconv_open_FUNCTION
#define g_iconv_open_REQUIRED_ARGC 2
#define g_iconv_open_OPTIONAL_ARGC 0
/* g_iconv_open
 *
 * Parameters:
 * - to_codeset: const char *
 * - from_codeset: const char *
 * Return Type: GIConv
 */
mrb_value
mrb_GLib_g_iconv_open(mrb_state* mrb, mrb_value self) {
  char * native_to_codeset = NULL;
  char * native_from_codeset = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_to_codeset, &native_from_codeset);

  /* Invocation */
  GIConv native_return_value = g_iconv_open(native_to_codeset, native_from_codeset);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GIConv(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_idle_add_FUNCTION
#define g_idle_add_REQUIRED_ARGC 2
#define g_idle_add_OPTIONAL_ARGC 0
/* g_idle_add
 *
 * Parameters:
 * - function: int (*)(void *)
 * - data: void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_idle_add(mrb_state* mrb, mrb_value self) {
  mrb_value function;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &function, &data);

  /* Type checking */
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  int (*native_function)(void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  guint native_return_value = g_idle_add(native_function, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_idle_add_full_FUNCTION
#define g_idle_add_full_REQUIRED_ARGC 4
#define g_idle_add_full_OPTIONAL_ARGC 0
/* g_idle_add_full
 *
 * Parameters:
 * - priority: int
 * - function: int (*)(void *)
 * - data: void *
 * - notify: void (*)(void *)
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_idle_add_full(mrb_state* mrb, mrb_value self) {
  mrb_int native_priority;
  mrb_value function;
  mrb_value data;
  mrb_value notify;

  /* Fetch the args */
  mrb_get_args(mrb, "iooo", &native_priority, &function, &data, &notify);

  /* Type checking */
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Unbox parameters */
  int (*native_function)(void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_notify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Invocation */
  guint native_return_value = g_idle_add_full(native_priority, native_function, native_data, native_notify);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_idle_remove_by_data_FUNCTION
#define g_idle_remove_by_data_REQUIRED_ARGC 1
#define g_idle_remove_by_data_OPTIONAL_ARGC 0
/* g_idle_remove_by_data
 *
 * Parameters:
 * - data: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_idle_remove_by_data(mrb_state* mrb, mrb_value self) {
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &data);

  /* Type checking */
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  gboolean native_return_value = g_idle_remove_by_data(native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_idle_source_new_FUNCTION
#define g_idle_source_new_REQUIRED_ARGC 0
#define g_idle_source_new_OPTIONAL_ARGC 0
/* g_idle_source_new
 *
 * Parameters: None
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_idle_source_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GSource * native_return_value = g_idle_source_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_int64_equal_FUNCTION
#define g_int64_equal_REQUIRED_ARGC 2
#define g_int64_equal_OPTIONAL_ARGC 0
/* g_int64_equal
 *
 * Parameters:
 * - v1: const void *
 * - v2: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_int64_equal(mrb_state* mrb, mrb_value self) {
  mrb_value v1;
  mrb_value v2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &v1, &v2);

  /* Type checking */
  TODO_type_check_void_PTR(v1);
  TODO_type_check_void_PTR(v2);

  /* Unbox parameters */
  const void * native_v1 = TODO_mruby_unbox_void_PTR(v1);

  const void * native_v2 = TODO_mruby_unbox_void_PTR(v2);

  /* Invocation */
  gboolean native_return_value = g_int64_equal(native_v1, native_v2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_int64_hash_FUNCTION
#define g_int64_hash_REQUIRED_ARGC 1
#define g_int64_hash_OPTIONAL_ARGC 0
/* g_int64_hash
 *
 * Parameters:
 * - v: const void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_int64_hash(mrb_state* mrb, mrb_value self) {
  mrb_value v;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &v);

  /* Type checking */
  TODO_type_check_void_PTR(v);

  /* Unbox parameters */
  const void * native_v = TODO_mruby_unbox_void_PTR(v);

  /* Invocation */
  guint native_return_value = g_int64_hash(native_v);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_int_equal_FUNCTION
#define g_int_equal_REQUIRED_ARGC 2
#define g_int_equal_OPTIONAL_ARGC 0
/* g_int_equal
 *
 * Parameters:
 * - v1: const void *
 * - v2: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_int_equal(mrb_state* mrb, mrb_value self) {
  mrb_value v1;
  mrb_value v2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &v1, &v2);

  /* Type checking */
  TODO_type_check_void_PTR(v1);
  TODO_type_check_void_PTR(v2);

  /* Unbox parameters */
  const void * native_v1 = TODO_mruby_unbox_void_PTR(v1);

  const void * native_v2 = TODO_mruby_unbox_void_PTR(v2);

  /* Invocation */
  gboolean native_return_value = g_int_equal(native_v1, native_v2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_int_hash_FUNCTION
#define g_int_hash_REQUIRED_ARGC 1
#define g_int_hash_OPTIONAL_ARGC 0
/* g_int_hash
 *
 * Parameters:
 * - v: const void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_int_hash(mrb_state* mrb, mrb_value self) {
  mrb_value v;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &v);

  /* Type checking */
  TODO_type_check_void_PTR(v);

  /* Unbox parameters */
  const void * native_v = TODO_mruby_unbox_void_PTR(v);

  /* Invocation */
  guint native_return_value = g_int_hash(native_v);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_intern_static_string_FUNCTION
#define g_intern_static_string_REQUIRED_ARGC 1
#define g_intern_static_string_OPTIONAL_ARGC 0
/* g_intern_static_string
 *
 * Parameters:
 * - string: const char *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_intern_static_string(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_string);

  /* Invocation */
  const gchar * native_return_value = g_intern_static_string(native_string);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_intern_string_FUNCTION
#define g_intern_string_REQUIRED_ARGC 1
#define g_intern_string_OPTIONAL_ARGC 0
/* g_intern_string
 *
 * Parameters:
 * - string: const char *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_intern_string(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_string);

  /* Invocation */
  const gchar * native_return_value = g_intern_string(native_string);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_add_watch_FUNCTION
#define g_io_add_watch_REQUIRED_ARGC 4
#define g_io_add_watch_OPTIONAL_ARGC 0
/* g_io_add_watch
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - condition: GIOCondition
 * - func: int (*)(struct _GIOChannel *, GIOCondition, void *)
 * - user_data: void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_io_add_watch(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  mrb_int native_condition;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &channel, &native_condition, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GIOChannel_PTR_COMMA_GIOConditionCOMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  int (*native_func)(struct _GIOChannel *, GIOCondition, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GIOChannel_PTR_COMMA_GIOConditionCOMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  guint native_return_value = g_io_add_watch(native_channel, native_condition, native_func, native_user_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_add_watch_full_FUNCTION
#define g_io_add_watch_full_REQUIRED_ARGC 6
#define g_io_add_watch_full_OPTIONAL_ARGC 0
/* g_io_add_watch_full
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - priority: int
 * - condition: GIOCondition
 * - func: int (*)(struct _GIOChannel *, GIOCondition, void *)
 * - user_data: void *
 * - notify: void (*)(void *)
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_io_add_watch_full(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  mrb_int native_priority;
  mrb_int native_condition;
  mrb_value func;
  mrb_value user_data;
  mrb_value notify;

  /* Fetch the args */
  mrb_get_args(mrb, "oiiooo", &channel, &native_priority, &native_condition, &func, &user_data, &notify);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GIOChannel_PTR_COMMA_GIOConditionCOMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  int (*native_func)(struct _GIOChannel *, GIOCondition, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GIOChannel_PTR_COMMA_GIOConditionCOMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  void (*native_notify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Invocation */
  guint native_return_value = g_io_add_watch_full(native_channel, native_priority, native_condition, native_func, native_user_data, native_notify);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_close_FUNCTION
#define g_io_channel_close_REQUIRED_ARGC 1
#define g_io_channel_close_OPTIONAL_ARGC 0
/* g_io_channel_close
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_io_channel_close(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  g_io_channel_close(native_channel);

  return mrb_nil_value();
}
#endif

#if BIND_g_io_channel_error_from_errno_FUNCTION
#define g_io_channel_error_from_errno_REQUIRED_ARGC 1
#define g_io_channel_error_from_errno_OPTIONAL_ARGC 0
/* g_io_channel_error_from_errno
 *
 * Parameters:
 * - en: int
 * Return Type: GIOChannelError
 */
mrb_value
mrb_GLib_g_io_channel_error_from_errno(mrb_state* mrb, mrb_value self) {
  mrb_int native_en;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_en);

  /* Invocation */
  GIOChannelError native_return_value = g_io_channel_error_from_errno(native_en);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_error_quark_FUNCTION
#define g_io_channel_error_quark_REQUIRED_ARGC 0
#define g_io_channel_error_quark_OPTIONAL_ARGC 0
/* g_io_channel_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_io_channel_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_io_channel_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_flush_FUNCTION
#define g_io_channel_flush_REQUIRED_ARGC 1
#define g_io_channel_flush_OPTIONAL_ARGC 0
/* g_io_channel_flush
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_flush(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_flush(native_channel, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_channel_get_buffer_condition_FUNCTION
#define g_io_channel_get_buffer_condition_REQUIRED_ARGC 1
#define g_io_channel_get_buffer_condition_OPTIONAL_ARGC 0
/* g_io_channel_get_buffer_condition
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: GIOCondition
 */
mrb_value
mrb_GLib_g_io_channel_get_buffer_condition(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GIOCondition native_return_value = g_io_channel_get_buffer_condition(native_channel);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_get_buffer_size_FUNCTION
#define g_io_channel_get_buffer_size_REQUIRED_ARGC 1
#define g_io_channel_get_buffer_size_OPTIONAL_ARGC 0
/* g_io_channel_get_buffer_size
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_io_channel_get_buffer_size(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  gsize native_return_value = g_io_channel_get_buffer_size(native_channel);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_get_buffered_FUNCTION
#define g_io_channel_get_buffered_REQUIRED_ARGC 1
#define g_io_channel_get_buffered_OPTIONAL_ARGC 0
/* g_io_channel_get_buffered
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_io_channel_get_buffered(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  gboolean native_return_value = g_io_channel_get_buffered(native_channel);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_get_close_on_unref_FUNCTION
#define g_io_channel_get_close_on_unref_REQUIRED_ARGC 1
#define g_io_channel_get_close_on_unref_OPTIONAL_ARGC 0
/* g_io_channel_get_close_on_unref
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_io_channel_get_close_on_unref(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  gboolean native_return_value = g_io_channel_get_close_on_unref(native_channel);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_get_encoding_FUNCTION
#define g_io_channel_get_encoding_REQUIRED_ARGC 1
#define g_io_channel_get_encoding_OPTIONAL_ARGC 0
/* g_io_channel_get_encoding
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_io_channel_get_encoding(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  const gchar * native_return_value = g_io_channel_get_encoding(native_channel);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_get_flags_FUNCTION
#define g_io_channel_get_flags_REQUIRED_ARGC 1
#define g_io_channel_get_flags_OPTIONAL_ARGC 0
/* g_io_channel_get_flags
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: GIOFlags
 */
mrb_value
mrb_GLib_g_io_channel_get_flags(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GIOFlags native_return_value = g_io_channel_get_flags(native_channel);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_get_line_term_FUNCTION
#define g_io_channel_get_line_term_REQUIRED_ARGC 2
#define g_io_channel_get_line_term_OPTIONAL_ARGC 0
/* g_io_channel_get_line_term
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - length: int *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_io_channel_get_line_term(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &channel, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_PTR(length);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  int * native_length = TODO_mruby_unbox_int_PTR(length);

  /* Invocation */
  const gchar * native_return_value = g_io_channel_get_line_term(native_channel, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_init_FUNCTION
#define g_io_channel_init_REQUIRED_ARGC 1
#define g_io_channel_init_OPTIONAL_ARGC 0
/* g_io_channel_init
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_io_channel_init(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  g_io_channel_init(native_channel);

  return mrb_nil_value();
}
#endif

#if BIND_g_io_channel_new_file_FUNCTION
#define g_io_channel_new_file_REQUIRED_ARGC 2
#define g_io_channel_new_file_OPTIONAL_ARGC 0
/* g_io_channel_new_file
 *
 * Parameters:
 * - filename: const char *
 * - mode: const char *
 * Return Type: GIOChannel *
 */
mrb_value
mrb_GLib_g_io_channel_new_file(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_filename = NULL;
  char * native_mode = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_filename, &native_mode);

  /* Invocation */
  GIOChannel * native_return_value = g_io_channel_new_file(native_filename, native_mode, &native_error);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GIOChannel(mrb, native_return_value));
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_channel_read_FUNCTION
#define g_io_channel_read_REQUIRED_ARGC 4
#define g_io_channel_read_OPTIONAL_ARGC 0
/* g_io_channel_read
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - buf: char *
 * - count: unsigned long
 * - bytes_read: unsigned long *
 * Return Type: GIOError
 */
mrb_value
mrb_GLib_g_io_channel_read(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  char * buf = NULL;
  mrb_int native_count;
  mrb_value bytes_read;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!io", &channel, &buf, &native_count, &bytes_read);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(bytes_read);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_buf = strdup(buf);

  unsigned long * native_bytes_read = TODO_mruby_unbox_unsigned_long_PTR(bytes_read);

  /* Invocation */
  GIOError native_return_value = g_io_channel_read(native_channel, native_buf, native_count, native_bytes_read);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_buf);
  native_buf = NULL;

  return return_value;
}
#endif

#if BIND_g_io_channel_read_chars_FUNCTION
#define g_io_channel_read_chars_REQUIRED_ARGC 4
#define g_io_channel_read_chars_OPTIONAL_ARGC 0
/* g_io_channel_read_chars
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - buf: char *
 * - count: unsigned long
 * - bytes_read: unsigned long *
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_read_chars(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  char * buf = NULL;
  mrb_int native_count;
  mrb_value bytes_read;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!io", &channel, &buf, &native_count, &bytes_read);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(bytes_read);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_buf = strdup(buf);

  unsigned long * native_bytes_read = TODO_mruby_unbox_unsigned_long_PTR(bytes_read);

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_read_chars(native_channel, native_buf, native_count, native_bytes_read, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_buf);
  native_buf = NULL;

  return results;
}
#endif

#if BIND_g_io_channel_read_line_FUNCTION
#define g_io_channel_read_line_REQUIRED_ARGC 4
#define g_io_channel_read_line_OPTIONAL_ARGC 0
/* g_io_channel_read_line
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - str_return: char **
 * - length: unsigned long *
 * - terminator_pos: unsigned long *
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_read_line(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  mrb_value str_return;
  mrb_value length;
  mrb_value terminator_pos;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &channel, &str_return, &length, &terminator_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(str_return);
  TODO_type_check_unsigned_long_PTR(length);
  TODO_type_check_unsigned_long_PTR(terminator_pos);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  char ** native_str_return = TODO_mruby_unbox_char_PTR_PTR(str_return);

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  unsigned long * native_terminator_pos = TODO_mruby_unbox_unsigned_long_PTR(terminator_pos);

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_read_line(native_channel, native_str_return, native_length, native_terminator_pos, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_channel_read_line_string_FUNCTION
#define g_io_channel_read_line_string_REQUIRED_ARGC 3
#define g_io_channel_read_line_string_OPTIONAL_ARGC 0
/* g_io_channel_read_line_string
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - buffer: struct _GString *
 * - terminator_pos: unsigned long *
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_read_line_string(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  mrb_value buffer;
  mrb_value terminator_pos;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &channel, &buffer, &terminator_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, buffer, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(terminator_pos);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  struct _GString * native_buffer = (mrb_nil_p(buffer) ? NULL : mruby_unbox__GString(buffer));

  unsigned long * native_terminator_pos = TODO_mruby_unbox_unsigned_long_PTR(terminator_pos);

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_read_line_string(native_channel, native_buffer, native_terminator_pos, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_channel_read_to_end_FUNCTION
#define g_io_channel_read_to_end_REQUIRED_ARGC 3
#define g_io_channel_read_to_end_OPTIONAL_ARGC 0
/* g_io_channel_read_to_end
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - str_return: char **
 * - length: unsigned long *
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_read_to_end(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  mrb_value str_return;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &channel, &str_return, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(str_return);
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  char ** native_str_return = TODO_mruby_unbox_char_PTR_PTR(str_return);

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_read_to_end(native_channel, native_str_return, native_length, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_channel_read_unichar_FUNCTION
#define g_io_channel_read_unichar_REQUIRED_ARGC 2
#define g_io_channel_read_unichar_OPTIONAL_ARGC 0
/* g_io_channel_read_unichar
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - thechar: unsigned int *
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_read_unichar(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  mrb_value thechar;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &channel, &thechar);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_int_PTR(thechar);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  unsigned int * native_thechar = TODO_mruby_unbox_unsigned_int_PTR(thechar);

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_read_unichar(native_channel, native_thechar, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_channel_ref_FUNCTION
#define g_io_channel_ref_REQUIRED_ARGC 1
#define g_io_channel_ref_OPTIONAL_ARGC 0
/* g_io_channel_ref
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: GIOChannel *
 */
mrb_value
mrb_GLib_g_io_channel_ref(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GIOChannel * native_return_value = g_io_channel_ref(native_channel);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GIOChannel(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_io_channel_seek_FUNCTION
#define g_io_channel_seek_REQUIRED_ARGC 3
#define g_io_channel_seek_OPTIONAL_ARGC 0
/* g_io_channel_seek
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - offset: long
 * - type: GSeekType
 * Return Type: GIOError
 */
mrb_value
mrb_GLib_g_io_channel_seek(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  mrb_int native_offset;
  mrb_int native_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &channel, &native_offset, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GIOError native_return_value = g_io_channel_seek(native_channel, native_offset, native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_seek_position_FUNCTION
#define g_io_channel_seek_position_REQUIRED_ARGC 3
#define g_io_channel_seek_position_OPTIONAL_ARGC 0
/* g_io_channel_seek_position
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - offset: long
 * - type: GSeekType
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_seek_position(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  mrb_int native_offset;
  mrb_int native_type;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &channel, &native_offset, &native_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_seek_position(native_channel, native_offset, native_type, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_channel_set_buffer_size_FUNCTION
#define g_io_channel_set_buffer_size_REQUIRED_ARGC 2
#define g_io_channel_set_buffer_size_OPTIONAL_ARGC 0
/* g_io_channel_set_buffer_size
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - size: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_io_channel_set_buffer_size(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  mrb_int native_size;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &channel, &native_size);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  g_io_channel_set_buffer_size(native_channel, native_size);

  return mrb_nil_value();
}
#endif

#if BIND_g_io_channel_set_buffered_FUNCTION
#define g_io_channel_set_buffered_REQUIRED_ARGC 2
#define g_io_channel_set_buffered_OPTIONAL_ARGC 0
/* g_io_channel_set_buffered
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - buffered: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_io_channel_set_buffered(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  mrb_int native_buffered;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &channel, &native_buffered);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  g_io_channel_set_buffered(native_channel, native_buffered);

  return mrb_nil_value();
}
#endif

#if BIND_g_io_channel_set_close_on_unref_FUNCTION
#define g_io_channel_set_close_on_unref_REQUIRED_ARGC 2
#define g_io_channel_set_close_on_unref_OPTIONAL_ARGC 0
/* g_io_channel_set_close_on_unref
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - do_close: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_io_channel_set_close_on_unref(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  mrb_int native_do_close;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &channel, &native_do_close);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  g_io_channel_set_close_on_unref(native_channel, native_do_close);

  return mrb_nil_value();
}
#endif

#if BIND_g_io_channel_set_encoding_FUNCTION
#define g_io_channel_set_encoding_REQUIRED_ARGC 2
#define g_io_channel_set_encoding_OPTIONAL_ARGC 0
/* g_io_channel_set_encoding
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - encoding: const char *
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_set_encoding(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  char * native_encoding = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &channel, &native_encoding);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_set_encoding(native_channel, native_encoding, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_channel_set_flags_FUNCTION
#define g_io_channel_set_flags_REQUIRED_ARGC 2
#define g_io_channel_set_flags_OPTIONAL_ARGC 0
/* g_io_channel_set_flags
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - flags: GIOFlags
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_set_flags(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  mrb_int native_flags;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &channel, &native_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_set_flags(native_channel, native_flags, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_channel_set_line_term_FUNCTION
#define g_io_channel_set_line_term_REQUIRED_ARGC 3
#define g_io_channel_set_line_term_OPTIONAL_ARGC 0
/* g_io_channel_set_line_term
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - line_term: const char *
 * - length: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_io_channel_set_line_term(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  char * native_line_term = NULL;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &channel, &native_line_term, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  g_io_channel_set_line_term(native_channel, native_line_term, native_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_io_channel_shutdown_FUNCTION
#define g_io_channel_shutdown_REQUIRED_ARGC 2
#define g_io_channel_shutdown_OPTIONAL_ARGC 0
/* g_io_channel_shutdown
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - flush: int
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_shutdown(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  mrb_int native_flush;
  struct GError * native_err = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &channel, &native_flush);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_shutdown(native_channel, native_flush, &native_err);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value err = (native_err == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_err));
  mrb_ary_push(mrb, results, err);

  return results;
}
#endif

#if BIND_g_io_channel_unix_get_fd_FUNCTION
#define g_io_channel_unix_get_fd_REQUIRED_ARGC 1
#define g_io_channel_unix_get_fd_OPTIONAL_ARGC 0
/* g_io_channel_unix_get_fd
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_io_channel_unix_get_fd(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  gint native_return_value = g_io_channel_unix_get_fd(native_channel);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_unix_new_FUNCTION
#define g_io_channel_unix_new_REQUIRED_ARGC 1
#define g_io_channel_unix_new_OPTIONAL_ARGC 0
/* g_io_channel_unix_new
 *
 * Parameters:
 * - fd: int
 * Return Type: GIOChannel *
 */
mrb_value
mrb_GLib_g_io_channel_unix_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_fd;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_fd);

  /* Invocation */
  GIOChannel * native_return_value = g_io_channel_unix_new(native_fd);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GIOChannel(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_io_channel_unref_FUNCTION
#define g_io_channel_unref_REQUIRED_ARGC 1
#define g_io_channel_unref_OPTIONAL_ARGC 0
/* g_io_channel_unref
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_io_channel_unref(mrb_state* mrb, mrb_value self) {
  mrb_value channel;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &channel);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  g_io_channel_unref(native_channel);

  return mrb_nil_value();
}
#endif

#if BIND_g_io_channel_write_FUNCTION
#define g_io_channel_write_REQUIRED_ARGC 4
#define g_io_channel_write_OPTIONAL_ARGC 0
/* g_io_channel_write
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - buf: const char *
 * - count: unsigned long
 * - bytes_written: unsigned long *
 * Return Type: GIOError
 */
mrb_value
mrb_GLib_g_io_channel_write(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  char * native_buf = NULL;
  mrb_int native_count;
  mrb_value bytes_written;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!io", &channel, &native_buf, &native_count, &bytes_written);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(bytes_written);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  unsigned long * native_bytes_written = TODO_mruby_unbox_unsigned_long_PTR(bytes_written);

  /* Invocation */
  GIOError native_return_value = g_io_channel_write(native_channel, native_buf, native_count, native_bytes_written);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_io_channel_write_chars_FUNCTION
#define g_io_channel_write_chars_REQUIRED_ARGC 4
#define g_io_channel_write_chars_OPTIONAL_ARGC 0
/* g_io_channel_write_chars
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - buf: const char *
 * - count: long
 * - bytes_written: unsigned long *
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_write_chars(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  char * native_buf = NULL;
  mrb_int native_count;
  mrb_value bytes_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!io", &channel, &native_buf, &native_count, &bytes_written);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(bytes_written);

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  unsigned long * native_bytes_written = TODO_mruby_unbox_unsigned_long_PTR(bytes_written);

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_write_chars(native_channel, native_buf, native_count, native_bytes_written, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_channel_write_unichar_FUNCTION
#define g_io_channel_write_unichar_REQUIRED_ARGC 2
#define g_io_channel_write_unichar_OPTIONAL_ARGC 0
/* g_io_channel_write_unichar
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - thechar: unsigned int
 * Return Type: GIOStatus
 */
mrb_value
mrb_GLib_g_io_channel_write_unichar(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value channel;
  mrb_int native_thechar;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &channel, &native_thechar);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GIOStatus native_return_value = g_io_channel_write_unichar(native_channel, native_thechar, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_io_create_watch_FUNCTION
#define g_io_create_watch_REQUIRED_ARGC 2
#define g_io_create_watch_OPTIONAL_ARGC 0
/* g_io_create_watch
 *
 * Parameters:
 * - channel: struct _GIOChannel *
 * - condition: GIOCondition
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_io_create_watch(mrb_state* mrb, mrb_value self) {
  mrb_value channel;
  mrb_int native_condition;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &channel, &native_condition);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, channel, GIOChannel_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GIOChannel expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GIOChannel * native_channel = (mrb_nil_p(channel) ? NULL : mruby_unbox__GIOChannel(channel));

  /* Invocation */
  GSource * native_return_value = g_io_create_watch(native_channel, native_condition);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_key_file_error_quark_FUNCTION
#define g_key_file_error_quark_REQUIRED_ARGC 0
#define g_key_file_error_quark_OPTIONAL_ARGC 0
/* g_key_file_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_key_file_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_key_file_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_key_file_free_FUNCTION
#define g_key_file_free_REQUIRED_ARGC 1
#define g_key_file_free_OPTIONAL_ARGC 0
/* g_key_file_free
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_free(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &key_file);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_free(native_key_file);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_get_boolean_FUNCTION
#define g_key_file_get_boolean_REQUIRED_ARGC 3
#define g_key_file_get_boolean_OPTIONAL_ARGC 0
/* g_key_file_get_boolean
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_get_boolean(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gboolean native_return_value = g_key_file_get_boolean(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_boolean_list_FUNCTION
#define g_key_file_get_boolean_list_REQUIRED_ARGC 4
#define g_key_file_get_boolean_list_OPTIONAL_ARGC 0
/* g_key_file_get_boolean_list
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - length: unsigned long *
 * Return Type: gboolean *
 */
mrb_value
mrb_GLib_g_key_file_get_boolean_list(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!o", &key_file, &native_group_name, &native_key, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gboolean * native_return_value = g_key_file_get_boolean_list(native_key_file, native_group_name, native_key, native_length, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gboolean_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_comment_FUNCTION
#define g_key_file_get_comment_REQUIRED_ARGC 3
#define g_key_file_get_comment_OPTIONAL_ARGC 0
/* g_key_file_get_comment
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_key_file_get_comment(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gchar * native_return_value = g_key_file_get_comment(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_double_FUNCTION
#define g_key_file_get_double_REQUIRED_ARGC 3
#define g_key_file_get_double_OPTIONAL_ARGC 0
/* g_key_file_get_double
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: gdouble
 */
mrb_value
mrb_GLib_g_key_file_get_double(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gdouble native_return_value = g_key_file_get_double(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_double_list_FUNCTION
#define g_key_file_get_double_list_REQUIRED_ARGC 4
#define g_key_file_get_double_list_OPTIONAL_ARGC 0
/* g_key_file_get_double_list
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - length: unsigned long *
 * Return Type: gdouble *
 */
mrb_value
mrb_GLib_g_key_file_get_double_list(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!o", &key_file, &native_group_name, &native_key, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gdouble * native_return_value = g_key_file_get_double_list(native_key_file, native_group_name, native_key, native_length, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gdouble_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_groups_FUNCTION
#define g_key_file_get_groups_REQUIRED_ARGC 2
#define g_key_file_get_groups_OPTIONAL_ARGC 0
/* g_key_file_get_groups
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - length: unsigned long *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_key_file_get_groups(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &key_file, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar ** native_return_value = g_key_file_get_groups(native_key_file, native_length);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_key_file_get_int64_FUNCTION
#define g_key_file_get_int64_REQUIRED_ARGC 3
#define g_key_file_get_int64_OPTIONAL_ARGC 0
/* g_key_file_get_int64
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: gint64
 */
mrb_value
mrb_GLib_g_key_file_get_int64(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gint64 native_return_value = g_key_file_get_int64(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint64(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_integer_FUNCTION
#define g_key_file_get_integer_REQUIRED_ARGC 3
#define g_key_file_get_integer_OPTIONAL_ARGC 0
/* g_key_file_get_integer
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_key_file_get_integer(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gint native_return_value = g_key_file_get_integer(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_integer_list_FUNCTION
#define g_key_file_get_integer_list_REQUIRED_ARGC 4
#define g_key_file_get_integer_list_OPTIONAL_ARGC 0
/* g_key_file_get_integer_list
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - length: unsigned long *
 * Return Type: gint *
 */
mrb_value
mrb_GLib_g_key_file_get_integer_list(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!o", &key_file, &native_group_name, &native_key, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gint * native_return_value = g_key_file_get_integer_list(native_key_file, native_group_name, native_key, native_length, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_keys_FUNCTION
#define g_key_file_get_keys_REQUIRED_ARGC 3
#define g_key_file_get_keys_OPTIONAL_ARGC 0
/* g_key_file_get_keys
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - length: unsigned long *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_key_file_get_keys(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!o", &key_file, &native_group_name, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar ** native_return_value = g_key_file_get_keys(native_key_file, native_group_name, native_length, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_locale_string_FUNCTION
#define g_key_file_get_locale_string_REQUIRED_ARGC 4
#define g_key_file_get_locale_string_OPTIONAL_ARGC 0
/* g_key_file_get_locale_string
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - locale: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_key_file_get_locale_string(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  char * native_locale = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!z!", &key_file, &native_group_name, &native_key, &native_locale);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gchar * native_return_value = g_key_file_get_locale_string(native_key_file, native_group_name, native_key, native_locale, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_locale_string_list_FUNCTION
#define g_key_file_get_locale_string_list_REQUIRED_ARGC 5
#define g_key_file_get_locale_string_list_OPTIONAL_ARGC 0
/* g_key_file_get_locale_string_list
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - locale: const char *
 * - length: unsigned long *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_key_file_get_locale_string_list(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  char * native_locale = NULL;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!z!o", &key_file, &native_group_name, &native_key, &native_locale, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar ** native_return_value = g_key_file_get_locale_string_list(native_key_file, native_group_name, native_key, native_locale, native_length, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_start_group_FUNCTION
#define g_key_file_get_start_group_REQUIRED_ARGC 1
#define g_key_file_get_start_group_OPTIONAL_ARGC 0
/* g_key_file_get_start_group
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_key_file_get_start_group(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &key_file);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gchar * native_return_value = g_key_file_get_start_group(native_key_file);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_key_file_get_string_FUNCTION
#define g_key_file_get_string_REQUIRED_ARGC 3
#define g_key_file_get_string_OPTIONAL_ARGC 0
/* g_key_file_get_string
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_key_file_get_string(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gchar * native_return_value = g_key_file_get_string(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_string_list_FUNCTION
#define g_key_file_get_string_list_REQUIRED_ARGC 4
#define g_key_file_get_string_list_OPTIONAL_ARGC 0
/* g_key_file_get_string_list
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - length: unsigned long *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_key_file_get_string_list(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!o", &key_file, &native_group_name, &native_key, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar ** native_return_value = g_key_file_get_string_list(native_key_file, native_group_name, native_key, native_length, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_uint64_FUNCTION
#define g_key_file_get_uint64_REQUIRED_ARGC 3
#define g_key_file_get_uint64_OPTIONAL_ARGC 0
/* g_key_file_get_uint64
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: guint64
 */
mrb_value
mrb_GLib_g_key_file_get_uint64(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  guint64 native_return_value = g_key_file_get_uint64(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint64(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_get_value_FUNCTION
#define g_key_file_get_value_REQUIRED_ARGC 3
#define g_key_file_get_value_OPTIONAL_ARGC 0
/* g_key_file_get_value
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_key_file_get_value(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gchar * native_return_value = g_key_file_get_value(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_has_group_FUNCTION
#define g_key_file_has_group_REQUIRED_ARGC 2
#define g_key_file_has_group_OPTIONAL_ARGC 0
/* g_key_file_has_group
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_has_group(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &key_file, &native_group_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gboolean native_return_value = g_key_file_has_group(native_key_file, native_group_name);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_key_file_has_key_FUNCTION
#define g_key_file_has_key_REQUIRED_ARGC 3
#define g_key_file_has_key_OPTIONAL_ARGC 0
/* g_key_file_has_key
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_has_key(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gboolean native_return_value = g_key_file_has_key(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_load_from_data_FUNCTION
#define g_key_file_load_from_data_REQUIRED_ARGC 4
#define g_key_file_load_from_data_OPTIONAL_ARGC 0
/* g_key_file_load_from_data
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - data: const char *
 * - length: unsigned long
 * - flags: GKeyFileFlags
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_load_from_data(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_data = NULL;
  mrb_int native_length;
  mrb_int native_flags;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!ii", &key_file, &native_data, &native_length, &native_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gboolean native_return_value = g_key_file_load_from_data(native_key_file, native_data, native_length, native_flags, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_load_from_data_dirs_FUNCTION
#define g_key_file_load_from_data_dirs_REQUIRED_ARGC 4
#define g_key_file_load_from_data_dirs_OPTIONAL_ARGC 0
/* g_key_file_load_from_data_dirs
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - file: const char *
 * - full_path: char **
 * - flags: GKeyFileFlags
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_load_from_data_dirs(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_file = NULL;
  mrb_value full_path;
  mrb_int native_flags;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!oi", &key_file, &native_file, &full_path, &native_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(full_path);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  char ** native_full_path = TODO_mruby_unbox_char_PTR_PTR(full_path);

  /* Invocation */
  gboolean native_return_value = g_key_file_load_from_data_dirs(native_key_file, native_file, native_full_path, native_flags, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_load_from_dirs_FUNCTION
#define g_key_file_load_from_dirs_REQUIRED_ARGC 5
#define g_key_file_load_from_dirs_OPTIONAL_ARGC 0
/* g_key_file_load_from_dirs
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - file: const char *
 * - search_dirs: const char **
 * - full_path: char **
 * - flags: GKeyFileFlags
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_load_from_dirs(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_file = NULL;
  mrb_value search_dirs;
  mrb_value full_path;
  mrb_int native_flags;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!ooi", &key_file, &native_file, &search_dirs, &full_path, &native_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(search_dirs);
  TODO_type_check_char_PTR_PTR(full_path);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  const char ** native_search_dirs = TODO_mruby_unbox_char_PTR_PTR(search_dirs);

  char ** native_full_path = TODO_mruby_unbox_char_PTR_PTR(full_path);

  /* Invocation */
  gboolean native_return_value = g_key_file_load_from_dirs(native_key_file, native_file, native_search_dirs, native_full_path, native_flags, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_load_from_file_FUNCTION
#define g_key_file_load_from_file_REQUIRED_ARGC 3
#define g_key_file_load_from_file_OPTIONAL_ARGC 0
/* g_key_file_load_from_file
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - file: const char *
 * - flags: GKeyFileFlags
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_load_from_file(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_file = NULL;
  mrb_int native_flags;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &key_file, &native_file, &native_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gboolean native_return_value = g_key_file_load_from_file(native_key_file, native_file, native_flags, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_new_FUNCTION
#define g_key_file_new_REQUIRED_ARGC 0
#define g_key_file_new_OPTIONAL_ARGC 0
/* g_key_file_new
 *
 * Parameters: None
 * Return Type: GKeyFile *
 */
mrb_value
mrb_GLib_g_key_file_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GKeyFile * native_return_value = g_key_file_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GKeyFile(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_key_file_ref_FUNCTION
#define g_key_file_ref_REQUIRED_ARGC 1
#define g_key_file_ref_OPTIONAL_ARGC 0
/* g_key_file_ref
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * Return Type: GKeyFile *
 */
mrb_value
mrb_GLib_g_key_file_ref(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &key_file);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  GKeyFile * native_return_value = g_key_file_ref(native_key_file);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GKeyFile(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_key_file_remove_comment_FUNCTION
#define g_key_file_remove_comment_REQUIRED_ARGC 3
#define g_key_file_remove_comment_OPTIONAL_ARGC 0
/* g_key_file_remove_comment
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_remove_comment(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gboolean native_return_value = g_key_file_remove_comment(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_remove_group_FUNCTION
#define g_key_file_remove_group_REQUIRED_ARGC 2
#define g_key_file_remove_group_OPTIONAL_ARGC 0
/* g_key_file_remove_group
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_remove_group(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &key_file, &native_group_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gboolean native_return_value = g_key_file_remove_group(native_key_file, native_group_name, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_remove_key_FUNCTION
#define g_key_file_remove_key_REQUIRED_ARGC 3
#define g_key_file_remove_key_OPTIONAL_ARGC 0
/* g_key_file_remove_key
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_remove_key(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &key_file, &native_group_name, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gboolean native_return_value = g_key_file_remove_key(native_key_file, native_group_name, native_key, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_save_to_file_FUNCTION
#define g_key_file_save_to_file_REQUIRED_ARGC 2
#define g_key_file_save_to_file_OPTIONAL_ARGC 0
/* g_key_file_save_to_file
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - filename: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_save_to_file(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_filename = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &key_file, &native_filename);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gboolean native_return_value = g_key_file_save_to_file(native_key_file, native_filename, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_set_boolean_FUNCTION
#define g_key_file_set_boolean_REQUIRED_ARGC 4
#define g_key_file_set_boolean_OPTIONAL_ARGC 0
/* g_key_file_set_boolean
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - value: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_boolean(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!i", &key_file, &native_group_name, &native_key, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_set_boolean(native_key_file, native_group_name, native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_boolean_list_FUNCTION
#define g_key_file_set_boolean_list_REQUIRED_ARGC 5
#define g_key_file_set_boolean_list_OPTIONAL_ARGC 0
/* g_key_file_set_boolean_list
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - list: int []
 * - length: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_boolean_list(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_value list;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!oi", &key_file, &native_group_name, &native_key, &list, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_[](list);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  int [] native_list = TODO_mruby_unbox_int_[](list);

  /* Invocation */
  g_key_file_set_boolean_list(native_key_file, native_group_name, native_key, native_list, native_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_comment_FUNCTION
#define g_key_file_set_comment_REQUIRED_ARGC 4
#define g_key_file_set_comment_OPTIONAL_ARGC 0
/* g_key_file_set_comment
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - comment: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_key_file_set_comment(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  char * native_comment = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!z!", &key_file, &native_group_name, &native_key, &native_comment);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  gboolean native_return_value = g_key_file_set_comment(native_key_file, native_group_name, native_key, native_comment, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_set_double_FUNCTION
#define g_key_file_set_double_REQUIRED_ARGC 4
#define g_key_file_set_double_OPTIONAL_ARGC 0
/* g_key_file_set_double
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - value: double
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_double(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  double native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!f", &key_file, &native_group_name, &native_key, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_set_double(native_key_file, native_group_name, native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_double_list_FUNCTION
#define g_key_file_set_double_list_REQUIRED_ARGC 5
#define g_key_file_set_double_list_OPTIONAL_ARGC 0
/* g_key_file_set_double_list
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - list: double []
 * - length: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_double_list(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_value list;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!oi", &key_file, &native_group_name, &native_key, &list, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_double_[](list);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  double [] native_list = TODO_mruby_unbox_double_[](list);

  /* Invocation */
  g_key_file_set_double_list(native_key_file, native_group_name, native_key, native_list, native_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_int64_FUNCTION
#define g_key_file_set_int64_REQUIRED_ARGC 4
#define g_key_file_set_int64_OPTIONAL_ARGC 0
/* g_key_file_set_int64
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - value: long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_int64(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!i", &key_file, &native_group_name, &native_key, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_set_int64(native_key_file, native_group_name, native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_integer_FUNCTION
#define g_key_file_set_integer_REQUIRED_ARGC 4
#define g_key_file_set_integer_OPTIONAL_ARGC 0
/* g_key_file_set_integer
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - value: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_integer(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!i", &key_file, &native_group_name, &native_key, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_set_integer(native_key_file, native_group_name, native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_integer_list_FUNCTION
#define g_key_file_set_integer_list_REQUIRED_ARGC 5
#define g_key_file_set_integer_list_OPTIONAL_ARGC 0
/* g_key_file_set_integer_list
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - list: int []
 * - length: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_integer_list(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_value list;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!oi", &key_file, &native_group_name, &native_key, &list, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_[](list);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  int [] native_list = TODO_mruby_unbox_int_[](list);

  /* Invocation */
  g_key_file_set_integer_list(native_key_file, native_group_name, native_key, native_list, native_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_list_separator_FUNCTION
#define g_key_file_set_list_separator_REQUIRED_ARGC 2
#define g_key_file_set_list_separator_OPTIONAL_ARGC 0
/* g_key_file_set_list_separator
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - separator: char
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_list_separator(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  mrb_int native_separator;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &key_file, &native_separator);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_set_list_separator(native_key_file, native_separator);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_locale_string_FUNCTION
#define g_key_file_set_locale_string_REQUIRED_ARGC 5
#define g_key_file_set_locale_string_OPTIONAL_ARGC 0
/* g_key_file_set_locale_string
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - locale: const char *
 * - string: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_locale_string(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  char * native_locale = NULL;
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!z!z!", &key_file, &native_group_name, &native_key, &native_locale, &native_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_set_locale_string(native_key_file, native_group_name, native_key, native_locale, native_string);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_locale_string_list_FUNCTION
#define g_key_file_set_locale_string_list_REQUIRED_ARGC 6
#define g_key_file_set_locale_string_list_OPTIONAL_ARGC 0
/* g_key_file_set_locale_string_list
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - locale: const char *
 * - list: const char *const[]
 * - length: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_locale_string_list(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  char * native_locale = NULL;
  mrb_value list;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!z!oi", &key_file, &native_group_name, &native_key, &native_locale, &list, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_const[](list);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  const char *const[] native_list = TODO_mruby_unbox_char_PTR_const[](list);

  /* Invocation */
  g_key_file_set_locale_string_list(native_key_file, native_group_name, native_key, native_locale, native_list, native_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_string_FUNCTION
#define g_key_file_set_string_REQUIRED_ARGC 4
#define g_key_file_set_string_OPTIONAL_ARGC 0
/* g_key_file_set_string
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - string: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_string(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!z!", &key_file, &native_group_name, &native_key, &native_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_set_string(native_key_file, native_group_name, native_key, native_string);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_string_list_FUNCTION
#define g_key_file_set_string_list_REQUIRED_ARGC 5
#define g_key_file_set_string_list_OPTIONAL_ARGC 0
/* g_key_file_set_string_list
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - list: const char *const[]
 * - length: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_string_list(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_value list;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!oi", &key_file, &native_group_name, &native_key, &list, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_const[](list);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  const char *const[] native_list = TODO_mruby_unbox_char_PTR_const[](list);

  /* Invocation */
  g_key_file_set_string_list(native_key_file, native_group_name, native_key, native_list, native_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_uint64_FUNCTION
#define g_key_file_set_uint64_REQUIRED_ARGC 4
#define g_key_file_set_uint64_OPTIONAL_ARGC 0
/* g_key_file_set_uint64
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - value: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_uint64(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!i", &key_file, &native_group_name, &native_key, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_set_uint64(native_key_file, native_group_name, native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_set_value_FUNCTION
#define g_key_file_set_value_REQUIRED_ARGC 4
#define g_key_file_set_value_OPTIONAL_ARGC 0
/* g_key_file_set_value
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - group_name: const char *
 * - key: const char *
 * - value: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_set_value(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;
  char * native_group_name = NULL;
  char * native_key = NULL;
  char * native_value = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!z!", &key_file, &native_group_name, &native_key, &native_value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_set_value(native_key_file, native_group_name, native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_key_file_to_data_FUNCTION
#define g_key_file_to_data_REQUIRED_ARGC 2
#define g_key_file_to_data_OPTIONAL_ARGC 0
/* g_key_file_to_data
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * - length: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_key_file_to_data(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value key_file;
  mrb_value length;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &key_file, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar * native_return_value = g_key_file_to_data(native_key_file, native_length, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_key_file_unref_FUNCTION
#define g_key_file_unref_REQUIRED_ARGC 1
#define g_key_file_unref_OPTIONAL_ARGC 0
/* g_key_file_unref
 *
 * Parameters:
 * - key_file: struct _GKeyFile *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_key_file_unref(mrb_state* mrb, mrb_value self) {
  mrb_value key_file;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &key_file);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key_file, GKeyFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GKeyFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GKeyFile * native_key_file = (mrb_nil_p(key_file) ? NULL : mruby_unbox__GKeyFile(key_file));

  /* Invocation */
  g_key_file_unref(native_key_file);

  return mrb_nil_value();
}
#endif

#if BIND_g_list_alloc_FUNCTION
#define g_list_alloc_REQUIRED_ARGC 0
#define g_list_alloc_OPTIONAL_ARGC 0
/* g_list_alloc
 *
 * Parameters: None
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_alloc(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GList * native_return_value = g_list_alloc();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_append_FUNCTION
#define g_list_append_REQUIRED_ARGC 2
#define g_list_append_OPTIONAL_ARGC 0
/* g_list_append
 *
 * Parameters:
 * - list: struct _GList *
 * - data: void *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_append(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GList * native_return_value = g_list_append(native_list, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_concat_FUNCTION
#define g_list_concat_REQUIRED_ARGC 2
#define g_list_concat_OPTIONAL_ARGC 0
/* g_list_concat
 *
 * Parameters:
 * - list1: struct _GList *
 * - list2: struct _GList *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_concat(mrb_state* mrb, mrb_value self) {
  mrb_value list1;
  mrb_value list2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list1, &list2);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list1, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, list2, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list1 = (mrb_nil_p(list1) ? NULL : mruby_unbox__GList(list1));

  struct _GList * native_list2 = (mrb_nil_p(list2) ? NULL : mruby_unbox__GList(list2));

  /* Invocation */
  GList * native_return_value = g_list_concat(native_list1, native_list2);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_copy_FUNCTION
#define g_list_copy_REQUIRED_ARGC 1
#define g_list_copy_OPTIONAL_ARGC 0
/* g_list_copy
 *
 * Parameters:
 * - list: struct _GList *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_copy(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  /* Invocation */
  GList * native_return_value = g_list_copy(native_list);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_copy_deep_FUNCTION
#define g_list_copy_deep_REQUIRED_ARGC 3
#define g_list_copy_deep_OPTIONAL_ARGC 0
/* g_list_copy_deep
 *
 * Parameters:
 * - list: struct _GList *
 * - func: void *(*)(const void *, void *)
 * - user_data: void *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_copy_deep(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  void *(*native_func)(const void *, void *) = TODO_mruby_unbox_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GList * native_return_value = g_list_copy_deep(native_list, native_func, native_user_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_delete_link_FUNCTION
#define g_list_delete_link_REQUIRED_ARGC 2
#define g_list_delete_link_OPTIONAL_ARGC 0
/* g_list_delete_link
 *
 * Parameters:
 * - list: struct _GList *
 * - link_: struct _GList *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_delete_link(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value link_;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &link_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, link_, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  struct _GList * native_link_ = (mrb_nil_p(link_) ? NULL : mruby_unbox__GList(link_));

  /* Invocation */
  GList * native_return_value = g_list_delete_link(native_list, native_link_);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_find_FUNCTION
#define g_list_find_REQUIRED_ARGC 2
#define g_list_find_OPTIONAL_ARGC 0
/* g_list_find
 *
 * Parameters:
 * - list: struct _GList *
 * - data: const void *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_find(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GList * native_return_value = g_list_find(native_list, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_find_custom_FUNCTION
#define g_list_find_custom_REQUIRED_ARGC 3
#define g_list_find_custom_OPTIONAL_ARGC 0
/* g_list_find_custom
 *
 * Parameters:
 * - list: struct _GList *
 * - data: const void *
 * - func: int (*)(const void *, const void *)
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_find_custom(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &data, &func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(func);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(func);

  /* Invocation */
  GList * native_return_value = g_list_find_custom(native_list, native_data, native_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_first_FUNCTION
#define g_list_first_REQUIRED_ARGC 1
#define g_list_first_OPTIONAL_ARGC 0
/* g_list_first
 *
 * Parameters:
 * - list: struct _GList *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_first(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  /* Invocation */
  GList * native_return_value = g_list_first(native_list);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_foreach_FUNCTION
#define g_list_foreach_REQUIRED_ARGC 3
#define g_list_foreach_OPTIONAL_ARGC 0
/* g_list_foreach
 *
 * Parameters:
 * - list: struct _GList *
 * - func: void (*)(void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_list_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  void (*native_func)(void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_list_foreach(native_list, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_list_free_FUNCTION
#define g_list_free_REQUIRED_ARGC 1
#define g_list_free_OPTIONAL_ARGC 0
/* g_list_free
 *
 * Parameters:
 * - list: struct _GList *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_list_free(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  /* Invocation */
  g_list_free(native_list);

  return mrb_nil_value();
}
#endif

#if BIND_g_list_free_1_FUNCTION
#define g_list_free_1_REQUIRED_ARGC 1
#define g_list_free_1_OPTIONAL_ARGC 0
/* g_list_free_1
 *
 * Parameters:
 * - list: struct _GList *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_list_free_1(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  /* Invocation */
  g_list_free_1(native_list);

  return mrb_nil_value();
}
#endif

#if BIND_g_list_free_full_FUNCTION
#define g_list_free_full_REQUIRED_ARGC 2
#define g_list_free_full_OPTIONAL_ARGC 0
/* g_list_free_full
 *
 * Parameters:
 * - list: struct _GList *
 * - free_func: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_list_free_full(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value free_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &free_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(free_func);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  void (*native_free_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(free_func);

  /* Invocation */
  g_list_free_full(native_list, native_free_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_list_index_FUNCTION
#define g_list_index_REQUIRED_ARGC 2
#define g_list_index_OPTIONAL_ARGC 0
/* g_list_index
 *
 * Parameters:
 * - list: struct _GList *
 * - data: const void *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_list_index(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  gint native_return_value = g_list_index(native_list, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_list_insert_FUNCTION
#define g_list_insert_REQUIRED_ARGC 3
#define g_list_insert_OPTIONAL_ARGC 0
/* g_list_insert
 *
 * Parameters:
 * - list: struct _GList *
 * - data: void *
 * - position: int
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_insert(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;
  mrb_int native_position;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &list, &data, &native_position);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GList * native_return_value = g_list_insert(native_list, native_data, native_position);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_insert_before_FUNCTION
#define g_list_insert_before_REQUIRED_ARGC 3
#define g_list_insert_before_OPTIONAL_ARGC 0
/* g_list_insert_before
 *
 * Parameters:
 * - list: struct _GList *
 * - sibling: struct _GList *
 * - data: void *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_insert_before(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value sibling;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &sibling, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sibling, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  struct _GList * native_sibling = (mrb_nil_p(sibling) ? NULL : mruby_unbox__GList(sibling));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GList * native_return_value = g_list_insert_before(native_list, native_sibling, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_insert_sorted_FUNCTION
#define g_list_insert_sorted_REQUIRED_ARGC 3
#define g_list_insert_sorted_OPTIONAL_ARGC 0
/* g_list_insert_sorted
 *
 * Parameters:
 * - list: struct _GList *
 * - data: void *
 * - func: int (*)(const void *, const void *)
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_insert_sorted(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &data, &func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(func);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(func);

  /* Invocation */
  GList * native_return_value = g_list_insert_sorted(native_list, native_data, native_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_insert_sorted_with_data_FUNCTION
#define g_list_insert_sorted_with_data_REQUIRED_ARGC 4
#define g_list_insert_sorted_with_data_OPTIONAL_ARGC 0
/* g_list_insert_sorted_with_data
 *
 * Parameters:
 * - list: struct _GList *
 * - data: void *
 * - func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_insert_sorted_with_data(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &list, &data, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GList * native_return_value = g_list_insert_sorted_with_data(native_list, native_data, native_func, native_user_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_last_FUNCTION
#define g_list_last_REQUIRED_ARGC 1
#define g_list_last_OPTIONAL_ARGC 0
/* g_list_last
 *
 * Parameters:
 * - list: struct _GList *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_last(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  /* Invocation */
  GList * native_return_value = g_list_last(native_list);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_length_FUNCTION
#define g_list_length_REQUIRED_ARGC 1
#define g_list_length_OPTIONAL_ARGC 0
/* g_list_length
 *
 * Parameters:
 * - list: struct _GList *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_list_length(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  /* Invocation */
  guint native_return_value = g_list_length(native_list);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_list_nth_FUNCTION
#define g_list_nth_REQUIRED_ARGC 2
#define g_list_nth_OPTIONAL_ARGC 0
/* g_list_nth
 *
 * Parameters:
 * - list: struct _GList *
 * - n: unsigned int
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_nth(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &list, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  /* Invocation */
  GList * native_return_value = g_list_nth(native_list, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_nth_data_FUNCTION
#define g_list_nth_data_REQUIRED_ARGC 2
#define g_list_nth_data_OPTIONAL_ARGC 0
/* g_list_nth_data
 *
 * Parameters:
 * - list: struct _GList *
 * - n: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_list_nth_data(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &list, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  /* Invocation */
  gpointer native_return_value = g_list_nth_data(native_list, native_n);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_list_nth_prev_FUNCTION
#define g_list_nth_prev_REQUIRED_ARGC 2
#define g_list_nth_prev_OPTIONAL_ARGC 0
/* g_list_nth_prev
 *
 * Parameters:
 * - list: struct _GList *
 * - n: unsigned int
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_nth_prev(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &list, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  /* Invocation */
  GList * native_return_value = g_list_nth_prev(native_list, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_position_FUNCTION
#define g_list_position_REQUIRED_ARGC 2
#define g_list_position_OPTIONAL_ARGC 0
/* g_list_position
 *
 * Parameters:
 * - list: struct _GList *
 * - llink: struct _GList *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_list_position(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value llink;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &llink);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, llink, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  struct _GList * native_llink = (mrb_nil_p(llink) ? NULL : mruby_unbox__GList(llink));

  /* Invocation */
  gint native_return_value = g_list_position(native_list, native_llink);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_list_prepend_FUNCTION
#define g_list_prepend_REQUIRED_ARGC 2
#define g_list_prepend_OPTIONAL_ARGC 0
/* g_list_prepend
 *
 * Parameters:
 * - list: struct _GList *
 * - data: void *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_prepend(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GList * native_return_value = g_list_prepend(native_list, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_remove_FUNCTION
#define g_list_remove_REQUIRED_ARGC 2
#define g_list_remove_OPTIONAL_ARGC 0
/* g_list_remove
 *
 * Parameters:
 * - list: struct _GList *
 * - data: const void *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_remove(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GList * native_return_value = g_list_remove(native_list, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_remove_all_FUNCTION
#define g_list_remove_all_REQUIRED_ARGC 2
#define g_list_remove_all_OPTIONAL_ARGC 0
/* g_list_remove_all
 *
 * Parameters:
 * - list: struct _GList *
 * - data: const void *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_remove_all(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GList * native_return_value = g_list_remove_all(native_list, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_remove_link_FUNCTION
#define g_list_remove_link_REQUIRED_ARGC 2
#define g_list_remove_link_OPTIONAL_ARGC 0
/* g_list_remove_link
 *
 * Parameters:
 * - list: struct _GList *
 * - llink: struct _GList *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_remove_link(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value llink;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &llink);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, llink, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  struct _GList * native_llink = (mrb_nil_p(llink) ? NULL : mruby_unbox__GList(llink));

  /* Invocation */
  GList * native_return_value = g_list_remove_link(native_list, native_llink);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_reverse_FUNCTION
#define g_list_reverse_REQUIRED_ARGC 1
#define g_list_reverse_OPTIONAL_ARGC 0
/* g_list_reverse
 *
 * Parameters:
 * - list: struct _GList *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_reverse(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  /* Invocation */
  GList * native_return_value = g_list_reverse(native_list);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_sort_FUNCTION
#define g_list_sort_REQUIRED_ARGC 2
#define g_list_sort_OPTIONAL_ARGC 0
/* g_list_sort
 *
 * Parameters:
 * - list: struct _GList *
 * - compare_func: int (*)(const void *, const void *)
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_sort(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value compare_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &compare_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(compare_func);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  int (*native_compare_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(compare_func);

  /* Invocation */
  GList * native_return_value = g_list_sort(native_list, native_compare_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_list_sort_with_data_FUNCTION
#define g_list_sort_with_data_REQUIRED_ARGC 3
#define g_list_sort_with_data_OPTIONAL_ARGC 0
/* g_list_sort_with_data
 *
 * Parameters:
 * - list: struct _GList *
 * - compare_func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_list_sort_with_data(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value compare_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &compare_func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GList(list));

  int (*native_compare_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GList * native_return_value = g_list_sort_with_data(native_list, native_compare_func, native_user_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_listenv_FUNCTION
#define g_listenv_REQUIRED_ARGC 0
#define g_listenv_OPTIONAL_ARGC 0
/* g_listenv
 *
 * Parameters: None
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_listenv(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gchar ** native_return_value = g_listenv();

  /* Box the return value */
  mrb_value return_value = mrb_ary_new(mrb);
  do {
    int i = 0;
    while (native_return_value[i] != NULL) {
      mrb_ary_push(mrb, return_value, mrb_str_new_cstr(mrb, native_return_value[i]));
      ++i;
    }
  } while (0);
  do {
    int i = 0;
    while (native_return_value[i] != NULL) {
      free(native_return_value[i]);
      ++i;
    }
    free(native_return_value);
  } while (0);
  
  return return_value;
}
#endif

#if BIND_g_locale_from_utf8_FUNCTION
#define g_locale_from_utf8_REQUIRED_ARGC 4
#define g_locale_from_utf8_OPTIONAL_ARGC 0
/* g_locale_from_utf8
 *
 * Parameters:
 * - utf8string: const char *
 * - len: long
 * - bytes_read: unsigned long *
 * - bytes_written: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_locale_from_utf8(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_utf8string = NULL;
  mrb_int native_len;
  mrb_value bytes_read;
  mrb_value bytes_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ioo", &native_utf8string, &native_len, &bytes_read, &bytes_written);

  /* Type checking */
  TODO_type_check_unsigned_long_PTR(bytes_read);
  TODO_type_check_unsigned_long_PTR(bytes_written);

  /* Unbox parameters */
  unsigned long * native_bytes_read = TODO_mruby_unbox_unsigned_long_PTR(bytes_read);

  unsigned long * native_bytes_written = TODO_mruby_unbox_unsigned_long_PTR(bytes_written);

  /* Invocation */
  gchar * native_return_value = g_locale_from_utf8(native_utf8string, native_len, native_bytes_read, native_bytes_written, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_locale_to_utf8_FUNCTION
#define g_locale_to_utf8_REQUIRED_ARGC 4
#define g_locale_to_utf8_OPTIONAL_ARGC 0
/* g_locale_to_utf8
 *
 * Parameters:
 * - opsysstring: const char *
 * - len: long
 * - bytes_read: unsigned long *
 * - bytes_written: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_locale_to_utf8(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_opsysstring = NULL;
  mrb_int native_len;
  mrb_value bytes_read;
  mrb_value bytes_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ioo", &native_opsysstring, &native_len, &bytes_read, &bytes_written);

  /* Type checking */
  TODO_type_check_unsigned_long_PTR(bytes_read);
  TODO_type_check_unsigned_long_PTR(bytes_written);

  /* Unbox parameters */
  unsigned long * native_bytes_read = TODO_mruby_unbox_unsigned_long_PTR(bytes_read);

  unsigned long * native_bytes_written = TODO_mruby_unbox_unsigned_long_PTR(bytes_written);

  /* Invocation */
  gchar * native_return_value = g_locale_to_utf8(native_opsysstring, native_len, native_bytes_read, native_bytes_written, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_log_FUNCTION
#define g_log_REQUIRED_ARGC 3
#define g_log_OPTIONAL_ARGC 0
/* g_log
 *
 * Parameters:
 * - log_domain: const char *
 * - log_level: GLogLevelFlags
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_log(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  mrb_int native_log_level;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!", &native_log_domain, &native_log_level, &native_format);

  /* Invocation */
  g_log(native_log_domain, native_log_level, native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_log_default_handler_FUNCTION
#define g_log_default_handler_REQUIRED_ARGC 4
#define g_log_default_handler_OPTIONAL_ARGC 0
/* g_log_default_handler
 *
 * Parameters:
 * - log_domain: const char *
 * - log_level: GLogLevelFlags
 * - message: const char *
 * - unused_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_log_default_handler(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  mrb_int native_log_level;
  char * native_message = NULL;
  mrb_value unused_data;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!o", &native_log_domain, &native_log_level, &native_message, &unused_data);

  /* Type checking */
  TODO_type_check_void_PTR(unused_data);

  /* Unbox parameters */
  void * native_unused_data = TODO_mruby_unbox_void_PTR(unused_data);

  /* Invocation */
  g_log_default_handler(native_log_domain, native_log_level, native_message, native_unused_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_log_remove_handler_FUNCTION
#define g_log_remove_handler_REQUIRED_ARGC 2
#define g_log_remove_handler_OPTIONAL_ARGC 0
/* g_log_remove_handler
 *
 * Parameters:
 * - log_domain: const char *
 * - handler_id: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_log_remove_handler(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  mrb_int native_handler_id;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_log_domain, &native_handler_id);

  /* Invocation */
  g_log_remove_handler(native_log_domain, native_handler_id);

  return mrb_nil_value();
}
#endif

#if BIND_g_log_set_always_fatal_FUNCTION
#define g_log_set_always_fatal_REQUIRED_ARGC 1
#define g_log_set_always_fatal_OPTIONAL_ARGC 0
/* g_log_set_always_fatal
 *
 * Parameters:
 * - fatal_mask: GLogLevelFlags
 * Return Type: GLogLevelFlags
 */
mrb_value
mrb_GLib_g_log_set_always_fatal(mrb_state* mrb, mrb_value self) {
  mrb_int native_fatal_mask;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_fatal_mask);

  /* Invocation */
  GLogLevelFlags native_return_value = g_log_set_always_fatal(native_fatal_mask);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_log_set_default_handler_FUNCTION
#define g_log_set_default_handler_REQUIRED_ARGC 2
#define g_log_set_default_handler_OPTIONAL_ARGC 0
/* g_log_set_default_handler
 *
 * Parameters:
 * - log_func: void (*)(const char *, GLogLevelFlags, const char *, void *)
 * - user_data: void *
 * Return Type: GLogFunc
 */
mrb_value
mrb_GLib_g_log_set_default_handler(mrb_state* mrb, mrb_value self) {
  mrb_value log_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &log_func, &user_data);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_GLogLevelFlagsCOMMA_const_char_PTR_COMMA_void_PTR_RPAREN(log_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  void (*native_log_func)(const char *, GLogLevelFlags, const char *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_GLogLevelFlagsCOMMA_const_char_PTR_COMMA_void_PTR_RPAREN(log_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GLogFunc native_return_value = g_log_set_default_handler(native_log_func, native_user_data);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GLogFunc(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_log_set_fatal_mask_FUNCTION
#define g_log_set_fatal_mask_REQUIRED_ARGC 2
#define g_log_set_fatal_mask_OPTIONAL_ARGC 0
/* g_log_set_fatal_mask
 *
 * Parameters:
 * - log_domain: const char *
 * - fatal_mask: GLogLevelFlags
 * Return Type: GLogLevelFlags
 */
mrb_value
mrb_GLib_g_log_set_fatal_mask(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  mrb_int native_fatal_mask;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_log_domain, &native_fatal_mask);

  /* Invocation */
  GLogLevelFlags native_return_value = g_log_set_fatal_mask(native_log_domain, native_fatal_mask);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_log_set_handler_FUNCTION
#define g_log_set_handler_REQUIRED_ARGC 4
#define g_log_set_handler_OPTIONAL_ARGC 0
/* g_log_set_handler
 *
 * Parameters:
 * - log_domain: const char *
 * - log_levels: GLogLevelFlags
 * - log_func: void (*)(const char *, GLogLevelFlags, const char *, void *)
 * - user_data: void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_log_set_handler(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  mrb_int native_log_levels;
  mrb_value log_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ioo", &native_log_domain, &native_log_levels, &log_func, &user_data);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_GLogLevelFlagsCOMMA_const_char_PTR_COMMA_void_PTR_RPAREN(log_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  void (*native_log_func)(const char *, GLogLevelFlags, const char *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_GLogLevelFlagsCOMMA_const_char_PTR_COMMA_void_PTR_RPAREN(log_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  guint native_return_value = g_log_set_handler(native_log_domain, native_log_levels, native_log_func, native_user_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_log_set_handler_full_FUNCTION
#define g_log_set_handler_full_REQUIRED_ARGC 5
#define g_log_set_handler_full_OPTIONAL_ARGC 0
/* g_log_set_handler_full
 *
 * Parameters:
 * - log_domain: const char *
 * - log_levels: GLogLevelFlags
 * - log_func: void (*)(const char *, GLogLevelFlags, const char *, void *)
 * - user_data: void *
 * - destroy: void (*)(void *)
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_log_set_handler_full(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  mrb_int native_log_levels;
  mrb_value log_func;
  mrb_value user_data;
  mrb_value destroy;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iooo", &native_log_domain, &native_log_levels, &log_func, &user_data, &destroy);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_GLogLevelFlagsCOMMA_const_char_PTR_COMMA_void_PTR_RPAREN(log_func);
  TODO_type_check_void_PTR(user_data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy);

  /* Unbox parameters */
  void (*native_log_func)(const char *, GLogLevelFlags, const char *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_GLogLevelFlagsCOMMA_const_char_PTR_COMMA_void_PTR_RPAREN(log_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  void (*native_destroy)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy);

  /* Invocation */
  guint native_return_value = g_log_set_handler_full(native_log_domain, native_log_levels, native_log_func, native_user_data, native_destroy);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_logv_FUNCTION
#define g_logv_REQUIRED_ARGC 4
#define g_logv_OPTIONAL_ARGC 0
/* g_logv
 *
 * Parameters:
 * - log_domain: const char *
 * - log_level: GLogLevelFlags
 * - format: const char *
 * - args: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_logv(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  mrb_int native_log_level;
  char * native_format = NULL;
  mrb_int native_args;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!i", &native_log_domain, &native_log_level, &native_format, &native_args);

  /* Invocation */
  g_logv(native_log_domain, native_log_level, native_format, native_args);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_acquire_FUNCTION
#define g_main_context_acquire_REQUIRED_ARGC 1
#define g_main_context_acquire_OPTIONAL_ARGC 0
/* g_main_context_acquire
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_main_context_acquire(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  gboolean native_return_value = g_main_context_acquire(native_context);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_context_add_poll_FUNCTION
#define g_main_context_add_poll_REQUIRED_ARGC 3
#define g_main_context_add_poll_OPTIONAL_ARGC 0
/* g_main_context_add_poll
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - fd: struct _GPollFD *
 * - priority: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_add_poll(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value fd;
  mrb_int native_priority;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &context, &fd, &native_priority);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, fd, GPollFD_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPollFD expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  struct _GPollFD * native_fd = (mrb_nil_p(fd) ? NULL : mruby_unbox__GPollFD(fd));

  /* Invocation */
  g_main_context_add_poll(native_context, native_fd, native_priority);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_check_FUNCTION
#define g_main_context_check_REQUIRED_ARGC 4
#define g_main_context_check_OPTIONAL_ARGC 0
/* g_main_context_check
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - max_priority: int
 * - fds: struct _GPollFD *
 * - n_fds: int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_main_context_check(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_int native_max_priority;
  mrb_value fds;
  mrb_int native_n_fds;

  /* Fetch the args */
  mrb_get_args(mrb, "oioi", &context, &native_max_priority, &fds, &native_n_fds);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, fds, GPollFD_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPollFD expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  struct _GPollFD * native_fds = (mrb_nil_p(fds) ? NULL : mruby_unbox__GPollFD(fds));

  /* Invocation */
  gint native_return_value = g_main_context_check(native_context, native_max_priority, native_fds, native_n_fds);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_context_default_FUNCTION
#define g_main_context_default_REQUIRED_ARGC 0
#define g_main_context_default_OPTIONAL_ARGC 0
/* g_main_context_default
 *
 * Parameters: None
 * Return Type: GMainContext *
 */
mrb_value
mrb_GLib_g_main_context_default(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GMainContext * native_return_value = g_main_context_default();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMainContext(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_context_dispatch_FUNCTION
#define g_main_context_dispatch_REQUIRED_ARGC 1
#define g_main_context_dispatch_OPTIONAL_ARGC 0
/* g_main_context_dispatch
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_dispatch(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  g_main_context_dispatch(native_context);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_find_source_by_funcs_user_data_FUNCTION
#define g_main_context_find_source_by_funcs_user_data_REQUIRED_ARGC 3
#define g_main_context_find_source_by_funcs_user_data_OPTIONAL_ARGC 0
/* g_main_context_find_source_by_funcs_user_data
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - funcs: struct _GSourceFuncs *
 * - user_data: void *
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_main_context_find_source_by_funcs_user_data(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value funcs;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &context, &funcs, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, funcs, GSourceFuncs_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSourceFuncs expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  struct _GSourceFuncs * native_funcs = (mrb_nil_p(funcs) ? NULL : mruby_unbox__GSourceFuncs(funcs));

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GSource * native_return_value = g_main_context_find_source_by_funcs_user_data(native_context, native_funcs, native_user_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_context_find_source_by_id_FUNCTION
#define g_main_context_find_source_by_id_REQUIRED_ARGC 2
#define g_main_context_find_source_by_id_OPTIONAL_ARGC 0
/* g_main_context_find_source_by_id
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - source_id: unsigned int
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_main_context_find_source_by_id(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_int native_source_id;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &context, &native_source_id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  GSource * native_return_value = g_main_context_find_source_by_id(native_context, native_source_id);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_context_find_source_by_user_data_FUNCTION
#define g_main_context_find_source_by_user_data_REQUIRED_ARGC 2
#define g_main_context_find_source_by_user_data_OPTIONAL_ARGC 0
/* g_main_context_find_source_by_user_data
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - user_data: void *
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_main_context_find_source_by_user_data(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &context, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GSource * native_return_value = g_main_context_find_source_by_user_data(native_context, native_user_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_context_get_poll_func_FUNCTION
#define g_main_context_get_poll_func_REQUIRED_ARGC 1
#define g_main_context_get_poll_func_OPTIONAL_ARGC 0
/* g_main_context_get_poll_func
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: GPollFunc
 */
mrb_value
mrb_GLib_g_main_context_get_poll_func(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  GPollFunc native_return_value = g_main_context_get_poll_func(native_context);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GPollFunc(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_context_get_thread_default_FUNCTION
#define g_main_context_get_thread_default_REQUIRED_ARGC 0
#define g_main_context_get_thread_default_OPTIONAL_ARGC 0
/* g_main_context_get_thread_default
 *
 * Parameters: None
 * Return Type: GMainContext *
 */
mrb_value
mrb_GLib_g_main_context_get_thread_default(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GMainContext * native_return_value = g_main_context_get_thread_default();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMainContext(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_context_invoke_FUNCTION
#define g_main_context_invoke_REQUIRED_ARGC 3
#define g_main_context_invoke_OPTIONAL_ARGC 0
/* g_main_context_invoke
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - function: int (*)(void *)
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_invoke(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value function;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &context, &function, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  int (*native_function)(void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_main_context_invoke(native_context, native_function, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_invoke_full_FUNCTION
#define g_main_context_invoke_full_REQUIRED_ARGC 5
#define g_main_context_invoke_full_OPTIONAL_ARGC 0
/* g_main_context_invoke_full
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - priority: int
 * - function: int (*)(void *)
 * - data: void *
 * - notify: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_invoke_full(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_int native_priority;
  mrb_value function;
  mrb_value data;
  mrb_value notify;

  /* Fetch the args */
  mrb_get_args(mrb, "oiooo", &context, &native_priority, &function, &data, &notify);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  int (*native_function)(void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_notify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Invocation */
  g_main_context_invoke_full(native_context, native_priority, native_function, native_data, native_notify);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_is_owner_FUNCTION
#define g_main_context_is_owner_REQUIRED_ARGC 1
#define g_main_context_is_owner_OPTIONAL_ARGC 0
/* g_main_context_is_owner
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_main_context_is_owner(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  gboolean native_return_value = g_main_context_is_owner(native_context);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_context_iteration_FUNCTION
#define g_main_context_iteration_REQUIRED_ARGC 2
#define g_main_context_iteration_OPTIONAL_ARGC 0
/* g_main_context_iteration
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - may_block: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_main_context_iteration(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_int native_may_block;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &context, &native_may_block);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  gboolean native_return_value = g_main_context_iteration(native_context, native_may_block);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_context_new_FUNCTION
#define g_main_context_new_REQUIRED_ARGC 0
#define g_main_context_new_OPTIONAL_ARGC 0
/* g_main_context_new
 *
 * Parameters: None
 * Return Type: GMainContext *
 */
mrb_value
mrb_GLib_g_main_context_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GMainContext * native_return_value = g_main_context_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMainContext(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_context_pending_FUNCTION
#define g_main_context_pending_REQUIRED_ARGC 1
#define g_main_context_pending_OPTIONAL_ARGC 0
/* g_main_context_pending
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_main_context_pending(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  gboolean native_return_value = g_main_context_pending(native_context);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_context_pop_thread_default_FUNCTION
#define g_main_context_pop_thread_default_REQUIRED_ARGC 1
#define g_main_context_pop_thread_default_OPTIONAL_ARGC 0
/* g_main_context_pop_thread_default
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_pop_thread_default(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  g_main_context_pop_thread_default(native_context);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_prepare_FUNCTION
#define g_main_context_prepare_REQUIRED_ARGC 2
#define g_main_context_prepare_OPTIONAL_ARGC 0
/* g_main_context_prepare
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - priority: int *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_main_context_prepare(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value priority;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &context, &priority);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_PTR(priority);

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  int * native_priority = TODO_mruby_unbox_int_PTR(priority);

  /* Invocation */
  gboolean native_return_value = g_main_context_prepare(native_context, native_priority);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_context_push_thread_default_FUNCTION
#define g_main_context_push_thread_default_REQUIRED_ARGC 1
#define g_main_context_push_thread_default_OPTIONAL_ARGC 0
/* g_main_context_push_thread_default
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_push_thread_default(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  g_main_context_push_thread_default(native_context);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_query_FUNCTION
#define g_main_context_query_REQUIRED_ARGC 5
#define g_main_context_query_OPTIONAL_ARGC 0
/* g_main_context_query
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - max_priority: int
 * - timeout_: int *
 * - fds: struct _GPollFD *
 * - n_fds: int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_main_context_query(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_int native_max_priority;
  mrb_value timeout_;
  mrb_value fds;
  mrb_int native_n_fds;

  /* Fetch the args */
  mrb_get_args(mrb, "oiooi", &context, &native_max_priority, &timeout_, &fds, &native_n_fds);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_PTR(timeout_);
  if (!mrb_obj_is_kind_of(mrb, fds, GPollFD_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPollFD expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  int * native_timeout_ = TODO_mruby_unbox_int_PTR(timeout_);

  struct _GPollFD * native_fds = (mrb_nil_p(fds) ? NULL : mruby_unbox__GPollFD(fds));

  /* Invocation */
  gint native_return_value = g_main_context_query(native_context, native_max_priority, native_timeout_, native_fds, native_n_fds);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_context_ref_FUNCTION
#define g_main_context_ref_REQUIRED_ARGC 1
#define g_main_context_ref_OPTIONAL_ARGC 0
/* g_main_context_ref
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: GMainContext *
 */
mrb_value
mrb_GLib_g_main_context_ref(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  GMainContext * native_return_value = g_main_context_ref(native_context);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMainContext(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_context_ref_thread_default_FUNCTION
#define g_main_context_ref_thread_default_REQUIRED_ARGC 0
#define g_main_context_ref_thread_default_OPTIONAL_ARGC 0
/* g_main_context_ref_thread_default
 *
 * Parameters: None
 * Return Type: GMainContext *
 */
mrb_value
mrb_GLib_g_main_context_ref_thread_default(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GMainContext * native_return_value = g_main_context_ref_thread_default();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMainContext(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_context_release_FUNCTION
#define g_main_context_release_REQUIRED_ARGC 1
#define g_main_context_release_OPTIONAL_ARGC 0
/* g_main_context_release
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_release(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  g_main_context_release(native_context);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_remove_poll_FUNCTION
#define g_main_context_remove_poll_REQUIRED_ARGC 2
#define g_main_context_remove_poll_OPTIONAL_ARGC 0
/* g_main_context_remove_poll
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - fd: struct _GPollFD *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_remove_poll(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value fd;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &context, &fd);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, fd, GPollFD_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPollFD expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  struct _GPollFD * native_fd = (mrb_nil_p(fd) ? NULL : mruby_unbox__GPollFD(fd));

  /* Invocation */
  g_main_context_remove_poll(native_context, native_fd);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_set_poll_func_FUNCTION
#define g_main_context_set_poll_func_REQUIRED_ARGC 2
#define g_main_context_set_poll_func_OPTIONAL_ARGC 0
/* g_main_context_set_poll_func
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - func: int (*)(struct _GPollFD *, unsigned int, int)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_set_poll_func(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &context, &func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GPollFD_PTR_COMMA_unsigned_intCOMMA_int_RPAREN(func);

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  int (*native_func)(struct _GPollFD *, unsigned int, int) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GPollFD_PTR_COMMA_unsigned_intCOMMA_int_RPAREN(func);

  /* Invocation */
  g_main_context_set_poll_func(native_context, native_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_unref_FUNCTION
#define g_main_context_unref_REQUIRED_ARGC 1
#define g_main_context_unref_OPTIONAL_ARGC 0
/* g_main_context_unref
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_unref(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  g_main_context_unref(native_context);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_context_wait_FUNCTION
#define g_main_context_wait_REQUIRED_ARGC 3
#define g_main_context_wait_OPTIONAL_ARGC 0
/* g_main_context_wait
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - cond: struct _GCond *
 * - mutex: union _GMutex *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_main_context_wait(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value cond;
  mrb_value mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &context, &cond, &mutex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, cond, GCond_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GCond expected");
    return mrb_nil_value();
  }
  TODO_type_check_union__GMutex_PTR(mutex);

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  struct _GCond * native_cond = (mrb_nil_p(cond) ? NULL : mruby_unbox__GCond(cond));

  union _GMutex * native_mutex = TODO_mruby_unbox_union__GMutex_PTR(mutex);

  /* Invocation */
  gboolean native_return_value = g_main_context_wait(native_context, native_cond, native_mutex);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_context_wakeup_FUNCTION
#define g_main_context_wakeup_REQUIRED_ARGC 1
#define g_main_context_wakeup_OPTIONAL_ARGC 0
/* g_main_context_wakeup
 *
 * Parameters:
 * - context: struct _GMainContext *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_context_wakeup(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  g_main_context_wakeup(native_context);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_current_source_FUNCTION
#define g_main_current_source_REQUIRED_ARGC 0
#define g_main_current_source_OPTIONAL_ARGC 0
/* g_main_current_source
 *
 * Parameters: None
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_main_current_source(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GSource * native_return_value = g_main_current_source();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_depth_FUNCTION
#define g_main_depth_REQUIRED_ARGC 0
#define g_main_depth_OPTIONAL_ARGC 0
/* g_main_depth
 *
 * Parameters: None
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_main_depth(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gint native_return_value = g_main_depth();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_loop_get_context_FUNCTION
#define g_main_loop_get_context_REQUIRED_ARGC 1
#define g_main_loop_get_context_OPTIONAL_ARGC 0
/* g_main_loop_get_context
 *
 * Parameters:
 * - loop: struct _GMainLoop *
 * Return Type: GMainContext *
 */
mrb_value
mrb_GLib_g_main_loop_get_context(mrb_state* mrb, mrb_value self) {
  mrb_value loop;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &loop);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, loop, GMainLoop_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainLoop expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainLoop * native_loop = (mrb_nil_p(loop) ? NULL : mruby_unbox__GMainLoop(loop));

  /* Invocation */
  GMainContext * native_return_value = g_main_loop_get_context(native_loop);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMainContext(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_loop_is_running_FUNCTION
#define g_main_loop_is_running_REQUIRED_ARGC 1
#define g_main_loop_is_running_OPTIONAL_ARGC 0
/* g_main_loop_is_running
 *
 * Parameters:
 * - loop: struct _GMainLoop *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_main_loop_is_running(mrb_state* mrb, mrb_value self) {
  mrb_value loop;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &loop);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, loop, GMainLoop_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainLoop expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainLoop * native_loop = (mrb_nil_p(loop) ? NULL : mruby_unbox__GMainLoop(loop));

  /* Invocation */
  gboolean native_return_value = g_main_loop_is_running(native_loop);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_main_loop_new_FUNCTION
#define g_main_loop_new_REQUIRED_ARGC 2
#define g_main_loop_new_OPTIONAL_ARGC 0
/* g_main_loop_new
 *
 * Parameters:
 * - context: struct _GMainContext *
 * - is_running: int
 * Return Type: GMainLoop *
 */
mrb_value
mrb_GLib_g_main_loop_new(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_int native_is_running;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &context, &native_is_running);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  GMainLoop * native_return_value = g_main_loop_new(native_context, native_is_running);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMainLoop(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_loop_quit_FUNCTION
#define g_main_loop_quit_REQUIRED_ARGC 1
#define g_main_loop_quit_OPTIONAL_ARGC 0
/* g_main_loop_quit
 *
 * Parameters:
 * - loop: struct _GMainLoop *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_loop_quit(mrb_state* mrb, mrb_value self) {
  mrb_value loop;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &loop);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, loop, GMainLoop_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainLoop expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainLoop * native_loop = (mrb_nil_p(loop) ? NULL : mruby_unbox__GMainLoop(loop));

  /* Invocation */
  g_main_loop_quit(native_loop);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_loop_ref_FUNCTION
#define g_main_loop_ref_REQUIRED_ARGC 1
#define g_main_loop_ref_OPTIONAL_ARGC 0
/* g_main_loop_ref
 *
 * Parameters:
 * - loop: struct _GMainLoop *
 * Return Type: GMainLoop *
 */
mrb_value
mrb_GLib_g_main_loop_ref(mrb_state* mrb, mrb_value self) {
  mrb_value loop;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &loop);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, loop, GMainLoop_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainLoop expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainLoop * native_loop = (mrb_nil_p(loop) ? NULL : mruby_unbox__GMainLoop(loop));

  /* Invocation */
  GMainLoop * native_return_value = g_main_loop_ref(native_loop);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMainLoop(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_main_loop_run_FUNCTION
#define g_main_loop_run_REQUIRED_ARGC 1
#define g_main_loop_run_OPTIONAL_ARGC 0
/* g_main_loop_run
 *
 * Parameters:
 * - loop: struct _GMainLoop *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_loop_run(mrb_state* mrb, mrb_value self) {
  mrb_value loop;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &loop);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, loop, GMainLoop_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainLoop expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainLoop * native_loop = (mrb_nil_p(loop) ? NULL : mruby_unbox__GMainLoop(loop));

  /* Invocation */
  g_main_loop_run(native_loop);

  return mrb_nil_value();
}
#endif

#if BIND_g_main_loop_unref_FUNCTION
#define g_main_loop_unref_REQUIRED_ARGC 1
#define g_main_loop_unref_OPTIONAL_ARGC 0
/* g_main_loop_unref
 *
 * Parameters:
 * - loop: struct _GMainLoop *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_main_loop_unref(mrb_state* mrb, mrb_value self) {
  mrb_value loop;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &loop);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, loop, GMainLoop_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainLoop expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMainLoop * native_loop = (mrb_nil_p(loop) ? NULL : mruby_unbox__GMainLoop(loop));

  /* Invocation */
  g_main_loop_unref(native_loop);

  return mrb_nil_value();
}
#endif

#if BIND_g_malloc_FUNCTION
#define g_malloc_REQUIRED_ARGC 1
#define g_malloc_OPTIONAL_ARGC 0
/* g_malloc
 *
 * Parameters:
 * - n_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_malloc(mrb_state* mrb, mrb_value self) {
  mrb_int native_n_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_n_bytes);

  /* Invocation */
  gpointer native_return_value = g_malloc(native_n_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_malloc0_FUNCTION
#define g_malloc0_REQUIRED_ARGC 1
#define g_malloc0_OPTIONAL_ARGC 0
/* g_malloc0
 *
 * Parameters:
 * - n_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_malloc0(mrb_state* mrb, mrb_value self) {
  mrb_int native_n_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_n_bytes);

  /* Invocation */
  gpointer native_return_value = g_malloc0(native_n_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_malloc0_n_FUNCTION
#define g_malloc0_n_REQUIRED_ARGC 2
#define g_malloc0_n_OPTIONAL_ARGC 0
/* g_malloc0_n
 *
 * Parameters:
 * - n_blocks: unsigned long
 * - n_block_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_malloc0_n(mrb_state* mrb, mrb_value self) {
  mrb_int native_n_blocks;
  mrb_int native_n_block_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_n_blocks, &native_n_block_bytes);

  /* Invocation */
  gpointer native_return_value = g_malloc0_n(native_n_blocks, native_n_block_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_malloc_n_FUNCTION
#define g_malloc_n_REQUIRED_ARGC 2
#define g_malloc_n_OPTIONAL_ARGC 0
/* g_malloc_n
 *
 * Parameters:
 * - n_blocks: unsigned long
 * - n_block_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_malloc_n(mrb_state* mrb, mrb_value self) {
  mrb_int native_n_blocks;
  mrb_int native_n_block_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_n_blocks, &native_n_block_bytes);

  /* Invocation */
  gpointer native_return_value = g_malloc_n(native_n_blocks, native_n_block_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_mapped_file_free_FUNCTION
#define g_mapped_file_free_REQUIRED_ARGC 1
#define g_mapped_file_free_OPTIONAL_ARGC 0
/* g_mapped_file_free
 *
 * Parameters:
 * - file: struct _GMappedFile *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_mapped_file_free(mrb_state* mrb, mrb_value self) {
  mrb_value file;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &file);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, file, GMappedFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMappedFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMappedFile * native_file = (mrb_nil_p(file) ? NULL : mruby_unbox__GMappedFile(file));

  /* Invocation */
  g_mapped_file_free(native_file);

  return mrb_nil_value();
}
#endif

#if BIND_g_mapped_file_get_bytes_FUNCTION
#define g_mapped_file_get_bytes_REQUIRED_ARGC 1
#define g_mapped_file_get_bytes_OPTIONAL_ARGC 0
/* g_mapped_file_get_bytes
 *
 * Parameters:
 * - file: struct _GMappedFile *
 * Return Type: GBytes *
 */
mrb_value
mrb_GLib_g_mapped_file_get_bytes(mrb_state* mrb, mrb_value self) {
  mrb_value file;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &file);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, file, GMappedFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMappedFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMappedFile * native_file = (mrb_nil_p(file) ? NULL : mruby_unbox__GMappedFile(file));

  /* Invocation */
  GBytes * native_return_value = g_mapped_file_get_bytes(native_file);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBytes(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_mapped_file_get_contents_FUNCTION
#define g_mapped_file_get_contents_REQUIRED_ARGC 1
#define g_mapped_file_get_contents_OPTIONAL_ARGC 0
/* g_mapped_file_get_contents
 *
 * Parameters:
 * - file: struct _GMappedFile *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_mapped_file_get_contents(mrb_state* mrb, mrb_value self) {
  mrb_value file;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &file);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, file, GMappedFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMappedFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMappedFile * native_file = (mrb_nil_p(file) ? NULL : mruby_unbox__GMappedFile(file));

  /* Invocation */
  gchar * native_return_value = g_mapped_file_get_contents(native_file);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_mapped_file_get_length_FUNCTION
#define g_mapped_file_get_length_REQUIRED_ARGC 1
#define g_mapped_file_get_length_OPTIONAL_ARGC 0
/* g_mapped_file_get_length
 *
 * Parameters:
 * - file: struct _GMappedFile *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_mapped_file_get_length(mrb_state* mrb, mrb_value self) {
  mrb_value file;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &file);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, file, GMappedFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMappedFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMappedFile * native_file = (mrb_nil_p(file) ? NULL : mruby_unbox__GMappedFile(file));

  /* Invocation */
  gsize native_return_value = g_mapped_file_get_length(native_file);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_mapped_file_new_FUNCTION
#define g_mapped_file_new_REQUIRED_ARGC 2
#define g_mapped_file_new_OPTIONAL_ARGC 0
/* g_mapped_file_new
 *
 * Parameters:
 * - filename: const char *
 * - writable: int
 * Return Type: GMappedFile *
 */
mrb_value
mrb_GLib_g_mapped_file_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_filename = NULL;
  mrb_int native_writable;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_filename, &native_writable);

  /* Invocation */
  GMappedFile * native_return_value = g_mapped_file_new(native_filename, native_writable, &native_error);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMappedFile(mrb, native_return_value));
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_mapped_file_new_from_fd_FUNCTION
#define g_mapped_file_new_from_fd_REQUIRED_ARGC 2
#define g_mapped_file_new_from_fd_OPTIONAL_ARGC 0
/* g_mapped_file_new_from_fd
 *
 * Parameters:
 * - fd: int
 * - writable: int
 * Return Type: GMappedFile *
 */
mrb_value
mrb_GLib_g_mapped_file_new_from_fd(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_int native_fd;
  mrb_int native_writable;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_fd, &native_writable);

  /* Invocation */
  GMappedFile * native_return_value = g_mapped_file_new_from_fd(native_fd, native_writable, &native_error);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMappedFile(mrb, native_return_value));
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_mapped_file_ref_FUNCTION
#define g_mapped_file_ref_REQUIRED_ARGC 1
#define g_mapped_file_ref_OPTIONAL_ARGC 0
/* g_mapped_file_ref
 *
 * Parameters:
 * - file: struct _GMappedFile *
 * Return Type: GMappedFile *
 */
mrb_value
mrb_GLib_g_mapped_file_ref(mrb_state* mrb, mrb_value self) {
  mrb_value file;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &file);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, file, GMappedFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMappedFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMappedFile * native_file = (mrb_nil_p(file) ? NULL : mruby_unbox__GMappedFile(file));

  /* Invocation */
  GMappedFile * native_return_value = g_mapped_file_ref(native_file);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMappedFile(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_mapped_file_unref_FUNCTION
#define g_mapped_file_unref_REQUIRED_ARGC 1
#define g_mapped_file_unref_OPTIONAL_ARGC 0
/* g_mapped_file_unref
 *
 * Parameters:
 * - file: struct _GMappedFile *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_mapped_file_unref(mrb_state* mrb, mrb_value self) {
  mrb_value file;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &file);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, file, GMappedFile_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMappedFile expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMappedFile * native_file = (mrb_nil_p(file) ? NULL : mruby_unbox__GMappedFile(file));

  /* Invocation */
  g_mapped_file_unref(native_file);

  return mrb_nil_value();
}
#endif

#if BIND_g_markup_collect_attributes_FUNCTION
#define g_markup_collect_attributes_REQUIRED_ARGC 5
#define g_markup_collect_attributes_OPTIONAL_ARGC 0
/* g_markup_collect_attributes
 *
 * Parameters:
 * - element_name: const char *
 * - attribute_names: const char **
 * - attribute_values: const char **
 * - first_type: GMarkupCollectType
 * - first_attr: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_markup_collect_attributes(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_element_name = NULL;
  mrb_value attribute_names;
  mrb_value attribute_values;
  struct GError * native_error = NULL;
  mrb_int native_first_type;
  char * native_first_attr = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ooiz!", &native_element_name, &attribute_names, &attribute_values, &native_first_type, &native_first_attr);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(attribute_names);
  TODO_type_check_char_PTR_PTR(attribute_values);

  /* Unbox parameters */
  const char ** native_attribute_names = TODO_mruby_unbox_char_PTR_PTR(attribute_names);

  const char ** native_attribute_values = TODO_mruby_unbox_char_PTR_PTR(attribute_values);

  /* Invocation */
  gboolean native_return_value = g_markup_collect_attributes(native_element_name, native_attribute_names, native_attribute_values, &native_error, native_first_type, native_first_attr);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_markup_error_quark_FUNCTION
#define g_markup_error_quark_REQUIRED_ARGC 0
#define g_markup_error_quark_OPTIONAL_ARGC 0
/* g_markup_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_markup_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_markup_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_markup_escape_text_FUNCTION
#define g_markup_escape_text_REQUIRED_ARGC 2
#define g_markup_escape_text_OPTIONAL_ARGC 0
/* g_markup_escape_text
 *
 * Parameters:
 * - text: const char *
 * - length: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_markup_escape_text(mrb_state* mrb, mrb_value self) {
  char * native_text = NULL;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_text, &native_length);

  /* Invocation */
  gchar * native_return_value = g_markup_escape_text(native_text, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_markup_parse_context_end_parse_FUNCTION
#define g_markup_parse_context_end_parse_REQUIRED_ARGC 1
#define g_markup_parse_context_end_parse_OPTIONAL_ARGC 0
/* g_markup_parse_context_end_parse
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_markup_parse_context_end_parse(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value context;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  /* Invocation */
  gboolean native_return_value = g_markup_parse_context_end_parse(native_context, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_markup_parse_context_free_FUNCTION
#define g_markup_parse_context_free_REQUIRED_ARGC 1
#define g_markup_parse_context_free_OPTIONAL_ARGC 0
/* g_markup_parse_context_free
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_markup_parse_context_free(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  /* Invocation */
  g_markup_parse_context_free(native_context);

  return mrb_nil_value();
}
#endif

#if BIND_g_markup_parse_context_get_element_FUNCTION
#define g_markup_parse_context_get_element_REQUIRED_ARGC 1
#define g_markup_parse_context_get_element_OPTIONAL_ARGC 0
/* g_markup_parse_context_get_element
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_markup_parse_context_get_element(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  /* Invocation */
  const gchar * native_return_value = g_markup_parse_context_get_element(native_context);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_markup_parse_context_get_element_stack_FUNCTION
#define g_markup_parse_context_get_element_stack_REQUIRED_ARGC 1
#define g_markup_parse_context_get_element_stack_OPTIONAL_ARGC 0
/* g_markup_parse_context_get_element_stack
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * Return Type: const GSList *
 */
mrb_value
mrb_GLib_g_markup_parse_context_get_element_stack(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  /* Invocation */
  const GSList * native_return_value = g_markup_parse_context_get_element_stack(native_context);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_markup_parse_context_get_position_FUNCTION
#define g_markup_parse_context_get_position_REQUIRED_ARGC 3
#define g_markup_parse_context_get_position_OPTIONAL_ARGC 0
/* g_markup_parse_context_get_position
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * - line_number: int *
 * - char_number: int *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_markup_parse_context_get_position(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value line_number;
  mrb_value char_number;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &context, &line_number, &char_number);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_PTR(line_number);
  TODO_type_check_int_PTR(char_number);

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  int * native_line_number = TODO_mruby_unbox_int_PTR(line_number);

  int * native_char_number = TODO_mruby_unbox_int_PTR(char_number);

  /* Invocation */
  g_markup_parse_context_get_position(native_context, native_line_number, native_char_number);

  return mrb_nil_value();
}
#endif

#if BIND_g_markup_parse_context_get_user_data_FUNCTION
#define g_markup_parse_context_get_user_data_REQUIRED_ARGC 1
#define g_markup_parse_context_get_user_data_OPTIONAL_ARGC 0
/* g_markup_parse_context_get_user_data
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_markup_parse_context_get_user_data(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  /* Invocation */
  gpointer native_return_value = g_markup_parse_context_get_user_data(native_context);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_markup_parse_context_new_FUNCTION
#define g_markup_parse_context_new_REQUIRED_ARGC 4
#define g_markup_parse_context_new_OPTIONAL_ARGC 0
/* g_markup_parse_context_new
 *
 * Parameters:
 * - parser: const struct _GMarkupParser *
 * - flags: GMarkupParseFlags
 * - user_data: void *
 * - user_data_dnotify: void (*)(void *)
 * Return Type: GMarkupParseContext *
 */
mrb_value
mrb_GLib_g_markup_parse_context_new(mrb_state* mrb, mrb_value self) {
  mrb_value parser;
  mrb_int native_flags;
  mrb_value user_data;
  mrb_value user_data_dnotify;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &parser, &native_flags, &user_data, &user_data_dnotify);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, parser, GMarkupParser_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParser expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(user_data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(user_data_dnotify);

  /* Unbox parameters */
  const struct _GMarkupParser * native_parser = (mrb_nil_p(parser) ? NULL : mruby_unbox__GMarkupParser(parser));

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  void (*native_user_data_dnotify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(user_data_dnotify);

  /* Invocation */
  GMarkupParseContext * native_return_value = g_markup_parse_context_new(native_parser, native_flags, native_user_data, native_user_data_dnotify);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMarkupParseContext(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_markup_parse_context_parse_FUNCTION
#define g_markup_parse_context_parse_REQUIRED_ARGC 3
#define g_markup_parse_context_parse_OPTIONAL_ARGC 0
/* g_markup_parse_context_parse
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * - text: const char *
 * - text_len: long
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_markup_parse_context_parse(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value context;
  char * native_text = NULL;
  mrb_int native_text_len;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &context, &native_text, &native_text_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  /* Invocation */
  gboolean native_return_value = g_markup_parse_context_parse(native_context, native_text, native_text_len, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_markup_parse_context_pop_FUNCTION
#define g_markup_parse_context_pop_REQUIRED_ARGC 1
#define g_markup_parse_context_pop_OPTIONAL_ARGC 0
/* g_markup_parse_context_pop
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_markup_parse_context_pop(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  /* Invocation */
  gpointer native_return_value = g_markup_parse_context_pop(native_context);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_markup_parse_context_push_FUNCTION
#define g_markup_parse_context_push_REQUIRED_ARGC 3
#define g_markup_parse_context_push_OPTIONAL_ARGC 0
/* g_markup_parse_context_push
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * - parser: const struct _GMarkupParser *
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_markup_parse_context_push(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value parser;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &context, &parser, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, parser, GMarkupParser_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParser expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  const struct _GMarkupParser * native_parser = (mrb_nil_p(parser) ? NULL : mruby_unbox__GMarkupParser(parser));

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_markup_parse_context_push(native_context, native_parser, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_markup_parse_context_ref_FUNCTION
#define g_markup_parse_context_ref_REQUIRED_ARGC 1
#define g_markup_parse_context_ref_OPTIONAL_ARGC 0
/* g_markup_parse_context_ref
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * Return Type: GMarkupParseContext *
 */
mrb_value
mrb_GLib_g_markup_parse_context_ref(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  /* Invocation */
  GMarkupParseContext * native_return_value = g_markup_parse_context_ref(native_context);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMarkupParseContext(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_markup_parse_context_unref_FUNCTION
#define g_markup_parse_context_unref_REQUIRED_ARGC 1
#define g_markup_parse_context_unref_OPTIONAL_ARGC 0
/* g_markup_parse_context_unref
 *
 * Parameters:
 * - context: struct _GMarkupParseContext *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_markup_parse_context_unref(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GMarkupParseContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMarkupParseContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMarkupParseContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMarkupParseContext(context));

  /* Invocation */
  g_markup_parse_context_unref(native_context);

  return mrb_nil_value();
}
#endif

#if BIND_g_markup_printf_escaped_FUNCTION
#define g_markup_printf_escaped_REQUIRED_ARGC 1
#define g_markup_printf_escaped_OPTIONAL_ARGC 0
/* g_markup_printf_escaped
 *
 * Parameters:
 * - format: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_markup_printf_escaped(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_format);

  /* Invocation */
  gchar * native_return_value = g_markup_printf_escaped(native_format);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_markup_vprintf_escaped_FUNCTION
#define g_markup_vprintf_escaped_REQUIRED_ARGC 2
#define g_markup_vprintf_escaped_OPTIONAL_ARGC 0
/* g_markup_vprintf_escaped
 *
 * Parameters:
 * - format: const char *
 * - args: int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_markup_vprintf_escaped(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;
  mrb_int native_args;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_format, &native_args);

  /* Invocation */
  gchar * native_return_value = g_markup_vprintf_escaped(native_format, native_args);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_match_info_expand_references_FUNCTION
#define g_match_info_expand_references_REQUIRED_ARGC 2
#define g_match_info_expand_references_OPTIONAL_ARGC 0
/* g_match_info_expand_references
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * - string_to_expand: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_match_info_expand_references(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value match_info;
  char * native_string_to_expand = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &match_info, &native_string_to_expand);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  gchar * native_return_value = g_match_info_expand_references(native_match_info, native_string_to_expand, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_match_info_fetch_FUNCTION
#define g_match_info_fetch_REQUIRED_ARGC 2
#define g_match_info_fetch_OPTIONAL_ARGC 0
/* g_match_info_fetch
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * - match_num: int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_match_info_fetch(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;
  mrb_int native_match_num;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &match_info, &native_match_num);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  gchar * native_return_value = g_match_info_fetch(native_match_info, native_match_num);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_match_info_fetch_all_FUNCTION
#define g_match_info_fetch_all_REQUIRED_ARGC 1
#define g_match_info_fetch_all_OPTIONAL_ARGC 0
/* g_match_info_fetch_all
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_match_info_fetch_all(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  gchar ** native_return_value = g_match_info_fetch_all(native_match_info);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_match_info_fetch_named_FUNCTION
#define g_match_info_fetch_named_REQUIRED_ARGC 2
#define g_match_info_fetch_named_OPTIONAL_ARGC 0
/* g_match_info_fetch_named
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * - name: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_match_info_fetch_named(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &match_info, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  gchar * native_return_value = g_match_info_fetch_named(native_match_info, native_name);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_match_info_fetch_named_pos_FUNCTION
#define g_match_info_fetch_named_pos_REQUIRED_ARGC 4
#define g_match_info_fetch_named_pos_OPTIONAL_ARGC 0
/* g_match_info_fetch_named_pos
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * - name: const char *
 * - start_pos: int *
 * - end_pos: int *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_match_info_fetch_named_pos(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;
  char * native_name = NULL;
  mrb_value start_pos;
  mrb_value end_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!oo", &match_info, &native_name, &start_pos, &end_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_PTR(start_pos);
  TODO_type_check_int_PTR(end_pos);

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  int * native_start_pos = TODO_mruby_unbox_int_PTR(start_pos);

  int * native_end_pos = TODO_mruby_unbox_int_PTR(end_pos);

  /* Invocation */
  gboolean native_return_value = g_match_info_fetch_named_pos(native_match_info, native_name, native_start_pos, native_end_pos);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_match_info_fetch_pos_FUNCTION
#define g_match_info_fetch_pos_REQUIRED_ARGC 4
#define g_match_info_fetch_pos_OPTIONAL_ARGC 0
/* g_match_info_fetch_pos
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * - match_num: int
 * - start_pos: int *
 * - end_pos: int *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_match_info_fetch_pos(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;
  mrb_int native_match_num;
  mrb_value start_pos;
  mrb_value end_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &match_info, &native_match_num, &start_pos, &end_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_PTR(start_pos);
  TODO_type_check_int_PTR(end_pos);

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  int * native_start_pos = TODO_mruby_unbox_int_PTR(start_pos);

  int * native_end_pos = TODO_mruby_unbox_int_PTR(end_pos);

  /* Invocation */
  gboolean native_return_value = g_match_info_fetch_pos(native_match_info, native_match_num, native_start_pos, native_end_pos);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_match_info_free_FUNCTION
#define g_match_info_free_REQUIRED_ARGC 1
#define g_match_info_free_OPTIONAL_ARGC 0
/* g_match_info_free
 *
 * Parameters:
 * - match_info: struct _GMatchInfo *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_match_info_free(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  g_match_info_free(native_match_info);

  return mrb_nil_value();
}
#endif

#if BIND_g_match_info_get_match_count_FUNCTION
#define g_match_info_get_match_count_REQUIRED_ARGC 1
#define g_match_info_get_match_count_OPTIONAL_ARGC 0
/* g_match_info_get_match_count
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_match_info_get_match_count(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  gint native_return_value = g_match_info_get_match_count(native_match_info);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_match_info_get_regex_FUNCTION
#define g_match_info_get_regex_REQUIRED_ARGC 1
#define g_match_info_get_regex_OPTIONAL_ARGC 0
/* g_match_info_get_regex
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * Return Type: GRegex *
 */
mrb_value
mrb_GLib_g_match_info_get_regex(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  GRegex * native_return_value = g_match_info_get_regex(native_match_info);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GRegex(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_match_info_get_string_FUNCTION
#define g_match_info_get_string_REQUIRED_ARGC 1
#define g_match_info_get_string_OPTIONAL_ARGC 0
/* g_match_info_get_string
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_match_info_get_string(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  const gchar * native_return_value = g_match_info_get_string(native_match_info);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_match_info_is_partial_match_FUNCTION
#define g_match_info_is_partial_match_REQUIRED_ARGC 1
#define g_match_info_is_partial_match_OPTIONAL_ARGC 0
/* g_match_info_is_partial_match
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_match_info_is_partial_match(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  gboolean native_return_value = g_match_info_is_partial_match(native_match_info);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_match_info_matches_FUNCTION
#define g_match_info_matches_REQUIRED_ARGC 1
#define g_match_info_matches_OPTIONAL_ARGC 0
/* g_match_info_matches
 *
 * Parameters:
 * - match_info: const struct _GMatchInfo *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_match_info_matches(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  gboolean native_return_value = g_match_info_matches(native_match_info);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_match_info_next_FUNCTION
#define g_match_info_next_REQUIRED_ARGC 1
#define g_match_info_next_OPTIONAL_ARGC 0
/* g_match_info_next
 *
 * Parameters:
 * - match_info: struct _GMatchInfo *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_match_info_next(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value match_info;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  gboolean native_return_value = g_match_info_next(native_match_info, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_match_info_ref_FUNCTION
#define g_match_info_ref_REQUIRED_ARGC 1
#define g_match_info_ref_OPTIONAL_ARGC 0
/* g_match_info_ref
 *
 * Parameters:
 * - match_info: struct _GMatchInfo *
 * Return Type: GMatchInfo *
 */
mrb_value
mrb_GLib_g_match_info_ref(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  GMatchInfo * native_return_value = g_match_info_ref(native_match_info);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMatchInfo(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_match_info_unref_FUNCTION
#define g_match_info_unref_REQUIRED_ARGC 1
#define g_match_info_unref_OPTIONAL_ARGC 0
/* g_match_info_unref
 *
 * Parameters:
 * - match_info: struct _GMatchInfo *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_match_info_unref(mrb_state* mrb, mrb_value self) {
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, match_info, GMatchInfo_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMatchInfo expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMatchInfo * native_match_info = (mrb_nil_p(match_info) ? NULL : mruby_unbox__GMatchInfo(match_info));

  /* Invocation */
  g_match_info_unref(native_match_info);

  return mrb_nil_value();
}
#endif

#if BIND_g_mem_is_system_malloc_FUNCTION
#define g_mem_is_system_malloc_REQUIRED_ARGC 0
#define g_mem_is_system_malloc_OPTIONAL_ARGC 0
/* g_mem_is_system_malloc
 *
 * Parameters: None
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_mem_is_system_malloc(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gboolean native_return_value = g_mem_is_system_malloc();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_mem_profile_FUNCTION
#define g_mem_profile_REQUIRED_ARGC 0
#define g_mem_profile_OPTIONAL_ARGC 0
/* g_mem_profile
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_GLib_g_mem_profile(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  g_mem_profile();

  return mrb_nil_value();
}
#endif

#if BIND_g_mem_set_vtable_FUNCTION
#define g_mem_set_vtable_REQUIRED_ARGC 1
#define g_mem_set_vtable_OPTIONAL_ARGC 0
/* g_mem_set_vtable
 *
 * Parameters:
 * - vtable: struct _GMemVTable *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_mem_set_vtable(mrb_state* mrb, mrb_value self) {
  mrb_value vtable;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &vtable);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, vtable, GMemVTable_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMemVTable expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GMemVTable * native_vtable = (mrb_nil_p(vtable) ? NULL : mruby_unbox__GMemVTable(vtable));

  /* Invocation */
  g_mem_set_vtable(native_vtable);

  return mrb_nil_value();
}
#endif

#if BIND_g_memdup_FUNCTION
#define g_memdup_REQUIRED_ARGC 2
#define g_memdup_OPTIONAL_ARGC 0
/* g_memdup
 *
 * Parameters:
 * - mem: const void *
 * - byte_size: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_memdup(mrb_state* mrb, mrb_value self) {
  mrb_value mem;
  mrb_int native_byte_size;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &mem, &native_byte_size);

  /* Type checking */
  TODO_type_check_void_PTR(mem);

  /* Unbox parameters */
  const void * native_mem = TODO_mruby_unbox_void_PTR(mem);

  /* Invocation */
  gpointer native_return_value = g_memdup(native_mem, native_byte_size);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_mkdir_with_parents_FUNCTION
#define g_mkdir_with_parents_REQUIRED_ARGC 2
#define g_mkdir_with_parents_OPTIONAL_ARGC 0
/* g_mkdir_with_parents
 *
 * Parameters:
 * - pathname: const char *
 * - mode: int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_mkdir_with_parents(mrb_state* mrb, mrb_value self) {
  char * native_pathname = NULL;
  mrb_int native_mode;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_pathname, &native_mode);

  /* Invocation */
  gint native_return_value = g_mkdir_with_parents(native_pathname, native_mode);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_mkdtemp_FUNCTION
#define g_mkdtemp_REQUIRED_ARGC 1
#define g_mkdtemp_OPTIONAL_ARGC 0
/* g_mkdtemp
 *
 * Parameters:
 * - tmpl: char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_mkdtemp(mrb_state* mrb, mrb_value self) {
  char * tmpl = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &tmpl);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_tmpl = strdup(tmpl);

  /* Invocation */
  gchar * native_return_value = g_mkdtemp(native_tmpl);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_tmpl);
  native_tmpl = NULL;

  return return_value;
}
#endif

#if BIND_g_mkdtemp_full_FUNCTION
#define g_mkdtemp_full_REQUIRED_ARGC 2
#define g_mkdtemp_full_OPTIONAL_ARGC 0
/* g_mkdtemp_full
 *
 * Parameters:
 * - tmpl: char *
 * - mode: int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_mkdtemp_full(mrb_state* mrb, mrb_value self) {
  char * tmpl = NULL;
  mrb_int native_mode;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &tmpl, &native_mode);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_tmpl = strdup(tmpl);

  /* Invocation */
  gchar * native_return_value = g_mkdtemp_full(native_tmpl, native_mode);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_tmpl);
  native_tmpl = NULL;

  return return_value;
}
#endif

#if BIND_g_mkstemp_FUNCTION
#define g_mkstemp_REQUIRED_ARGC 1
#define g_mkstemp_OPTIONAL_ARGC 0
/* g_mkstemp
 *
 * Parameters:
 * - tmpl: char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_mkstemp(mrb_state* mrb, mrb_value self) {
  char * tmpl = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &tmpl);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_tmpl = strdup(tmpl);

  /* Invocation */
  gint native_return_value = g_mkstemp(native_tmpl);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_tmpl);
  native_tmpl = NULL;

  return return_value;
}
#endif

#if BIND_g_mkstemp_full_FUNCTION
#define g_mkstemp_full_REQUIRED_ARGC 3
#define g_mkstemp_full_OPTIONAL_ARGC 0
/* g_mkstemp_full
 *
 * Parameters:
 * - tmpl: char *
 * - flags: int
 * - mode: int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_mkstemp_full(mrb_state* mrb, mrb_value self) {
  char * tmpl = NULL;
  mrb_int native_flags;
  mrb_int native_mode;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ii", &tmpl, &native_flags, &native_mode);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_tmpl = strdup(tmpl);

  /* Invocation */
  gint native_return_value = g_mkstemp_full(native_tmpl, native_flags, native_mode);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_tmpl);
  native_tmpl = NULL;

  return return_value;
}
#endif

#if BIND_g_mutex_clear_FUNCTION
#define g_mutex_clear_REQUIRED_ARGC 1
#define g_mutex_clear_OPTIONAL_ARGC 0
/* g_mutex_clear
 *
 * Parameters:
 * - mutex: union _GMutex *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_mutex_clear(mrb_state* mrb, mrb_value self) {
  mrb_value mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &mutex);

  /* Type checking */
  TODO_type_check_union__GMutex_PTR(mutex);

  /* Unbox parameters */
  union _GMutex * native_mutex = TODO_mruby_unbox_union__GMutex_PTR(mutex);

  /* Invocation */
  g_mutex_clear(native_mutex);

  return mrb_nil_value();
}
#endif

#if BIND_g_mutex_init_FUNCTION
#define g_mutex_init_REQUIRED_ARGC 1
#define g_mutex_init_OPTIONAL_ARGC 0
/* g_mutex_init
 *
 * Parameters:
 * - mutex: union _GMutex *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_mutex_init(mrb_state* mrb, mrb_value self) {
  mrb_value mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &mutex);

  /* Type checking */
  TODO_type_check_union__GMutex_PTR(mutex);

  /* Unbox parameters */
  union _GMutex * native_mutex = TODO_mruby_unbox_union__GMutex_PTR(mutex);

  /* Invocation */
  g_mutex_init(native_mutex);

  return mrb_nil_value();
}
#endif

#if BIND_g_mutex_lock_FUNCTION
#define g_mutex_lock_REQUIRED_ARGC 1
#define g_mutex_lock_OPTIONAL_ARGC 0
/* g_mutex_lock
 *
 * Parameters:
 * - mutex: union _GMutex *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_mutex_lock(mrb_state* mrb, mrb_value self) {
  mrb_value mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &mutex);

  /* Type checking */
  TODO_type_check_union__GMutex_PTR(mutex);

  /* Unbox parameters */
  union _GMutex * native_mutex = TODO_mruby_unbox_union__GMutex_PTR(mutex);

  /* Invocation */
  g_mutex_lock(native_mutex);

  return mrb_nil_value();
}
#endif

#if BIND_g_mutex_locker_free_FUNCTION
#define g_mutex_locker_free_REQUIRED_ARGC 1
#define g_mutex_locker_free_OPTIONAL_ARGC 0
/* g_mutex_locker_free
 *
 * Parameters:
 * - locker: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_mutex_locker_free(mrb_state* mrb, mrb_value self) {
  mrb_value locker;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &locker);

  /* Type checking */
  TODO_type_check_void_PTR(locker);

  /* Unbox parameters */
  void * native_locker = TODO_mruby_unbox_void_PTR(locker);

  /* Invocation */
  g_mutex_locker_free(native_locker);

  return mrb_nil_value();
}
#endif

#if BIND_g_mutex_locker_new_FUNCTION
#define g_mutex_locker_new_REQUIRED_ARGC 1
#define g_mutex_locker_new_OPTIONAL_ARGC 0
/* g_mutex_locker_new
 *
 * Parameters:
 * - mutex: union _GMutex *
 * Return Type: GMutexLocker *
 */
mrb_value
mrb_GLib_g_mutex_locker_new(mrb_state* mrb, mrb_value self) {
  mrb_value mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &mutex);

  /* Type checking */
  TODO_type_check_union__GMutex_PTR(mutex);

  /* Unbox parameters */
  union _GMutex * native_mutex = TODO_mruby_unbox_union__GMutex_PTR(mutex);

  /* Invocation */
  GMutexLocker * native_return_value = g_mutex_locker_new(native_mutex);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GMutexLocker_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_mutex_trylock_FUNCTION
#define g_mutex_trylock_REQUIRED_ARGC 1
#define g_mutex_trylock_OPTIONAL_ARGC 0
/* g_mutex_trylock
 *
 * Parameters:
 * - mutex: union _GMutex *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_mutex_trylock(mrb_state* mrb, mrb_value self) {
  mrb_value mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &mutex);

  /* Type checking */
  TODO_type_check_union__GMutex_PTR(mutex);

  /* Unbox parameters */
  union _GMutex * native_mutex = TODO_mruby_unbox_union__GMutex_PTR(mutex);

  /* Invocation */
  gboolean native_return_value = g_mutex_trylock(native_mutex);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_mutex_unlock_FUNCTION
#define g_mutex_unlock_REQUIRED_ARGC 1
#define g_mutex_unlock_OPTIONAL_ARGC 0
/* g_mutex_unlock
 *
 * Parameters:
 * - mutex: union _GMutex *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_mutex_unlock(mrb_state* mrb, mrb_value self) {
  mrb_value mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &mutex);

  /* Type checking */
  TODO_type_check_union__GMutex_PTR(mutex);

  /* Unbox parameters */
  union _GMutex * native_mutex = TODO_mruby_unbox_union__GMutex_PTR(mutex);

  /* Invocation */
  g_mutex_unlock(native_mutex);

  return mrb_nil_value();
}
#endif

#if BIND_g_node_child_index_FUNCTION
#define g_node_child_index_REQUIRED_ARGC 2
#define g_node_child_index_OPTIONAL_ARGC 0
/* g_node_child_index
 *
 * Parameters:
 * - node: struct _GNode *
 * - data: void *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_node_child_index(mrb_state* mrb, mrb_value self) {
  mrb_value node;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &node, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  gint native_return_value = g_node_child_index(native_node, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_node_child_position_FUNCTION
#define g_node_child_position_REQUIRED_ARGC 2
#define g_node_child_position_OPTIONAL_ARGC 0
/* g_node_child_position
 *
 * Parameters:
 * - node: struct _GNode *
 * - child: struct _GNode *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_node_child_position(mrb_state* mrb, mrb_value self) {
  mrb_value node;
  mrb_value child;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &node, &child);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, child, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  struct _GNode * native_child = (mrb_nil_p(child) ? NULL : mruby_unbox__GNode(child));

  /* Invocation */
  gint native_return_value = g_node_child_position(native_node, native_child);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_node_children_foreach_FUNCTION
#define g_node_children_foreach_REQUIRED_ARGC 4
#define g_node_children_foreach_OPTIONAL_ARGC 0
/* g_node_children_foreach
 *
 * Parameters:
 * - node: struct _GNode *
 * - flags: GTraverseFlags
 * - func: void (*)(struct _GNode *, void *)
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_node_children_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value node;
  mrb_int native_flags;
  mrb_value func;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &node, &native_flags, &func, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN__GNode_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  void (*native_func)(struct _GNode *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN__GNode_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_node_children_foreach(native_node, native_flags, native_func, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_node_copy_FUNCTION
#define g_node_copy_REQUIRED_ARGC 1
#define g_node_copy_OPTIONAL_ARGC 0
/* g_node_copy
 *
 * Parameters:
 * - node: struct _GNode *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_copy(mrb_state* mrb, mrb_value self) {
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  GNode * native_return_value = g_node_copy(native_node);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_copy_deep_FUNCTION
#define g_node_copy_deep_REQUIRED_ARGC 3
#define g_node_copy_deep_OPTIONAL_ARGC 0
/* g_node_copy_deep
 *
 * Parameters:
 * - node: struct _GNode *
 * - copy_func: void *(*)(const void *, void *)
 * - data: void *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_copy_deep(mrb_state* mrb, mrb_value self) {
  mrb_value node;
  mrb_value copy_func;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &node, &copy_func, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(copy_func);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  void *(*native_copy_func)(const void *, void *) = TODO_mruby_unbox_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(copy_func);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GNode * native_return_value = g_node_copy_deep(native_node, native_copy_func, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_depth_FUNCTION
#define g_node_depth_REQUIRED_ARGC 1
#define g_node_depth_OPTIONAL_ARGC 0
/* g_node_depth
 *
 * Parameters:
 * - node: struct _GNode *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_node_depth(mrb_state* mrb, mrb_value self) {
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  guint native_return_value = g_node_depth(native_node);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_node_destroy_FUNCTION
#define g_node_destroy_REQUIRED_ARGC 1
#define g_node_destroy_OPTIONAL_ARGC 0
/* g_node_destroy
 *
 * Parameters:
 * - root: struct _GNode *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_node_destroy(mrb_state* mrb, mrb_value self) {
  mrb_value root;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &root);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, root, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_root = (mrb_nil_p(root) ? NULL : mruby_unbox__GNode(root));

  /* Invocation */
  g_node_destroy(native_root);

  return mrb_nil_value();
}
#endif

#if BIND_g_node_find_FUNCTION
#define g_node_find_REQUIRED_ARGC 4
#define g_node_find_OPTIONAL_ARGC 0
/* g_node_find
 *
 * Parameters:
 * - root: struct _GNode *
 * - order: GTraverseType
 * - flags: GTraverseFlags
 * - data: void *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_find(mrb_state* mrb, mrb_value self) {
  mrb_value root;
  mrb_int native_order;
  mrb_int native_flags;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oiio", &root, &native_order, &native_flags, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, root, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GNode * native_root = (mrb_nil_p(root) ? NULL : mruby_unbox__GNode(root));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GNode * native_return_value = g_node_find(native_root, native_order, native_flags, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_find_child_FUNCTION
#define g_node_find_child_REQUIRED_ARGC 3
#define g_node_find_child_OPTIONAL_ARGC 0
/* g_node_find_child
 *
 * Parameters:
 * - node: struct _GNode *
 * - flags: GTraverseFlags
 * - data: void *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_find_child(mrb_state* mrb, mrb_value self) {
  mrb_value node;
  mrb_int native_flags;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &node, &native_flags, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GNode * native_return_value = g_node_find_child(native_node, native_flags, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_first_sibling_FUNCTION
#define g_node_first_sibling_REQUIRED_ARGC 1
#define g_node_first_sibling_OPTIONAL_ARGC 0
/* g_node_first_sibling
 *
 * Parameters:
 * - node: struct _GNode *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_first_sibling(mrb_state* mrb, mrb_value self) {
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  GNode * native_return_value = g_node_first_sibling(native_node);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_get_root_FUNCTION
#define g_node_get_root_REQUIRED_ARGC 1
#define g_node_get_root_OPTIONAL_ARGC 0
/* g_node_get_root
 *
 * Parameters:
 * - node: struct _GNode *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_get_root(mrb_state* mrb, mrb_value self) {
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  GNode * native_return_value = g_node_get_root(native_node);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_insert_FUNCTION
#define g_node_insert_REQUIRED_ARGC 3
#define g_node_insert_OPTIONAL_ARGC 0
/* g_node_insert
 *
 * Parameters:
 * - parent: struct _GNode *
 * - position: int
 * - node: struct _GNode *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_insert(mrb_state* mrb, mrb_value self) {
  mrb_value parent;
  mrb_int native_position;
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &parent, &native_position, &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, parent, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_parent = (mrb_nil_p(parent) ? NULL : mruby_unbox__GNode(parent));

  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  GNode * native_return_value = g_node_insert(native_parent, native_position, native_node);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_insert_after_FUNCTION
#define g_node_insert_after_REQUIRED_ARGC 3
#define g_node_insert_after_OPTIONAL_ARGC 0
/* g_node_insert_after
 *
 * Parameters:
 * - parent: struct _GNode *
 * - sibling: struct _GNode *
 * - node: struct _GNode *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_insert_after(mrb_state* mrb, mrb_value self) {
  mrb_value parent;
  mrb_value sibling;
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &parent, &sibling, &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, parent, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sibling, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_parent = (mrb_nil_p(parent) ? NULL : mruby_unbox__GNode(parent));

  struct _GNode * native_sibling = (mrb_nil_p(sibling) ? NULL : mruby_unbox__GNode(sibling));

  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  GNode * native_return_value = g_node_insert_after(native_parent, native_sibling, native_node);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_insert_before_FUNCTION
#define g_node_insert_before_REQUIRED_ARGC 3
#define g_node_insert_before_OPTIONAL_ARGC 0
/* g_node_insert_before
 *
 * Parameters:
 * - parent: struct _GNode *
 * - sibling: struct _GNode *
 * - node: struct _GNode *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_insert_before(mrb_state* mrb, mrb_value self) {
  mrb_value parent;
  mrb_value sibling;
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &parent, &sibling, &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, parent, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sibling, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_parent = (mrb_nil_p(parent) ? NULL : mruby_unbox__GNode(parent));

  struct _GNode * native_sibling = (mrb_nil_p(sibling) ? NULL : mruby_unbox__GNode(sibling));

  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  GNode * native_return_value = g_node_insert_before(native_parent, native_sibling, native_node);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_is_ancestor_FUNCTION
#define g_node_is_ancestor_REQUIRED_ARGC 2
#define g_node_is_ancestor_OPTIONAL_ARGC 0
/* g_node_is_ancestor
 *
 * Parameters:
 * - node: struct _GNode *
 * - descendant: struct _GNode *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_node_is_ancestor(mrb_state* mrb, mrb_value self) {
  mrb_value node;
  mrb_value descendant;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &node, &descendant);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, descendant, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  struct _GNode * native_descendant = (mrb_nil_p(descendant) ? NULL : mruby_unbox__GNode(descendant));

  /* Invocation */
  gboolean native_return_value = g_node_is_ancestor(native_node, native_descendant);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_node_last_child_FUNCTION
#define g_node_last_child_REQUIRED_ARGC 1
#define g_node_last_child_OPTIONAL_ARGC 0
/* g_node_last_child
 *
 * Parameters:
 * - node: struct _GNode *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_last_child(mrb_state* mrb, mrb_value self) {
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  GNode * native_return_value = g_node_last_child(native_node);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_last_sibling_FUNCTION
#define g_node_last_sibling_REQUIRED_ARGC 1
#define g_node_last_sibling_OPTIONAL_ARGC 0
/* g_node_last_sibling
 *
 * Parameters:
 * - node: struct _GNode *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_last_sibling(mrb_state* mrb, mrb_value self) {
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  GNode * native_return_value = g_node_last_sibling(native_node);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_max_height_FUNCTION
#define g_node_max_height_REQUIRED_ARGC 1
#define g_node_max_height_OPTIONAL_ARGC 0
/* g_node_max_height
 *
 * Parameters:
 * - root: struct _GNode *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_node_max_height(mrb_state* mrb, mrb_value self) {
  mrb_value root;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &root);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, root, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_root = (mrb_nil_p(root) ? NULL : mruby_unbox__GNode(root));

  /* Invocation */
  guint native_return_value = g_node_max_height(native_root);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_node_n_children_FUNCTION
#define g_node_n_children_REQUIRED_ARGC 1
#define g_node_n_children_OPTIONAL_ARGC 0
/* g_node_n_children
 *
 * Parameters:
 * - node: struct _GNode *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_node_n_children(mrb_state* mrb, mrb_value self) {
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  guint native_return_value = g_node_n_children(native_node);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_node_n_nodes_FUNCTION
#define g_node_n_nodes_REQUIRED_ARGC 2
#define g_node_n_nodes_OPTIONAL_ARGC 0
/* g_node_n_nodes
 *
 * Parameters:
 * - root: struct _GNode *
 * - flags: GTraverseFlags
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_node_n_nodes(mrb_state* mrb, mrb_value self) {
  mrb_value root;
  mrb_int native_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &root, &native_flags);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, root, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_root = (mrb_nil_p(root) ? NULL : mruby_unbox__GNode(root));

  /* Invocation */
  guint native_return_value = g_node_n_nodes(native_root, native_flags);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_node_new_FUNCTION
#define g_node_new_REQUIRED_ARGC 1
#define g_node_new_OPTIONAL_ARGC 0
/* g_node_new
 *
 * Parameters:
 * - data: void *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_new(mrb_state* mrb, mrb_value self) {
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &data);

  /* Type checking */
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GNode * native_return_value = g_node_new(native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_nth_child_FUNCTION
#define g_node_nth_child_REQUIRED_ARGC 2
#define g_node_nth_child_OPTIONAL_ARGC 0
/* g_node_nth_child
 *
 * Parameters:
 * - node: struct _GNode *
 * - n: unsigned int
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_nth_child(mrb_state* mrb, mrb_value self) {
  mrb_value node;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &node, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  GNode * native_return_value = g_node_nth_child(native_node, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_prepend_FUNCTION
#define g_node_prepend_REQUIRED_ARGC 2
#define g_node_prepend_OPTIONAL_ARGC 0
/* g_node_prepend
 *
 * Parameters:
 * - parent: struct _GNode *
 * - node: struct _GNode *
 * Return Type: GNode *
 */
mrb_value
mrb_GLib_g_node_prepend(mrb_state* mrb, mrb_value self) {
  mrb_value parent;
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &parent, &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, parent, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_parent = (mrb_nil_p(parent) ? NULL : mruby_unbox__GNode(parent));

  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  GNode * native_return_value = g_node_prepend(native_parent, native_node);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_node_reverse_children_FUNCTION
#define g_node_reverse_children_REQUIRED_ARGC 1
#define g_node_reverse_children_OPTIONAL_ARGC 0
/* g_node_reverse_children
 *
 * Parameters:
 * - node: struct _GNode *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_node_reverse_children(mrb_state* mrb, mrb_value self) {
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  g_node_reverse_children(native_node);

  return mrb_nil_value();
}
#endif

#if BIND_g_node_traverse_FUNCTION
#define g_node_traverse_REQUIRED_ARGC 6
#define g_node_traverse_OPTIONAL_ARGC 0
/* g_node_traverse
 *
 * Parameters:
 * - root: struct _GNode *
 * - order: GTraverseType
 * - flags: GTraverseFlags
 * - max_depth: int
 * - func: int (*)(struct _GNode *, void *)
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_node_traverse(mrb_state* mrb, mrb_value self) {
  mrb_value root;
  mrb_int native_order;
  mrb_int native_flags;
  mrb_int native_max_depth;
  mrb_value func;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oiiioo", &root, &native_order, &native_flags, &native_max_depth, &func, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, root, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GNode_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GNode * native_root = (mrb_nil_p(root) ? NULL : mruby_unbox__GNode(root));

  int (*native_func)(struct _GNode *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GNode_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_node_traverse(native_root, native_order, native_flags, native_max_depth, native_func, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_node_unlink_FUNCTION
#define g_node_unlink_REQUIRED_ARGC 1
#define g_node_unlink_OPTIONAL_ARGC 0
/* g_node_unlink
 *
 * Parameters:
 * - node: struct _GNode *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_node_unlink(mrb_state* mrb, mrb_value self) {
  mrb_value node;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &node);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, node, GNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GNode * native_node = (mrb_nil_p(node) ? NULL : mruby_unbox__GNode(node));

  /* Invocation */
  g_node_unlink(native_node);

  return mrb_nil_value();
}
#endif

#if BIND_g_nullify_pointer_FUNCTION
#define g_nullify_pointer_REQUIRED_ARGC 1
#define g_nullify_pointer_OPTIONAL_ARGC 0
/* g_nullify_pointer
 *
 * Parameters:
 * - nullify_location: void **
 * Return Type: void
 */
mrb_value
mrb_GLib_g_nullify_pointer(mrb_state* mrb, mrb_value self) {
  mrb_value nullify_location;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &nullify_location);

  /* Type checking */
  TODO_type_check_void_PTR_PTR(nullify_location);

  /* Unbox parameters */
  void ** native_nullify_location = TODO_mruby_unbox_void_PTR_PTR(nullify_location);

  /* Invocation */
  g_nullify_pointer(native_nullify_location);

  return mrb_nil_value();
}
#endif

#if BIND_g_on_error_query_FUNCTION
#define g_on_error_query_REQUIRED_ARGC 1
#define g_on_error_query_OPTIONAL_ARGC 0
/* g_on_error_query
 *
 * Parameters:
 * - prg_name: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_on_error_query(mrb_state* mrb, mrb_value self) {
  char * native_prg_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_prg_name);

  /* Invocation */
  g_on_error_query(native_prg_name);

  return mrb_nil_value();
}
#endif

#if BIND_g_on_error_stack_trace_FUNCTION
#define g_on_error_stack_trace_REQUIRED_ARGC 1
#define g_on_error_stack_trace_OPTIONAL_ARGC 0
/* g_on_error_stack_trace
 *
 * Parameters:
 * - prg_name: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_on_error_stack_trace(mrb_state* mrb, mrb_value self) {
  char * native_prg_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_prg_name);

  /* Invocation */
  g_on_error_stack_trace(native_prg_name);

  return mrb_nil_value();
}
#endif

#if BIND_g_once_impl_FUNCTION
#define g_once_impl_REQUIRED_ARGC 3
#define g_once_impl_OPTIONAL_ARGC 0
/* g_once_impl
 *
 * Parameters:
 * - once: struct _GOnce *
 * - func: void *(*)(void *)
 * - arg: void *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_once_impl(mrb_state* mrb, mrb_value self) {
  mrb_value once;
  mrb_value func;
  mrb_value arg;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &once, &func, &arg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, once, GOnce_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOnce expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(arg);

  /* Unbox parameters */
  struct _GOnce * native_once = (mrb_nil_p(once) ? NULL : mruby_unbox__GOnce(once));

  void *(*native_func)(void *) = TODO_mruby_unbox_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(func);

  void * native_arg = TODO_mruby_unbox_void_PTR(arg);

  /* Invocation */
  gpointer native_return_value = g_once_impl(native_once, native_func, native_arg);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_once_init_enter_FUNCTION
#define g_once_init_enter_REQUIRED_ARGC 1
#define g_once_init_enter_OPTIONAL_ARGC 0
/* g_once_init_enter
 *
 * Parameters:
 * - location: volatile void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_once_init_enter(mrb_state* mrb, mrb_value self) {
  mrb_value location;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &location);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(location);

  /* Unbox parameters */
  volatile void * native_location = TODO_mruby_unbox_volatile_void_PTR(location);

  /* Invocation */
  gboolean native_return_value = g_once_init_enter(native_location);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_once_init_leave_FUNCTION
#define g_once_init_leave_REQUIRED_ARGC 2
#define g_once_init_leave_OPTIONAL_ARGC 0
/* g_once_init_leave
 *
 * Parameters:
 * - location: volatile void *
 * - result: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_once_init_leave(mrb_state* mrb, mrb_value self) {
  mrb_value location;
  mrb_int native_result;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &location, &native_result);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(location);

  /* Unbox parameters */
  volatile void * native_location = TODO_mruby_unbox_volatile_void_PTR(location);

  /* Invocation */
  g_once_init_leave(native_location, native_result);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_add_group_FUNCTION
#define g_option_context_add_group_REQUIRED_ARGC 2
#define g_option_context_add_group_OPTIONAL_ARGC 0
/* g_option_context_add_group
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - group: struct _GOptionGroup *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_add_group(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value group;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &context, &group);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  /* Invocation */
  g_option_context_add_group(native_context, native_group);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_add_main_entries_FUNCTION
#define g_option_context_add_main_entries_REQUIRED_ARGC 3
#define g_option_context_add_main_entries_OPTIONAL_ARGC 0
/* g_option_context_add_main_entries
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - entries: const struct _GOptionEntry *
 * - translation_domain: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_add_main_entries(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value entries;
  char * native_translation_domain = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooz!", &context, &entries, &native_translation_domain);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, entries, GOptionEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionEntry expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  const struct _GOptionEntry * native_entries = (mrb_nil_p(entries) ? NULL : mruby_unbox__GOptionEntry(entries));

  /* Invocation */
  g_option_context_add_main_entries(native_context, native_entries, native_translation_domain);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_free_FUNCTION
#define g_option_context_free_REQUIRED_ARGC 1
#define g_option_context_free_OPTIONAL_ARGC 0
/* g_option_context_free
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_free(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  g_option_context_free(native_context);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_get_description_FUNCTION
#define g_option_context_get_description_REQUIRED_ARGC 1
#define g_option_context_get_description_OPTIONAL_ARGC 0
/* g_option_context_get_description
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_option_context_get_description(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  const gchar * native_return_value = g_option_context_get_description(native_context);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_option_context_get_help_FUNCTION
#define g_option_context_get_help_REQUIRED_ARGC 3
#define g_option_context_get_help_OPTIONAL_ARGC 0
/* g_option_context_get_help
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - main_help: int
 * - group: struct _GOptionGroup *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_option_context_get_help(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_int native_main_help;
  mrb_value group;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &context, &native_main_help, &group);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  /* Invocation */
  gchar * native_return_value = g_option_context_get_help(native_context, native_main_help, native_group);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_option_context_get_help_enabled_FUNCTION
#define g_option_context_get_help_enabled_REQUIRED_ARGC 1
#define g_option_context_get_help_enabled_OPTIONAL_ARGC 0
/* g_option_context_get_help_enabled
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_option_context_get_help_enabled(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  gboolean native_return_value = g_option_context_get_help_enabled(native_context);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_option_context_get_ignore_unknown_options_FUNCTION
#define g_option_context_get_ignore_unknown_options_REQUIRED_ARGC 1
#define g_option_context_get_ignore_unknown_options_OPTIONAL_ARGC 0
/* g_option_context_get_ignore_unknown_options
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_option_context_get_ignore_unknown_options(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  gboolean native_return_value = g_option_context_get_ignore_unknown_options(native_context);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_option_context_get_main_group_FUNCTION
#define g_option_context_get_main_group_REQUIRED_ARGC 1
#define g_option_context_get_main_group_OPTIONAL_ARGC 0
/* g_option_context_get_main_group
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * Return Type: GOptionGroup *
 */
mrb_value
mrb_GLib_g_option_context_get_main_group(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  GOptionGroup * native_return_value = g_option_context_get_main_group(native_context);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GOptionGroup(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_option_context_get_strict_posix_FUNCTION
#define g_option_context_get_strict_posix_REQUIRED_ARGC 1
#define g_option_context_get_strict_posix_OPTIONAL_ARGC 0
/* g_option_context_get_strict_posix
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_option_context_get_strict_posix(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  gboolean native_return_value = g_option_context_get_strict_posix(native_context);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_option_context_get_summary_FUNCTION
#define g_option_context_get_summary_REQUIRED_ARGC 1
#define g_option_context_get_summary_OPTIONAL_ARGC 0
/* g_option_context_get_summary
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_option_context_get_summary(mrb_state* mrb, mrb_value self) {
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  const gchar * native_return_value = g_option_context_get_summary(native_context);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_option_context_new_FUNCTION
#define g_option_context_new_REQUIRED_ARGC 1
#define g_option_context_new_OPTIONAL_ARGC 0
/* g_option_context_new
 *
 * Parameters:
 * - parameter_string: const char *
 * Return Type: GOptionContext *
 */
mrb_value
mrb_GLib_g_option_context_new(mrb_state* mrb, mrb_value self) {
  char * native_parameter_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_parameter_string);

  /* Invocation */
  GOptionContext * native_return_value = g_option_context_new(native_parameter_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GOptionContext(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_option_context_parse_FUNCTION
#define g_option_context_parse_REQUIRED_ARGC 3
#define g_option_context_parse_OPTIONAL_ARGC 0
/* g_option_context_parse
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - argc: int *
 * - argv: char ***
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_option_context_parse(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value context;
  mrb_value argc;
  mrb_value argv;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &context, &argc, &argv);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_PTR(argc);
  TODO_type_check_char_PTR_PTR_PTR(argv);

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  int * native_argc = TODO_mruby_unbox_int_PTR(argc);

  char *** native_argv = TODO_mruby_unbox_char_PTR_PTR_PTR(argv);

  /* Invocation */
  gboolean native_return_value = g_option_context_parse(native_context, native_argc, native_argv, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_option_context_parse_strv_FUNCTION
#define g_option_context_parse_strv_REQUIRED_ARGC 2
#define g_option_context_parse_strv_OPTIONAL_ARGC 0
/* g_option_context_parse_strv
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - arguments: char ***
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_option_context_parse_strv(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value context;
  mrb_value arguments;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &context, &arguments);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR_PTR(arguments);

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  char *** native_arguments = TODO_mruby_unbox_char_PTR_PTR_PTR(arguments);

  /* Invocation */
  gboolean native_return_value = g_option_context_parse_strv(native_context, native_arguments, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_option_context_set_description_FUNCTION
#define g_option_context_set_description_REQUIRED_ARGC 2
#define g_option_context_set_description_OPTIONAL_ARGC 0
/* g_option_context_set_description
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - description: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_set_description(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  char * native_description = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &context, &native_description);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  g_option_context_set_description(native_context, native_description);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_set_help_enabled_FUNCTION
#define g_option_context_set_help_enabled_REQUIRED_ARGC 2
#define g_option_context_set_help_enabled_OPTIONAL_ARGC 0
/* g_option_context_set_help_enabled
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - help_enabled: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_set_help_enabled(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_int native_help_enabled;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &context, &native_help_enabled);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  g_option_context_set_help_enabled(native_context, native_help_enabled);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_set_ignore_unknown_options_FUNCTION
#define g_option_context_set_ignore_unknown_options_REQUIRED_ARGC 2
#define g_option_context_set_ignore_unknown_options_OPTIONAL_ARGC 0
/* g_option_context_set_ignore_unknown_options
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - ignore_unknown: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_set_ignore_unknown_options(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_int native_ignore_unknown;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &context, &native_ignore_unknown);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  g_option_context_set_ignore_unknown_options(native_context, native_ignore_unknown);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_set_main_group_FUNCTION
#define g_option_context_set_main_group_REQUIRED_ARGC 2
#define g_option_context_set_main_group_OPTIONAL_ARGC 0
/* g_option_context_set_main_group
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - group: struct _GOptionGroup *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_set_main_group(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value group;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &context, &group);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  /* Invocation */
  g_option_context_set_main_group(native_context, native_group);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_set_strict_posix_FUNCTION
#define g_option_context_set_strict_posix_REQUIRED_ARGC 2
#define g_option_context_set_strict_posix_OPTIONAL_ARGC 0
/* g_option_context_set_strict_posix
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - strict_posix: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_set_strict_posix(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_int native_strict_posix;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &context, &native_strict_posix);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  g_option_context_set_strict_posix(native_context, native_strict_posix);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_set_summary_FUNCTION
#define g_option_context_set_summary_REQUIRED_ARGC 2
#define g_option_context_set_summary_OPTIONAL_ARGC 0
/* g_option_context_set_summary
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - summary: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_set_summary(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  char * native_summary = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &context, &native_summary);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  g_option_context_set_summary(native_context, native_summary);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_set_translate_func_FUNCTION
#define g_option_context_set_translate_func_REQUIRED_ARGC 4
#define g_option_context_set_translate_func_OPTIONAL_ARGC 0
/* g_option_context_set_translate_func
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - func: const char *(*)(const char *, void *)
 * - data: void *
 * - destroy_notify: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_set_translate_func(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  mrb_value func;
  mrb_value data;
  mrb_value destroy_notify;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &context, &func, &data, &destroy_notify);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_LPAREN_PTR_RPAREN_LPAREN_const_char_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy_notify);

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  const char *(*native_func)(const char *, void *) = TODO_mruby_unbox_char_PTR_LPAREN_PTR_RPAREN_LPAREN_const_char_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_destroy_notify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy_notify);

  /* Invocation */
  g_option_context_set_translate_func(native_context, native_func, native_data, native_destroy_notify);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_context_set_translation_domain_FUNCTION
#define g_option_context_set_translation_domain_REQUIRED_ARGC 2
#define g_option_context_set_translation_domain_OPTIONAL_ARGC 0
/* g_option_context_set_translation_domain
 *
 * Parameters:
 * - context: struct _GOptionContext *
 * - domain: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_context_set_translation_domain(mrb_state* mrb, mrb_value self) {
  mrb_value context;
  char * native_domain = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &context, &native_domain);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, context, GOptionContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GOptionContext(context));

  /* Invocation */
  g_option_context_set_translation_domain(native_context, native_domain);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_error_quark_FUNCTION
#define g_option_error_quark_REQUIRED_ARGC 0
#define g_option_error_quark_OPTIONAL_ARGC 0
/* g_option_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_option_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_option_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_option_group_add_entries_FUNCTION
#define g_option_group_add_entries_REQUIRED_ARGC 2
#define g_option_group_add_entries_OPTIONAL_ARGC 0
/* g_option_group_add_entries
 *
 * Parameters:
 * - group: struct _GOptionGroup *
 * - entries: const struct _GOptionEntry *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_group_add_entries(mrb_state* mrb, mrb_value self) {
  mrb_value group;
  mrb_value entries;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &group, &entries);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, entries, GOptionEntry_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionEntry expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  const struct _GOptionEntry * native_entries = (mrb_nil_p(entries) ? NULL : mruby_unbox__GOptionEntry(entries));

  /* Invocation */
  g_option_group_add_entries(native_group, native_entries);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_group_free_FUNCTION
#define g_option_group_free_REQUIRED_ARGC 1
#define g_option_group_free_OPTIONAL_ARGC 0
/* g_option_group_free
 *
 * Parameters:
 * - group: struct _GOptionGroup *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_group_free(mrb_state* mrb, mrb_value self) {
  mrb_value group;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &group);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  /* Invocation */
  g_option_group_free(native_group);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_group_new_FUNCTION
#define g_option_group_new_REQUIRED_ARGC 5
#define g_option_group_new_OPTIONAL_ARGC 0
/* g_option_group_new
 *
 * Parameters:
 * - name: const char *
 * - description: const char *
 * - help_description: const char *
 * - user_data: void *
 * - destroy: void (*)(void *)
 * Return Type: GOptionGroup *
 */
mrb_value
mrb_GLib_g_option_group_new(mrb_state* mrb, mrb_value self) {
  char * native_name = NULL;
  char * native_description = NULL;
  char * native_help_description = NULL;
  mrb_value user_data;
  mrb_value destroy;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!z!oo", &native_name, &native_description, &native_help_description, &user_data, &destroy);

  /* Type checking */
  TODO_type_check_void_PTR(user_data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy);

  /* Unbox parameters */
  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  void (*native_destroy)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy);

  /* Invocation */
  GOptionGroup * native_return_value = g_option_group_new(native_name, native_description, native_help_description, native_user_data, native_destroy);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GOptionGroup(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_option_group_ref_FUNCTION
#define g_option_group_ref_REQUIRED_ARGC 1
#define g_option_group_ref_OPTIONAL_ARGC 0
/* g_option_group_ref
 *
 * Parameters:
 * - group: struct _GOptionGroup *
 * Return Type: GOptionGroup *
 */
mrb_value
mrb_GLib_g_option_group_ref(mrb_state* mrb, mrb_value self) {
  mrb_value group;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &group);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  /* Invocation */
  GOptionGroup * native_return_value = g_option_group_ref(native_group);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GOptionGroup(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_option_group_set_error_hook_FUNCTION
#define g_option_group_set_error_hook_REQUIRED_ARGC 2
#define g_option_group_set_error_hook_OPTIONAL_ARGC 0
/* g_option_group_set_error_hook
 *
 * Parameters:
 * - group: struct _GOptionGroup *
 * - error_func: void (*)(struct _GOptionContext *, struct _GOptionGroup *, void *, struct _GError **)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_group_set_error_hook(mrb_state* mrb, mrb_value self) {
  mrb_value group;
  mrb_value error_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &group, &error_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN__GOptionContext_PTR_COMMA_struct__GOptionGroup_PTR_COMMA_void_PTR_COMMA_struct__GError_PTR_PTR_RPAREN(error_func);

  /* Unbox parameters */
  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  void (*native_error_func)(struct _GOptionContext *, struct _GOptionGroup *, void *, struct _GError **) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN__GOptionContext_PTR_COMMA_struct__GOptionGroup_PTR_COMMA_void_PTR_COMMA_struct__GError_PTR_PTR_RPAREN(error_func);

  /* Invocation */
  g_option_group_set_error_hook(native_group, native_error_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_group_set_parse_hooks_FUNCTION
#define g_option_group_set_parse_hooks_REQUIRED_ARGC 3
#define g_option_group_set_parse_hooks_OPTIONAL_ARGC 0
/* g_option_group_set_parse_hooks
 *
 * Parameters:
 * - group: struct _GOptionGroup *
 * - pre_parse_func: int (*)(struct _GOptionContext *, struct _GOptionGroup *, void *, struct _GError **)
 * - post_parse_func: int (*)(struct _GOptionContext *, struct _GOptionGroup *, void *, struct _GError **)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_group_set_parse_hooks(mrb_state* mrb, mrb_value self) {
  mrb_value group;
  mrb_value pre_parse_func;
  mrb_value post_parse_func;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &group, &pre_parse_func, &post_parse_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GOptionContext_PTR_COMMA_struct__GOptionGroup_PTR_COMMA_void_PTR_COMMA_struct__GError_PTR_PTR_RPAREN(pre_parse_func);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GOptionContext_PTR_COMMA_struct__GOptionGroup_PTR_COMMA_void_PTR_COMMA_struct__GError_PTR_PTR_RPAREN(post_parse_func);

  /* Unbox parameters */
  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  int (*native_pre_parse_func)(struct _GOptionContext *, struct _GOptionGroup *, void *, struct _GError **) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GOptionContext_PTR_COMMA_struct__GOptionGroup_PTR_COMMA_void_PTR_COMMA_struct__GError_PTR_PTR_RPAREN(pre_parse_func);

  int (*native_post_parse_func)(struct _GOptionContext *, struct _GOptionGroup *, void *, struct _GError **) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GOptionContext_PTR_COMMA_struct__GOptionGroup_PTR_COMMA_void_PTR_COMMA_struct__GError_PTR_PTR_RPAREN(post_parse_func);

  /* Invocation */
  g_option_group_set_parse_hooks(native_group, native_pre_parse_func, native_post_parse_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_group_set_translate_func_FUNCTION
#define g_option_group_set_translate_func_REQUIRED_ARGC 4
#define g_option_group_set_translate_func_OPTIONAL_ARGC 0
/* g_option_group_set_translate_func
 *
 * Parameters:
 * - group: struct _GOptionGroup *
 * - func: const char *(*)(const char *, void *)
 * - data: void *
 * - destroy_notify: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_group_set_translate_func(mrb_state* mrb, mrb_value self) {
  mrb_value group;
  mrb_value func;
  mrb_value data;
  mrb_value destroy_notify;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &group, &func, &data, &destroy_notify);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_LPAREN_PTR_RPAREN_LPAREN_const_char_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy_notify);

  /* Unbox parameters */
  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  const char *(*native_func)(const char *, void *) = TODO_mruby_unbox_char_PTR_LPAREN_PTR_RPAREN_LPAREN_const_char_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_destroy_notify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy_notify);

  /* Invocation */
  g_option_group_set_translate_func(native_group, native_func, native_data, native_destroy_notify);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_group_set_translation_domain_FUNCTION
#define g_option_group_set_translation_domain_REQUIRED_ARGC 2
#define g_option_group_set_translation_domain_OPTIONAL_ARGC 0
/* g_option_group_set_translation_domain
 *
 * Parameters:
 * - group: struct _GOptionGroup *
 * - domain: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_group_set_translation_domain(mrb_state* mrb, mrb_value self) {
  mrb_value group;
  char * native_domain = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &group, &native_domain);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  /* Invocation */
  g_option_group_set_translation_domain(native_group, native_domain);

  return mrb_nil_value();
}
#endif

#if BIND_g_option_group_unref_FUNCTION
#define g_option_group_unref_REQUIRED_ARGC 1
#define g_option_group_unref_OPTIONAL_ARGC 0
/* g_option_group_unref
 *
 * Parameters:
 * - group: struct _GOptionGroup *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_option_group_unref(mrb_state* mrb, mrb_value self) {
  mrb_value group;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &group);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, group, GOptionGroup_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GOptionGroup expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GOptionGroup * native_group = (mrb_nil_p(group) ? NULL : mruby_unbox__GOptionGroup(group));

  /* Invocation */
  g_option_group_unref(native_group);

  return mrb_nil_value();
}
#endif

#if BIND_g_parse_debug_string_FUNCTION
#define g_parse_debug_string_REQUIRED_ARGC 3
#define g_parse_debug_string_OPTIONAL_ARGC 0
/* g_parse_debug_string
 *
 * Parameters:
 * - string: const char *
 * - keys: const struct _GDebugKey *
 * - nkeys: unsigned int
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_parse_debug_string(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;
  mrb_value keys;
  mrb_int native_nkeys;

  /* Fetch the args */
  mrb_get_args(mrb, "z!oi", &native_string, &keys, &native_nkeys);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, keys, GDebugKey_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GDebugKey expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GDebugKey * native_keys = (mrb_nil_p(keys) ? NULL : mruby_unbox__GDebugKey(keys));

  /* Invocation */
  guint native_return_value = g_parse_debug_string(native_string, native_keys, native_nkeys);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_path_get_basename_FUNCTION
#define g_path_get_basename_REQUIRED_ARGC 1
#define g_path_get_basename_OPTIONAL_ARGC 0
/* g_path_get_basename
 *
 * Parameters:
 * - file_name: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_path_get_basename(mrb_state* mrb, mrb_value self) {
  char * native_file_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_file_name);

  /* Invocation */
  gchar * native_return_value = g_path_get_basename(native_file_name);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_path_get_dirname_FUNCTION
#define g_path_get_dirname_REQUIRED_ARGC 1
#define g_path_get_dirname_OPTIONAL_ARGC 0
/* g_path_get_dirname
 *
 * Parameters:
 * - file_name: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_path_get_dirname(mrb_state* mrb, mrb_value self) {
  char * native_file_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_file_name);

  /* Invocation */
  gchar * native_return_value = g_path_get_dirname(native_file_name);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_path_is_absolute_FUNCTION
#define g_path_is_absolute_REQUIRED_ARGC 1
#define g_path_is_absolute_OPTIONAL_ARGC 0
/* g_path_is_absolute
 *
 * Parameters:
 * - file_name: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_path_is_absolute(mrb_state* mrb, mrb_value self) {
  char * native_file_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_file_name);

  /* Invocation */
  gboolean native_return_value = g_path_is_absolute(native_file_name);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_path_skip_root_FUNCTION
#define g_path_skip_root_REQUIRED_ARGC 1
#define g_path_skip_root_OPTIONAL_ARGC 0
/* g_path_skip_root
 *
 * Parameters:
 * - file_name: const char *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_path_skip_root(mrb_state* mrb, mrb_value self) {
  char * native_file_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_file_name);

  /* Invocation */
  const gchar * native_return_value = g_path_skip_root(native_file_name);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_pattern_match_FUNCTION
#define g_pattern_match_REQUIRED_ARGC 4
#define g_pattern_match_OPTIONAL_ARGC 0
/* g_pattern_match
 *
 * Parameters:
 * - pspec: struct _GPatternSpec *
 * - string_length: unsigned int
 * - string: const char *
 * - string_reversed: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_pattern_match(mrb_state* mrb, mrb_value self) {
  mrb_value pspec;
  mrb_int native_string_length;
  char * native_string = NULL;
  char * native_string_reversed = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz!z!", &pspec, &native_string_length, &native_string, &native_string_reversed);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pspec, GPatternSpec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPatternSpec expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPatternSpec * native_pspec = (mrb_nil_p(pspec) ? NULL : mruby_unbox__GPatternSpec(pspec));

  /* Invocation */
  gboolean native_return_value = g_pattern_match(native_pspec, native_string_length, native_string, native_string_reversed);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_pattern_match_simple_FUNCTION
#define g_pattern_match_simple_REQUIRED_ARGC 2
#define g_pattern_match_simple_OPTIONAL_ARGC 0
/* g_pattern_match_simple
 *
 * Parameters:
 * - pattern: const char *
 * - string: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_pattern_match_simple(mrb_state* mrb, mrb_value self) {
  char * native_pattern = NULL;
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_pattern, &native_string);

  /* Invocation */
  gboolean native_return_value = g_pattern_match_simple(native_pattern, native_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_pattern_match_string_FUNCTION
#define g_pattern_match_string_REQUIRED_ARGC 2
#define g_pattern_match_string_OPTIONAL_ARGC 0
/* g_pattern_match_string
 *
 * Parameters:
 * - pspec: struct _GPatternSpec *
 * - string: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_pattern_match_string(mrb_state* mrb, mrb_value self) {
  mrb_value pspec;
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &pspec, &native_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pspec, GPatternSpec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPatternSpec expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPatternSpec * native_pspec = (mrb_nil_p(pspec) ? NULL : mruby_unbox__GPatternSpec(pspec));

  /* Invocation */
  gboolean native_return_value = g_pattern_match_string(native_pspec, native_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_pattern_spec_equal_FUNCTION
#define g_pattern_spec_equal_REQUIRED_ARGC 2
#define g_pattern_spec_equal_OPTIONAL_ARGC 0
/* g_pattern_spec_equal
 *
 * Parameters:
 * - pspec1: struct _GPatternSpec *
 * - pspec2: struct _GPatternSpec *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_pattern_spec_equal(mrb_state* mrb, mrb_value self) {
  mrb_value pspec1;
  mrb_value pspec2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &pspec1, &pspec2);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pspec1, GPatternSpec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPatternSpec expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, pspec2, GPatternSpec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPatternSpec expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPatternSpec * native_pspec1 = (mrb_nil_p(pspec1) ? NULL : mruby_unbox__GPatternSpec(pspec1));

  struct _GPatternSpec * native_pspec2 = (mrb_nil_p(pspec2) ? NULL : mruby_unbox__GPatternSpec(pspec2));

  /* Invocation */
  gboolean native_return_value = g_pattern_spec_equal(native_pspec1, native_pspec2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_pattern_spec_free_FUNCTION
#define g_pattern_spec_free_REQUIRED_ARGC 1
#define g_pattern_spec_free_OPTIONAL_ARGC 0
/* g_pattern_spec_free
 *
 * Parameters:
 * - pspec: struct _GPatternSpec *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_pattern_spec_free(mrb_state* mrb, mrb_value self) {
  mrb_value pspec;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pspec);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pspec, GPatternSpec_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPatternSpec expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPatternSpec * native_pspec = (mrb_nil_p(pspec) ? NULL : mruby_unbox__GPatternSpec(pspec));

  /* Invocation */
  g_pattern_spec_free(native_pspec);

  return mrb_nil_value();
}
#endif

#if BIND_g_pattern_spec_new_FUNCTION
#define g_pattern_spec_new_REQUIRED_ARGC 1
#define g_pattern_spec_new_OPTIONAL_ARGC 0
/* g_pattern_spec_new
 *
 * Parameters:
 * - pattern: const char *
 * Return Type: GPatternSpec *
 */
mrb_value
mrb_GLib_g_pattern_spec_new(mrb_state* mrb, mrb_value self) {
  char * native_pattern = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_pattern);

  /* Invocation */
  GPatternSpec * native_return_value = g_pattern_spec_new(native_pattern);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GPatternSpec(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_pointer_bit_lock_FUNCTION
#define g_pointer_bit_lock_REQUIRED_ARGC 2
#define g_pointer_bit_lock_OPTIONAL_ARGC 0
/* g_pointer_bit_lock
 *
 * Parameters:
 * - address: volatile void *
 * - lock_bit: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_pointer_bit_lock(mrb_state* mrb, mrb_value self) {
  mrb_value address;
  mrb_int native_lock_bit;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &address, &native_lock_bit);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(address);

  /* Unbox parameters */
  volatile void * native_address = TODO_mruby_unbox_volatile_void_PTR(address);

  /* Invocation */
  g_pointer_bit_lock(native_address, native_lock_bit);

  return mrb_nil_value();
}
#endif

#if BIND_g_pointer_bit_trylock_FUNCTION
#define g_pointer_bit_trylock_REQUIRED_ARGC 2
#define g_pointer_bit_trylock_OPTIONAL_ARGC 0
/* g_pointer_bit_trylock
 *
 * Parameters:
 * - address: volatile void *
 * - lock_bit: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_pointer_bit_trylock(mrb_state* mrb, mrb_value self) {
  mrb_value address;
  mrb_int native_lock_bit;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &address, &native_lock_bit);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(address);

  /* Unbox parameters */
  volatile void * native_address = TODO_mruby_unbox_volatile_void_PTR(address);

  /* Invocation */
  gboolean native_return_value = g_pointer_bit_trylock(native_address, native_lock_bit);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_pointer_bit_unlock_FUNCTION
#define g_pointer_bit_unlock_REQUIRED_ARGC 2
#define g_pointer_bit_unlock_OPTIONAL_ARGC 0
/* g_pointer_bit_unlock
 *
 * Parameters:
 * - address: volatile void *
 * - lock_bit: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_pointer_bit_unlock(mrb_state* mrb, mrb_value self) {
  mrb_value address;
  mrb_int native_lock_bit;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &address, &native_lock_bit);

  /* Type checking */
  TODO_type_check_volatile_void_PTR(address);

  /* Unbox parameters */
  volatile void * native_address = TODO_mruby_unbox_volatile_void_PTR(address);

  /* Invocation */
  g_pointer_bit_unlock(native_address, native_lock_bit);

  return mrb_nil_value();
}
#endif

#if BIND_g_poll_FUNCTION
#define g_poll_REQUIRED_ARGC 3
#define g_poll_OPTIONAL_ARGC 0
/* g_poll
 *
 * Parameters:
 * - fds: struct _GPollFD *
 * - nfds: unsigned int
 * - timeout: int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_poll(mrb_state* mrb, mrb_value self) {
  mrb_value fds;
  mrb_int native_nfds;
  mrb_int native_timeout;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &fds, &native_nfds, &native_timeout);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, fds, GPollFD_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPollFD expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPollFD * native_fds = (mrb_nil_p(fds) ? NULL : mruby_unbox__GPollFD(fds));

  /* Invocation */
  gint native_return_value = g_poll(native_fds, native_nfds, native_timeout);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_prefix_error_FUNCTION
#define g_prefix_error_REQUIRED_ARGC 1
#define g_prefix_error_OPTIONAL_ARGC 0
/* g_prefix_error
 *
 * Parameters:
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_prefix_error(mrb_state* mrb, mrb_value self) {
  struct GError * native_err = NULL;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_format);

  /* Invocation */
  g_prefix_error(&native_err, native_format);

  /* Box the out parameters */
  mrb_value err = (native_err == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_err));

  return err;
}
#endif

#if BIND_g_print_FUNCTION
#define g_print_REQUIRED_ARGC 1
#define g_print_OPTIONAL_ARGC 0
/* g_print
 *
 * Parameters:
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_print(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_format);

  /* Invocation */
  g_print(native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_printerr_FUNCTION
#define g_printerr_REQUIRED_ARGC 1
#define g_printerr_OPTIONAL_ARGC 0
/* g_printerr
 *
 * Parameters:
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_printerr(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_format);

  /* Invocation */
  g_printerr(native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_printf_FUNCTION
#define g_printf_REQUIRED_ARGC 1
#define g_printf_OPTIONAL_ARGC 0
/* g_printf
 *
 * Parameters:
 * - format: const char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_printf(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_format);

  /* Invocation */
  gint native_return_value = g_printf(native_format);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_printf_string_upper_bound_FUNCTION
#define g_printf_string_upper_bound_REQUIRED_ARGC 2
#define g_printf_string_upper_bound_OPTIONAL_ARGC 0
/* g_printf_string_upper_bound
 *
 * Parameters:
 * - format: const char *
 * - args: int
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_printf_string_upper_bound(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;
  mrb_int native_args;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_format, &native_args);

  /* Invocation */
  gsize native_return_value = g_printf_string_upper_bound(native_format, native_args);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_private_get_FUNCTION
#define g_private_get_REQUIRED_ARGC 1
#define g_private_get_OPTIONAL_ARGC 0
/* g_private_get
 *
 * Parameters:
 * - key: struct _GPrivate *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_private_get(mrb_state* mrb, mrb_value self) {
  mrb_value key;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key, GPrivate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPrivate expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPrivate * native_key = (mrb_nil_p(key) ? NULL : mruby_unbox__GPrivate(key));

  /* Invocation */
  gpointer native_return_value = g_private_get(native_key);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_private_replace_FUNCTION
#define g_private_replace_REQUIRED_ARGC 2
#define g_private_replace_OPTIONAL_ARGC 0
/* g_private_replace
 *
 * Parameters:
 * - key: struct _GPrivate *
 * - value: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_private_replace(mrb_state* mrb, mrb_value self) {
  mrb_value key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key, GPrivate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPrivate expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(value);

  /* Unbox parameters */
  struct _GPrivate * native_key = (mrb_nil_p(key) ? NULL : mruby_unbox__GPrivate(key));

  void * native_value = TODO_mruby_unbox_void_PTR(value);

  /* Invocation */
  g_private_replace(native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_private_set_FUNCTION
#define g_private_set_REQUIRED_ARGC 2
#define g_private_set_OPTIONAL_ARGC 0
/* g_private_set
 *
 * Parameters:
 * - key: struct _GPrivate *
 * - value: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_private_set(mrb_state* mrb, mrb_value self) {
  mrb_value key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key, GPrivate_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPrivate expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(value);

  /* Unbox parameters */
  struct _GPrivate * native_key = (mrb_nil_p(key) ? NULL : mruby_unbox__GPrivate(key));

  void * native_value = TODO_mruby_unbox_void_PTR(value);

  /* Invocation */
  g_private_set(native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_propagate_error_FUNCTION
#define g_propagate_error_REQUIRED_ARGC 1
#define g_propagate_error_OPTIONAL_ARGC 0
/* g_propagate_error
 *
 * Parameters:
 * - src: struct _GError *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_propagate_error(mrb_state* mrb, mrb_value self) {
  struct GError * native_dest = NULL;
  mrb_value src;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &src);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, src, GError_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GError expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GError * native_src = (mrb_nil_p(src) ? NULL : mruby_unbox__GError(src));

  /* Invocation */
  g_propagate_error(&native_dest, native_src);

  /* Box the out parameters */
  mrb_value dest = (native_dest == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_dest));

  return dest;
}
#endif

#if BIND_g_propagate_prefixed_error_FUNCTION
#define g_propagate_prefixed_error_REQUIRED_ARGC 2
#define g_propagate_prefixed_error_OPTIONAL_ARGC 0
/* g_propagate_prefixed_error
 *
 * Parameters:
 * - src: struct _GError *
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_propagate_prefixed_error(mrb_state* mrb, mrb_value self) {
  struct GError * native_dest = NULL;
  mrb_value src;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &src, &native_format);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, src, GError_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GError expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GError * native_src = (mrb_nil_p(src) ? NULL : mruby_unbox__GError(src));

  /* Invocation */
  g_propagate_prefixed_error(&native_dest, native_src, native_format);

  /* Box the out parameters */
  mrb_value dest = (native_dest == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_dest));

  return dest;
}
#endif

#if BIND_g_ptr_array_add_FUNCTION
#define g_ptr_array_add_REQUIRED_ARGC 2
#define g_ptr_array_add_OPTIONAL_ARGC 0
/* g_ptr_array_add
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_ptr_array_add(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_ptr_array_add(native_array, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_ptr_array_foreach_FUNCTION
#define g_ptr_array_foreach_REQUIRED_ARGC 3
#define g_ptr_array_foreach_OPTIONAL_ARGC 0
/* g_ptr_array_foreach
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - func: void (*)(void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_ptr_array_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &array, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  void (*native_func)(void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_ptr_array_foreach(native_array, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_ptr_array_free_FUNCTION
#define g_ptr_array_free_REQUIRED_ARGC 2
#define g_ptr_array_free_OPTIONAL_ARGC 0
/* g_ptr_array_free
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - free_seg: int
 * Return Type: gpointer *
 */
mrb_value
mrb_GLib_g_ptr_array_free(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_free_seg;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_free_seg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  /* Invocation */
  gpointer * native_return_value = g_ptr_array_free(native_array, native_free_seg);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_insert_FUNCTION
#define g_ptr_array_insert_REQUIRED_ARGC 3
#define g_ptr_array_insert_OPTIONAL_ARGC 0
/* g_ptr_array_insert
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - index_: int
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_ptr_array_insert(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &array, &native_index_, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_ptr_array_insert(native_array, native_index_, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_ptr_array_new_FUNCTION
#define g_ptr_array_new_REQUIRED_ARGC 0
#define g_ptr_array_new_OPTIONAL_ARGC 0
/* g_ptr_array_new
 *
 * Parameters: None
 * Return Type: GPtrArray *
 */
mrb_value
mrb_GLib_g_ptr_array_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GPtrArray * native_return_value = g_ptr_array_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GPtrArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_new_full_FUNCTION
#define g_ptr_array_new_full_REQUIRED_ARGC 2
#define g_ptr_array_new_full_OPTIONAL_ARGC 0
/* g_ptr_array_new_full
 *
 * Parameters:
 * - reserved_size: unsigned int
 * - element_free_func: void (*)(void *)
 * Return Type: GPtrArray *
 */
mrb_value
mrb_GLib_g_ptr_array_new_full(mrb_state* mrb, mrb_value self) {
  mrb_int native_reserved_size;
  mrb_value element_free_func;

  /* Fetch the args */
  mrb_get_args(mrb, "io", &native_reserved_size, &element_free_func);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(element_free_func);

  /* Unbox parameters */
  void (*native_element_free_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(element_free_func);

  /* Invocation */
  GPtrArray * native_return_value = g_ptr_array_new_full(native_reserved_size, native_element_free_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GPtrArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_new_with_free_func_FUNCTION
#define g_ptr_array_new_with_free_func_REQUIRED_ARGC 1
#define g_ptr_array_new_with_free_func_OPTIONAL_ARGC 0
/* g_ptr_array_new_with_free_func
 *
 * Parameters:
 * - element_free_func: void (*)(void *)
 * Return Type: GPtrArray *
 */
mrb_value
mrb_GLib_g_ptr_array_new_with_free_func(mrb_state* mrb, mrb_value self) {
  mrb_value element_free_func;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &element_free_func);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(element_free_func);

  /* Unbox parameters */
  void (*native_element_free_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(element_free_func);

  /* Invocation */
  GPtrArray * native_return_value = g_ptr_array_new_with_free_func(native_element_free_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GPtrArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_ref_FUNCTION
#define g_ptr_array_ref_REQUIRED_ARGC 1
#define g_ptr_array_ref_OPTIONAL_ARGC 0
/* g_ptr_array_ref
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * Return Type: GPtrArray *
 */
mrb_value
mrb_GLib_g_ptr_array_ref(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  /* Invocation */
  GPtrArray * native_return_value = g_ptr_array_ref(native_array);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GPtrArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_remove_FUNCTION
#define g_ptr_array_remove_REQUIRED_ARGC 2
#define g_ptr_array_remove_OPTIONAL_ARGC 0
/* g_ptr_array_remove
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - data: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_ptr_array_remove(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  gboolean native_return_value = g_ptr_array_remove(native_array, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_remove_fast_FUNCTION
#define g_ptr_array_remove_fast_REQUIRED_ARGC 2
#define g_ptr_array_remove_fast_OPTIONAL_ARGC 0
/* g_ptr_array_remove_fast
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - data: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_ptr_array_remove_fast(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  gboolean native_return_value = g_ptr_array_remove_fast(native_array, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_remove_index_FUNCTION
#define g_ptr_array_remove_index_REQUIRED_ARGC 2
#define g_ptr_array_remove_index_OPTIONAL_ARGC 0
/* g_ptr_array_remove_index
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - index_: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_ptr_array_remove_index(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_index_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  /* Invocation */
  gpointer native_return_value = g_ptr_array_remove_index(native_array, native_index_);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_remove_index_fast_FUNCTION
#define g_ptr_array_remove_index_fast_REQUIRED_ARGC 2
#define g_ptr_array_remove_index_fast_OPTIONAL_ARGC 0
/* g_ptr_array_remove_index_fast
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - index_: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_ptr_array_remove_index_fast(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_index_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  /* Invocation */
  gpointer native_return_value = g_ptr_array_remove_index_fast(native_array, native_index_);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_remove_range_FUNCTION
#define g_ptr_array_remove_range_REQUIRED_ARGC 3
#define g_ptr_array_remove_range_OPTIONAL_ARGC 0
/* g_ptr_array_remove_range
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - index_: unsigned int
 * - length: unsigned int
 * Return Type: GPtrArray *
 */
mrb_value
mrb_GLib_g_ptr_array_remove_range(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_index_;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &array, &native_index_, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  /* Invocation */
  GPtrArray * native_return_value = g_ptr_array_remove_range(native_array, native_index_, native_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GPtrArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_set_free_func_FUNCTION
#define g_ptr_array_set_free_func_REQUIRED_ARGC 2
#define g_ptr_array_set_free_func_OPTIONAL_ARGC 0
/* g_ptr_array_set_free_func
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - element_free_func: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_ptr_array_set_free_func(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value element_free_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &element_free_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(element_free_func);

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  void (*native_element_free_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(element_free_func);

  /* Invocation */
  g_ptr_array_set_free_func(native_array, native_element_free_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_ptr_array_set_size_FUNCTION
#define g_ptr_array_set_size_REQUIRED_ARGC 2
#define g_ptr_array_set_size_OPTIONAL_ARGC 0
/* g_ptr_array_set_size
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - length: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_ptr_array_set_size(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &array, &native_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  /* Invocation */
  g_ptr_array_set_size(native_array, native_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_ptr_array_sized_new_FUNCTION
#define g_ptr_array_sized_new_REQUIRED_ARGC 1
#define g_ptr_array_sized_new_OPTIONAL_ARGC 0
/* g_ptr_array_sized_new
 *
 * Parameters:
 * - reserved_size: unsigned int
 * Return Type: GPtrArray *
 */
mrb_value
mrb_GLib_g_ptr_array_sized_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_reserved_size;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_reserved_size);

  /* Invocation */
  GPtrArray * native_return_value = g_ptr_array_sized_new(native_reserved_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GPtrArray(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_ptr_array_sort_FUNCTION
#define g_ptr_array_sort_REQUIRED_ARGC 2
#define g_ptr_array_sort_OPTIONAL_ARGC 0
/* g_ptr_array_sort
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - compare_func: int (*)(const void *, const void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_ptr_array_sort(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value compare_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &array, &compare_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(compare_func);

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  int (*native_compare_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(compare_func);

  /* Invocation */
  g_ptr_array_sort(native_array, native_compare_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_ptr_array_sort_with_data_FUNCTION
#define g_ptr_array_sort_with_data_REQUIRED_ARGC 3
#define g_ptr_array_sort_with_data_OPTIONAL_ARGC 0
/* g_ptr_array_sort_with_data
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * - compare_func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_ptr_array_sort_with_data(mrb_state* mrb, mrb_value self) {
  mrb_value array;
  mrb_value compare_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &array, &compare_func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  int (*native_compare_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_ptr_array_sort_with_data(native_array, native_compare_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_ptr_array_unref_FUNCTION
#define g_ptr_array_unref_REQUIRED_ARGC 1
#define g_ptr_array_unref_OPTIONAL_ARGC 0
/* g_ptr_array_unref
 *
 * Parameters:
 * - array: struct _GPtrArray *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_ptr_array_unref(mrb_state* mrb, mrb_value self) {
  mrb_value array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &array);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, array, GPtrArray_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPtrArray expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GPtrArray * native_array = (mrb_nil_p(array) ? NULL : mruby_unbox__GPtrArray(array));

  /* Invocation */
  g_ptr_array_unref(native_array);

  return mrb_nil_value();
}
#endif

#if BIND_g_qsort_with_data_FUNCTION
#define g_qsort_with_data_REQUIRED_ARGC 5
#define g_qsort_with_data_OPTIONAL_ARGC 0
/* g_qsort_with_data
 *
 * Parameters:
 * - pbase: const void *
 * - total_elems: int
 * - size: unsigned long
 * - compare_func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_qsort_with_data(mrb_state* mrb, mrb_value self) {
  mrb_value pbase;
  mrb_int native_total_elems;
  mrb_int native_size;
  mrb_value compare_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oiioo", &pbase, &native_total_elems, &native_size, &compare_func, &user_data);

  /* Type checking */
  TODO_type_check_void_PTR(pbase);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  const void * native_pbase = TODO_mruby_unbox_void_PTR(pbase);

  int (*native_compare_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_qsort_with_data(native_pbase, native_total_elems, native_size, native_compare_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_quark_from_static_string_FUNCTION
#define g_quark_from_static_string_REQUIRED_ARGC 1
#define g_quark_from_static_string_OPTIONAL_ARGC 0
/* g_quark_from_static_string
 *
 * Parameters:
 * - string: const char *
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_quark_from_static_string(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_string);

  /* Invocation */
  GQuark native_return_value = g_quark_from_static_string(native_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_quark_from_string_FUNCTION
#define g_quark_from_string_REQUIRED_ARGC 1
#define g_quark_from_string_OPTIONAL_ARGC 0
/* g_quark_from_string
 *
 * Parameters:
 * - string: const char *
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_quark_from_string(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_string);

  /* Invocation */
  GQuark native_return_value = g_quark_from_string(native_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_quark_to_string_FUNCTION
#define g_quark_to_string_REQUIRED_ARGC 1
#define g_quark_to_string_OPTIONAL_ARGC 0
/* g_quark_to_string
 *
 * Parameters:
 * - quark: unsigned int
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_quark_to_string(mrb_state* mrb, mrb_value self) {
  mrb_int native_quark;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_quark);

  /* Invocation */
  const gchar * native_return_value = g_quark_to_string(native_quark);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_quark_try_string_FUNCTION
#define g_quark_try_string_REQUIRED_ARGC 1
#define g_quark_try_string_OPTIONAL_ARGC 0
/* g_quark_try_string
 *
 * Parameters:
 * - string: const char *
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_quark_try_string(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_string);

  /* Invocation */
  GQuark native_return_value = g_quark_try_string(native_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_clear_FUNCTION
#define g_queue_clear_REQUIRED_ARGC 1
#define g_queue_clear_OPTIONAL_ARGC 0
/* g_queue_clear
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_clear(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  g_queue_clear(native_queue);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_copy_FUNCTION
#define g_queue_copy_REQUIRED_ARGC 1
#define g_queue_copy_OPTIONAL_ARGC 0
/* g_queue_copy
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: GQueue *
 */
mrb_value
mrb_GLib_g_queue_copy(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  GQueue * native_return_value = g_queue_copy(native_queue);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GQueue(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_queue_delete_link_FUNCTION
#define g_queue_delete_link_REQUIRED_ARGC 2
#define g_queue_delete_link_OPTIONAL_ARGC 0
/* g_queue_delete_link
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - link_: struct _GList *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_delete_link(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value link_;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &link_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, link_, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  struct _GList * native_link_ = (mrb_nil_p(link_) ? NULL : mruby_unbox__GList(link_));

  /* Invocation */
  g_queue_delete_link(native_queue, native_link_);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_find_FUNCTION
#define g_queue_find_REQUIRED_ARGC 2
#define g_queue_find_OPTIONAL_ARGC 0
/* g_queue_find
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - data: const void *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_queue_find(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GList * native_return_value = g_queue_find(native_queue, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_queue_find_custom_FUNCTION
#define g_queue_find_custom_REQUIRED_ARGC 3
#define g_queue_find_custom_OPTIONAL_ARGC 0
/* g_queue_find_custom
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - data: const void *
 * - func: int (*)(const void *, const void *)
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_queue_find_custom(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &queue, &data, &func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(func);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(func);

  /* Invocation */
  GList * native_return_value = g_queue_find_custom(native_queue, native_data, native_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_queue_foreach_FUNCTION
#define g_queue_foreach_REQUIRED_ARGC 3
#define g_queue_foreach_OPTIONAL_ARGC 0
/* g_queue_foreach
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - func: void (*)(void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &queue, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  void (*native_func)(void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_queue_foreach(native_queue, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_free_FUNCTION
#define g_queue_free_REQUIRED_ARGC 1
#define g_queue_free_OPTIONAL_ARGC 0
/* g_queue_free
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_free(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  g_queue_free(native_queue);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_free_full_FUNCTION
#define g_queue_free_full_REQUIRED_ARGC 2
#define g_queue_free_full_OPTIONAL_ARGC 0
/* g_queue_free_full
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - free_func: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_free_full(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value free_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &free_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(free_func);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  void (*native_free_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(free_func);

  /* Invocation */
  g_queue_free_full(native_queue, native_free_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_get_length_FUNCTION
#define g_queue_get_length_REQUIRED_ARGC 1
#define g_queue_get_length_OPTIONAL_ARGC 0
/* g_queue_get_length
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_queue_get_length(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  guint native_return_value = g_queue_get_length(native_queue);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_index_FUNCTION
#define g_queue_index_REQUIRED_ARGC 2
#define g_queue_index_OPTIONAL_ARGC 0
/* g_queue_index
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - data: const void *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_queue_index(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  gint native_return_value = g_queue_index(native_queue, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_init_FUNCTION
#define g_queue_init_REQUIRED_ARGC 1
#define g_queue_init_OPTIONAL_ARGC 0
/* g_queue_init
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_init(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  g_queue_init(native_queue);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_insert_after_FUNCTION
#define g_queue_insert_after_REQUIRED_ARGC 3
#define g_queue_insert_after_OPTIONAL_ARGC 0
/* g_queue_insert_after
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - sibling: struct _GList *
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_insert_after(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value sibling;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &queue, &sibling, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sibling, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  struct _GList * native_sibling = (mrb_nil_p(sibling) ? NULL : mruby_unbox__GList(sibling));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_queue_insert_after(native_queue, native_sibling, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_insert_before_FUNCTION
#define g_queue_insert_before_REQUIRED_ARGC 3
#define g_queue_insert_before_OPTIONAL_ARGC 0
/* g_queue_insert_before
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - sibling: struct _GList *
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_insert_before(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value sibling;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &queue, &sibling, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sibling, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  struct _GList * native_sibling = (mrb_nil_p(sibling) ? NULL : mruby_unbox__GList(sibling));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_queue_insert_before(native_queue, native_sibling, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_insert_sorted_FUNCTION
#define g_queue_insert_sorted_REQUIRED_ARGC 4
#define g_queue_insert_sorted_OPTIONAL_ARGC 0
/* g_queue_insert_sorted
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - data: void *
 * - func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_insert_sorted(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &queue, &data, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_queue_insert_sorted(native_queue, native_data, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_is_empty_FUNCTION
#define g_queue_is_empty_REQUIRED_ARGC 1
#define g_queue_is_empty_OPTIONAL_ARGC 0
/* g_queue_is_empty
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_queue_is_empty(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  gboolean native_return_value = g_queue_is_empty(native_queue);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_link_index_FUNCTION
#define g_queue_link_index_REQUIRED_ARGC 2
#define g_queue_link_index_OPTIONAL_ARGC 0
/* g_queue_link_index
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - link_: struct _GList *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_queue_link_index(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value link_;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &link_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, link_, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  struct _GList * native_link_ = (mrb_nil_p(link_) ? NULL : mruby_unbox__GList(link_));

  /* Invocation */
  gint native_return_value = g_queue_link_index(native_queue, native_link_);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_new_FUNCTION
#define g_queue_new_REQUIRED_ARGC 0
#define g_queue_new_OPTIONAL_ARGC 0
/* g_queue_new
 *
 * Parameters: None
 * Return Type: GQueue *
 */
mrb_value
mrb_GLib_g_queue_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQueue * native_return_value = g_queue_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GQueue(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_queue_peek_head_FUNCTION
#define g_queue_peek_head_REQUIRED_ARGC 1
#define g_queue_peek_head_OPTIONAL_ARGC 0
/* g_queue_peek_head
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_queue_peek_head(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_queue_peek_head(native_queue);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_peek_head_link_FUNCTION
#define g_queue_peek_head_link_REQUIRED_ARGC 1
#define g_queue_peek_head_link_OPTIONAL_ARGC 0
/* g_queue_peek_head_link
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_queue_peek_head_link(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  GList * native_return_value = g_queue_peek_head_link(native_queue);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_queue_peek_nth_FUNCTION
#define g_queue_peek_nth_REQUIRED_ARGC 2
#define g_queue_peek_nth_OPTIONAL_ARGC 0
/* g_queue_peek_nth
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - n: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_queue_peek_nth(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &queue, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_queue_peek_nth(native_queue, native_n);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_peek_nth_link_FUNCTION
#define g_queue_peek_nth_link_REQUIRED_ARGC 2
#define g_queue_peek_nth_link_OPTIONAL_ARGC 0
/* g_queue_peek_nth_link
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - n: unsigned int
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_queue_peek_nth_link(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &queue, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  GList * native_return_value = g_queue_peek_nth_link(native_queue, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_queue_peek_tail_FUNCTION
#define g_queue_peek_tail_REQUIRED_ARGC 1
#define g_queue_peek_tail_OPTIONAL_ARGC 0
/* g_queue_peek_tail
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_queue_peek_tail(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_queue_peek_tail(native_queue);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_peek_tail_link_FUNCTION
#define g_queue_peek_tail_link_REQUIRED_ARGC 1
#define g_queue_peek_tail_link_OPTIONAL_ARGC 0
/* g_queue_peek_tail_link
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_queue_peek_tail_link(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  GList * native_return_value = g_queue_peek_tail_link(native_queue);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_queue_pop_head_FUNCTION
#define g_queue_pop_head_REQUIRED_ARGC 1
#define g_queue_pop_head_OPTIONAL_ARGC 0
/* g_queue_pop_head
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_queue_pop_head(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_queue_pop_head(native_queue);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_pop_head_link_FUNCTION
#define g_queue_pop_head_link_REQUIRED_ARGC 1
#define g_queue_pop_head_link_OPTIONAL_ARGC 0
/* g_queue_pop_head_link
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_queue_pop_head_link(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  GList * native_return_value = g_queue_pop_head_link(native_queue);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_queue_pop_nth_FUNCTION
#define g_queue_pop_nth_REQUIRED_ARGC 2
#define g_queue_pop_nth_OPTIONAL_ARGC 0
/* g_queue_pop_nth
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - n: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_queue_pop_nth(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &queue, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_queue_pop_nth(native_queue, native_n);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_pop_nth_link_FUNCTION
#define g_queue_pop_nth_link_REQUIRED_ARGC 2
#define g_queue_pop_nth_link_OPTIONAL_ARGC 0
/* g_queue_pop_nth_link
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - n: unsigned int
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_queue_pop_nth_link(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &queue, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  GList * native_return_value = g_queue_pop_nth_link(native_queue, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_queue_pop_tail_FUNCTION
#define g_queue_pop_tail_REQUIRED_ARGC 1
#define g_queue_pop_tail_OPTIONAL_ARGC 0
/* g_queue_pop_tail
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_queue_pop_tail(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  gpointer native_return_value = g_queue_pop_tail(native_queue);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_pop_tail_link_FUNCTION
#define g_queue_pop_tail_link_REQUIRED_ARGC 1
#define g_queue_pop_tail_link_OPTIONAL_ARGC 0
/* g_queue_pop_tail_link
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: GList *
 */
mrb_value
mrb_GLib_g_queue_pop_tail_link(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  GList * native_return_value = g_queue_pop_tail_link(native_queue);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_queue_push_head_FUNCTION
#define g_queue_push_head_REQUIRED_ARGC 2
#define g_queue_push_head_OPTIONAL_ARGC 0
/* g_queue_push_head
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_push_head(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_queue_push_head(native_queue, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_push_head_link_FUNCTION
#define g_queue_push_head_link_REQUIRED_ARGC 2
#define g_queue_push_head_link_OPTIONAL_ARGC 0
/* g_queue_push_head_link
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - link_: struct _GList *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_push_head_link(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value link_;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &link_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, link_, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  struct _GList * native_link_ = (mrb_nil_p(link_) ? NULL : mruby_unbox__GList(link_));

  /* Invocation */
  g_queue_push_head_link(native_queue, native_link_);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_push_nth_FUNCTION
#define g_queue_push_nth_REQUIRED_ARGC 3
#define g_queue_push_nth_OPTIONAL_ARGC 0
/* g_queue_push_nth
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - data: void *
 * - n: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_push_nth(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &queue, &data, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_queue_push_nth(native_queue, native_data, native_n);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_push_nth_link_FUNCTION
#define g_queue_push_nth_link_REQUIRED_ARGC 3
#define g_queue_push_nth_link_OPTIONAL_ARGC 0
/* g_queue_push_nth_link
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - n: int
 * - link_: struct _GList *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_push_nth_link(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_int native_n;
  mrb_value link_;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &queue, &native_n, &link_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, link_, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  struct _GList * native_link_ = (mrb_nil_p(link_) ? NULL : mruby_unbox__GList(link_));

  /* Invocation */
  g_queue_push_nth_link(native_queue, native_n, native_link_);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_push_tail_FUNCTION
#define g_queue_push_tail_REQUIRED_ARGC 2
#define g_queue_push_tail_OPTIONAL_ARGC 0
/* g_queue_push_tail
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_push_tail(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_queue_push_tail(native_queue, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_push_tail_link_FUNCTION
#define g_queue_push_tail_link_REQUIRED_ARGC 2
#define g_queue_push_tail_link_OPTIONAL_ARGC 0
/* g_queue_push_tail_link
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - link_: struct _GList *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_push_tail_link(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value link_;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &link_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, link_, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  struct _GList * native_link_ = (mrb_nil_p(link_) ? NULL : mruby_unbox__GList(link_));

  /* Invocation */
  g_queue_push_tail_link(native_queue, native_link_);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_remove_FUNCTION
#define g_queue_remove_REQUIRED_ARGC 2
#define g_queue_remove_OPTIONAL_ARGC 0
/* g_queue_remove
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - data: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_queue_remove(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  gboolean native_return_value = g_queue_remove(native_queue, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_remove_all_FUNCTION
#define g_queue_remove_all_REQUIRED_ARGC 2
#define g_queue_remove_all_OPTIONAL_ARGC 0
/* g_queue_remove_all
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - data: const void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_queue_remove_all(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  guint native_return_value = g_queue_remove_all(native_queue, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_queue_reverse_FUNCTION
#define g_queue_reverse_REQUIRED_ARGC 1
#define g_queue_reverse_OPTIONAL_ARGC 0
/* g_queue_reverse
 *
 * Parameters:
 * - queue: struct _GQueue *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_reverse(mrb_state* mrb, mrb_value self) {
  mrb_value queue;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &queue);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  /* Invocation */
  g_queue_reverse(native_queue);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_sort_FUNCTION
#define g_queue_sort_REQUIRED_ARGC 3
#define g_queue_sort_OPTIONAL_ARGC 0
/* g_queue_sort
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - compare_func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_sort(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value compare_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &queue, &compare_func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  int (*native_compare_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_queue_sort(native_queue, native_compare_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_queue_unlink_FUNCTION
#define g_queue_unlink_REQUIRED_ARGC 2
#define g_queue_unlink_OPTIONAL_ARGC 0
/* g_queue_unlink
 *
 * Parameters:
 * - queue: struct _GQueue *
 * - link_: struct _GList *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_queue_unlink(mrb_state* mrb, mrb_value self) {
  mrb_value queue;
  mrb_value link_;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &queue, &link_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, queue, GQueue_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GQueue expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, link_, GList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GQueue * native_queue = (mrb_nil_p(queue) ? NULL : mruby_unbox__GQueue(queue));

  struct _GList * native_link_ = (mrb_nil_p(link_) ? NULL : mruby_unbox__GList(link_));

  /* Invocation */
  g_queue_unlink(native_queue, native_link_);

  return mrb_nil_value();
}
#endif

#if BIND_g_rand_copy_FUNCTION
#define g_rand_copy_REQUIRED_ARGC 1
#define g_rand_copy_OPTIONAL_ARGC 0
/* g_rand_copy
 *
 * Parameters:
 * - rand_: struct _GRand *
 * Return Type: GRand *
 */
mrb_value
mrb_GLib_g_rand_copy(mrb_state* mrb, mrb_value self) {
  mrb_value rand_;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rand_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rand_, GRand_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRand expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRand * native_rand_ = (mrb_nil_p(rand_) ? NULL : mruby_unbox__GRand(rand_));

  /* Invocation */
  GRand * native_return_value = g_rand_copy(native_rand_);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GRand(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_rand_double_FUNCTION
#define g_rand_double_REQUIRED_ARGC 1
#define g_rand_double_OPTIONAL_ARGC 0
/* g_rand_double
 *
 * Parameters:
 * - rand_: struct _GRand *
 * Return Type: gdouble
 */
mrb_value
mrb_GLib_g_rand_double(mrb_state* mrb, mrb_value self) {
  mrb_value rand_;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rand_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rand_, GRand_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRand expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRand * native_rand_ = (mrb_nil_p(rand_) ? NULL : mruby_unbox__GRand(rand_));

  /* Invocation */
  gdouble native_return_value = g_rand_double(native_rand_);

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_rand_double_range_FUNCTION
#define g_rand_double_range_REQUIRED_ARGC 3
#define g_rand_double_range_OPTIONAL_ARGC 0
/* g_rand_double_range
 *
 * Parameters:
 * - rand_: struct _GRand *
 * - begin: double
 * - end: double
 * Return Type: gdouble
 */
mrb_value
mrb_GLib_g_rand_double_range(mrb_state* mrb, mrb_value self) {
  mrb_value rand_;
  double native_begin;
  double native_end;

  /* Fetch the args */
  mrb_get_args(mrb, "off", &rand_, &native_begin, &native_end);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rand_, GRand_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRand expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRand * native_rand_ = (mrb_nil_p(rand_) ? NULL : mruby_unbox__GRand(rand_));

  /* Invocation */
  gdouble native_return_value = g_rand_double_range(native_rand_, native_begin, native_end);

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_rand_free_FUNCTION
#define g_rand_free_REQUIRED_ARGC 1
#define g_rand_free_OPTIONAL_ARGC 0
/* g_rand_free
 *
 * Parameters:
 * - rand_: struct _GRand *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rand_free(mrb_state* mrb, mrb_value self) {
  mrb_value rand_;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rand_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rand_, GRand_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRand expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRand * native_rand_ = (mrb_nil_p(rand_) ? NULL : mruby_unbox__GRand(rand_));

  /* Invocation */
  g_rand_free(native_rand_);

  return mrb_nil_value();
}
#endif

#if BIND_g_rand_int_FUNCTION
#define g_rand_int_REQUIRED_ARGC 1
#define g_rand_int_OPTIONAL_ARGC 0
/* g_rand_int
 *
 * Parameters:
 * - rand_: struct _GRand *
 * Return Type: guint32
 */
mrb_value
mrb_GLib_g_rand_int(mrb_state* mrb, mrb_value self) {
  mrb_value rand_;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rand_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rand_, GRand_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRand expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRand * native_rand_ = (mrb_nil_p(rand_) ? NULL : mruby_unbox__GRand(rand_));

  /* Invocation */
  guint32 native_return_value = g_rand_int(native_rand_);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_rand_int_range_FUNCTION
#define g_rand_int_range_REQUIRED_ARGC 3
#define g_rand_int_range_OPTIONAL_ARGC 0
/* g_rand_int_range
 *
 * Parameters:
 * - rand_: struct _GRand *
 * - begin: int
 * - end: int
 * Return Type: gint32
 */
mrb_value
mrb_GLib_g_rand_int_range(mrb_state* mrb, mrb_value self) {
  mrb_value rand_;
  mrb_int native_begin;
  mrb_int native_end;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &rand_, &native_begin, &native_end);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rand_, GRand_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRand expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRand * native_rand_ = (mrb_nil_p(rand_) ? NULL : mruby_unbox__GRand(rand_));

  /* Invocation */
  gint32 native_return_value = g_rand_int_range(native_rand_, native_begin, native_end);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_rand_new_FUNCTION
#define g_rand_new_REQUIRED_ARGC 0
#define g_rand_new_OPTIONAL_ARGC 0
/* g_rand_new
 *
 * Parameters: None
 * Return Type: GRand *
 */
mrb_value
mrb_GLib_g_rand_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GRand * native_return_value = g_rand_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GRand(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_rand_new_with_seed_FUNCTION
#define g_rand_new_with_seed_REQUIRED_ARGC 1
#define g_rand_new_with_seed_OPTIONAL_ARGC 0
/* g_rand_new_with_seed
 *
 * Parameters:
 * - seed: unsigned int
 * Return Type: GRand *
 */
mrb_value
mrb_GLib_g_rand_new_with_seed(mrb_state* mrb, mrb_value self) {
  mrb_int native_seed;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_seed);

  /* Invocation */
  GRand * native_return_value = g_rand_new_with_seed(native_seed);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GRand(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_rand_new_with_seed_array_FUNCTION
#define g_rand_new_with_seed_array_REQUIRED_ARGC 2
#define g_rand_new_with_seed_array_OPTIONAL_ARGC 0
/* g_rand_new_with_seed_array
 *
 * Parameters:
 * - seed: const unsigned int *
 * - seed_length: unsigned int
 * Return Type: GRand *
 */
mrb_value
mrb_GLib_g_rand_new_with_seed_array(mrb_state* mrb, mrb_value self) {
  mrb_value seed;
  mrb_int native_seed_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &seed, &native_seed_length);

  /* Type checking */
  TODO_type_check_unsigned_int_PTR(seed);

  /* Unbox parameters */
  const unsigned int * native_seed = TODO_mruby_unbox_unsigned_int_PTR(seed);

  /* Invocation */
  GRand * native_return_value = g_rand_new_with_seed_array(native_seed, native_seed_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GRand(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_rand_set_seed_FUNCTION
#define g_rand_set_seed_REQUIRED_ARGC 2
#define g_rand_set_seed_OPTIONAL_ARGC 0
/* g_rand_set_seed
 *
 * Parameters:
 * - rand_: struct _GRand *
 * - seed: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rand_set_seed(mrb_state* mrb, mrb_value self) {
  mrb_value rand_;
  mrb_int native_seed;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &rand_, &native_seed);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rand_, GRand_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRand expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRand * native_rand_ = (mrb_nil_p(rand_) ? NULL : mruby_unbox__GRand(rand_));

  /* Invocation */
  g_rand_set_seed(native_rand_, native_seed);

  return mrb_nil_value();
}
#endif

#if BIND_g_rand_set_seed_array_FUNCTION
#define g_rand_set_seed_array_REQUIRED_ARGC 3
#define g_rand_set_seed_array_OPTIONAL_ARGC 0
/* g_rand_set_seed_array
 *
 * Parameters:
 * - rand_: struct _GRand *
 * - seed: const unsigned int *
 * - seed_length: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rand_set_seed_array(mrb_state* mrb, mrb_value self) {
  mrb_value rand_;
  mrb_value seed;
  mrb_int native_seed_length;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &rand_, &seed, &native_seed_length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rand_, GRand_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRand expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_int_PTR(seed);

  /* Unbox parameters */
  struct _GRand * native_rand_ = (mrb_nil_p(rand_) ? NULL : mruby_unbox__GRand(rand_));

  const unsigned int * native_seed = TODO_mruby_unbox_unsigned_int_PTR(seed);

  /* Invocation */
  g_rand_set_seed_array(native_rand_, native_seed, native_seed_length);

  return mrb_nil_value();
}
#endif

#if BIND_g_random_double_FUNCTION
#define g_random_double_REQUIRED_ARGC 0
#define g_random_double_OPTIONAL_ARGC 0
/* g_random_double
 *
 * Parameters: None
 * Return Type: gdouble
 */
mrb_value
mrb_GLib_g_random_double(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gdouble native_return_value = g_random_double();

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_random_double_range_FUNCTION
#define g_random_double_range_REQUIRED_ARGC 2
#define g_random_double_range_OPTIONAL_ARGC 0
/* g_random_double_range
 *
 * Parameters:
 * - begin: double
 * - end: double
 * Return Type: gdouble
 */
mrb_value
mrb_GLib_g_random_double_range(mrb_state* mrb, mrb_value self) {
  double native_begin;
  double native_end;

  /* Fetch the args */
  mrb_get_args(mrb, "ff", &native_begin, &native_end);

  /* Invocation */
  gdouble native_return_value = g_random_double_range(native_begin, native_end);

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_random_int_FUNCTION
#define g_random_int_REQUIRED_ARGC 0
#define g_random_int_OPTIONAL_ARGC 0
/* g_random_int
 *
 * Parameters: None
 * Return Type: guint32
 */
mrb_value
mrb_GLib_g_random_int(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  guint32 native_return_value = g_random_int();

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_random_int_range_FUNCTION
#define g_random_int_range_REQUIRED_ARGC 2
#define g_random_int_range_OPTIONAL_ARGC 0
/* g_random_int_range
 *
 * Parameters:
 * - begin: int
 * - end: int
 * Return Type: gint32
 */
mrb_value
mrb_GLib_g_random_int_range(mrb_state* mrb, mrb_value self) {
  mrb_int native_begin;
  mrb_int native_end;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_begin, &native_end);

  /* Invocation */
  gint32 native_return_value = g_random_int_range(native_begin, native_end);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_random_set_seed_FUNCTION
#define g_random_set_seed_REQUIRED_ARGC 1
#define g_random_set_seed_OPTIONAL_ARGC 0
/* g_random_set_seed
 *
 * Parameters:
 * - seed: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_random_set_seed(mrb_state* mrb, mrb_value self) {
  mrb_int native_seed;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_seed);

  /* Invocation */
  g_random_set_seed(native_seed);

  return mrb_nil_value();
}
#endif

#if BIND_g_realloc_FUNCTION
#define g_realloc_REQUIRED_ARGC 2
#define g_realloc_OPTIONAL_ARGC 0
/* g_realloc
 *
 * Parameters:
 * - mem: void *
 * - n_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_realloc(mrb_state* mrb, mrb_value self) {
  mrb_value mem;
  mrb_int native_n_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &mem, &native_n_bytes);

  /* Type checking */
  TODO_type_check_void_PTR(mem);

  /* Unbox parameters */
  void * native_mem = TODO_mruby_unbox_void_PTR(mem);

  /* Invocation */
  gpointer native_return_value = g_realloc(native_mem, native_n_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_realloc_n_FUNCTION
#define g_realloc_n_REQUIRED_ARGC 3
#define g_realloc_n_OPTIONAL_ARGC 0
/* g_realloc_n
 *
 * Parameters:
 * - mem: void *
 * - n_blocks: unsigned long
 * - n_block_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_realloc_n(mrb_state* mrb, mrb_value self) {
  mrb_value mem;
  mrb_int native_n_blocks;
  mrb_int native_n_block_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &mem, &native_n_blocks, &native_n_block_bytes);

  /* Type checking */
  TODO_type_check_void_PTR(mem);

  /* Unbox parameters */
  void * native_mem = TODO_mruby_unbox_void_PTR(mem);

  /* Invocation */
  gpointer native_return_value = g_realloc_n(native_mem, native_n_blocks, native_n_block_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_rec_mutex_clear_FUNCTION
#define g_rec_mutex_clear_REQUIRED_ARGC 1
#define g_rec_mutex_clear_OPTIONAL_ARGC 0
/* g_rec_mutex_clear
 *
 * Parameters:
 * - rec_mutex: struct _GRecMutex *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rec_mutex_clear(mrb_state* mrb, mrb_value self) {
  mrb_value rec_mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rec_mutex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rec_mutex, GRecMutex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRecMutex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRecMutex * native_rec_mutex = (mrb_nil_p(rec_mutex) ? NULL : mruby_unbox__GRecMutex(rec_mutex));

  /* Invocation */
  g_rec_mutex_clear(native_rec_mutex);

  return mrb_nil_value();
}
#endif

#if BIND_g_rec_mutex_init_FUNCTION
#define g_rec_mutex_init_REQUIRED_ARGC 1
#define g_rec_mutex_init_OPTIONAL_ARGC 0
/* g_rec_mutex_init
 *
 * Parameters:
 * - rec_mutex: struct _GRecMutex *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rec_mutex_init(mrb_state* mrb, mrb_value self) {
  mrb_value rec_mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rec_mutex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rec_mutex, GRecMutex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRecMutex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRecMutex * native_rec_mutex = (mrb_nil_p(rec_mutex) ? NULL : mruby_unbox__GRecMutex(rec_mutex));

  /* Invocation */
  g_rec_mutex_init(native_rec_mutex);

  return mrb_nil_value();
}
#endif

#if BIND_g_rec_mutex_lock_FUNCTION
#define g_rec_mutex_lock_REQUIRED_ARGC 1
#define g_rec_mutex_lock_OPTIONAL_ARGC 0
/* g_rec_mutex_lock
 *
 * Parameters:
 * - rec_mutex: struct _GRecMutex *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rec_mutex_lock(mrb_state* mrb, mrb_value self) {
  mrb_value rec_mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rec_mutex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rec_mutex, GRecMutex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRecMutex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRecMutex * native_rec_mutex = (mrb_nil_p(rec_mutex) ? NULL : mruby_unbox__GRecMutex(rec_mutex));

  /* Invocation */
  g_rec_mutex_lock(native_rec_mutex);

  return mrb_nil_value();
}
#endif

#if BIND_g_rec_mutex_trylock_FUNCTION
#define g_rec_mutex_trylock_REQUIRED_ARGC 1
#define g_rec_mutex_trylock_OPTIONAL_ARGC 0
/* g_rec_mutex_trylock
 *
 * Parameters:
 * - rec_mutex: struct _GRecMutex *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_rec_mutex_trylock(mrb_state* mrb, mrb_value self) {
  mrb_value rec_mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rec_mutex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rec_mutex, GRecMutex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRecMutex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRecMutex * native_rec_mutex = (mrb_nil_p(rec_mutex) ? NULL : mruby_unbox__GRecMutex(rec_mutex));

  /* Invocation */
  gboolean native_return_value = g_rec_mutex_trylock(native_rec_mutex);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_rec_mutex_unlock_FUNCTION
#define g_rec_mutex_unlock_REQUIRED_ARGC 1
#define g_rec_mutex_unlock_OPTIONAL_ARGC 0
/* g_rec_mutex_unlock
 *
 * Parameters:
 * - rec_mutex: struct _GRecMutex *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rec_mutex_unlock(mrb_state* mrb, mrb_value self) {
  mrb_value rec_mutex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rec_mutex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rec_mutex, GRecMutex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRecMutex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRecMutex * native_rec_mutex = (mrb_nil_p(rec_mutex) ? NULL : mruby_unbox__GRecMutex(rec_mutex));

  /* Invocation */
  g_rec_mutex_unlock(native_rec_mutex);

  return mrb_nil_value();
}
#endif

#if BIND_g_regex_check_replacement_FUNCTION
#define g_regex_check_replacement_REQUIRED_ARGC 2
#define g_regex_check_replacement_OPTIONAL_ARGC 0
/* g_regex_check_replacement
 *
 * Parameters:
 * - replacement: const char *
 * - has_references: int *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_regex_check_replacement(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_replacement = NULL;
  mrb_value has_references;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_replacement, &has_references);

  /* Type checking */
  TODO_type_check_int_PTR(has_references);

  /* Unbox parameters */
  int * native_has_references = TODO_mruby_unbox_int_PTR(has_references);

  /* Invocation */
  gboolean native_return_value = g_regex_check_replacement(native_replacement, native_has_references, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_regex_error_quark_FUNCTION
#define g_regex_error_quark_REQUIRED_ARGC 0
#define g_regex_error_quark_OPTIONAL_ARGC 0
/* g_regex_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_regex_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_regex_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_escape_nul_FUNCTION
#define g_regex_escape_nul_REQUIRED_ARGC 2
#define g_regex_escape_nul_OPTIONAL_ARGC 0
/* g_regex_escape_nul
 *
 * Parameters:
 * - string: const char *
 * - length: int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_regex_escape_nul(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_string, &native_length);

  /* Invocation */
  gchar * native_return_value = g_regex_escape_nul(native_string, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_escape_string_FUNCTION
#define g_regex_escape_string_REQUIRED_ARGC 2
#define g_regex_escape_string_OPTIONAL_ARGC 0
/* g_regex_escape_string
 *
 * Parameters:
 * - string: const char *
 * - length: int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_regex_escape_string(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_string, &native_length);

  /* Invocation */
  gchar * native_return_value = g_regex_escape_string(native_string, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_get_capture_count_FUNCTION
#define g_regex_get_capture_count_REQUIRED_ARGC 1
#define g_regex_get_capture_count_OPTIONAL_ARGC 0
/* g_regex_get_capture_count
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_regex_get_capture_count(mrb_state* mrb, mrb_value self) {
  mrb_value regex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &regex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  gint native_return_value = g_regex_get_capture_count(native_regex);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_get_compile_flags_FUNCTION
#define g_regex_get_compile_flags_REQUIRED_ARGC 1
#define g_regex_get_compile_flags_OPTIONAL_ARGC 0
/* g_regex_get_compile_flags
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * Return Type: GRegexCompileFlags
 */
mrb_value
mrb_GLib_g_regex_get_compile_flags(mrb_state* mrb, mrb_value self) {
  mrb_value regex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &regex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  GRegexCompileFlags native_return_value = g_regex_get_compile_flags(native_regex);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_get_has_cr_or_lf_FUNCTION
#define g_regex_get_has_cr_or_lf_REQUIRED_ARGC 1
#define g_regex_get_has_cr_or_lf_OPTIONAL_ARGC 0
/* g_regex_get_has_cr_or_lf
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_regex_get_has_cr_or_lf(mrb_state* mrb, mrb_value self) {
  mrb_value regex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &regex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  gboolean native_return_value = g_regex_get_has_cr_or_lf(native_regex);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_get_match_flags_FUNCTION
#define g_regex_get_match_flags_REQUIRED_ARGC 1
#define g_regex_get_match_flags_OPTIONAL_ARGC 0
/* g_regex_get_match_flags
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * Return Type: GRegexMatchFlags
 */
mrb_value
mrb_GLib_g_regex_get_match_flags(mrb_state* mrb, mrb_value self) {
  mrb_value regex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &regex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  GRegexMatchFlags native_return_value = g_regex_get_match_flags(native_regex);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_get_max_backref_FUNCTION
#define g_regex_get_max_backref_REQUIRED_ARGC 1
#define g_regex_get_max_backref_OPTIONAL_ARGC 0
/* g_regex_get_max_backref
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_regex_get_max_backref(mrb_state* mrb, mrb_value self) {
  mrb_value regex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &regex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  gint native_return_value = g_regex_get_max_backref(native_regex);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_get_max_lookbehind_FUNCTION
#define g_regex_get_max_lookbehind_REQUIRED_ARGC 1
#define g_regex_get_max_lookbehind_OPTIONAL_ARGC 0
/* g_regex_get_max_lookbehind
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_regex_get_max_lookbehind(mrb_state* mrb, mrb_value self) {
  mrb_value regex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &regex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  gint native_return_value = g_regex_get_max_lookbehind(native_regex);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_get_pattern_FUNCTION
#define g_regex_get_pattern_REQUIRED_ARGC 1
#define g_regex_get_pattern_OPTIONAL_ARGC 0
/* g_regex_get_pattern
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_regex_get_pattern(mrb_state* mrb, mrb_value self) {
  mrb_value regex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &regex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  const gchar * native_return_value = g_regex_get_pattern(native_regex);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_get_string_number_FUNCTION
#define g_regex_get_string_number_REQUIRED_ARGC 2
#define g_regex_get_string_number_OPTIONAL_ARGC 0
/* g_regex_get_string_number
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * - name: const char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_regex_get_string_number(mrb_state* mrb, mrb_value self) {
  mrb_value regex;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &regex, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  gint native_return_value = g_regex_get_string_number(native_regex, native_name);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_match_FUNCTION
#define g_regex_match_REQUIRED_ARGC 4
#define g_regex_match_OPTIONAL_ARGC 0
/* g_regex_match
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * - string: const char *
 * - match_options: GRegexMatchFlags
 * - match_info: struct _GMatchInfo **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_regex_match(mrb_state* mrb, mrb_value self) {
  mrb_value regex;
  char * native_string = NULL;
  mrb_int native_match_options;
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!io", &regex, &native_string, &native_match_options, &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }
  TODO_type_check__GMatchInfo_PTR_PTR(match_info);

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  struct _GMatchInfo ** native_match_info = TODO_mruby_unbox__GMatchInfo_PTR_PTR(match_info);

  /* Invocation */
  gboolean native_return_value = g_regex_match(native_regex, native_string, native_match_options, native_match_info);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_match_all_FUNCTION
#define g_regex_match_all_REQUIRED_ARGC 4
#define g_regex_match_all_OPTIONAL_ARGC 0
/* g_regex_match_all
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * - string: const char *
 * - match_options: GRegexMatchFlags
 * - match_info: struct _GMatchInfo **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_regex_match_all(mrb_state* mrb, mrb_value self) {
  mrb_value regex;
  char * native_string = NULL;
  mrb_int native_match_options;
  mrb_value match_info;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!io", &regex, &native_string, &native_match_options, &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }
  TODO_type_check__GMatchInfo_PTR_PTR(match_info);

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  struct _GMatchInfo ** native_match_info = TODO_mruby_unbox__GMatchInfo_PTR_PTR(match_info);

  /* Invocation */
  gboolean native_return_value = g_regex_match_all(native_regex, native_string, native_match_options, native_match_info);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_match_all_full_FUNCTION
#define g_regex_match_all_full_REQUIRED_ARGC 6
#define g_regex_match_all_full_OPTIONAL_ARGC 0
/* g_regex_match_all_full
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * - string: const char *
 * - string_len: long
 * - start_position: int
 * - match_options: GRegexMatchFlags
 * - match_info: struct _GMatchInfo **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_regex_match_all_full(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value regex;
  char * native_string = NULL;
  mrb_int native_string_len;
  mrb_int native_start_position;
  mrb_int native_match_options;
  mrb_value match_info;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!iiio", &regex, &native_string, &native_string_len, &native_start_position, &native_match_options, &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }
  TODO_type_check__GMatchInfo_PTR_PTR(match_info);

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  struct _GMatchInfo ** native_match_info = TODO_mruby_unbox__GMatchInfo_PTR_PTR(match_info);

  /* Invocation */
  gboolean native_return_value = g_regex_match_all_full(native_regex, native_string, native_string_len, native_start_position, native_match_options, native_match_info, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_regex_match_full_FUNCTION
#define g_regex_match_full_REQUIRED_ARGC 6
#define g_regex_match_full_OPTIONAL_ARGC 0
/* g_regex_match_full
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * - string: const char *
 * - string_len: long
 * - start_position: int
 * - match_options: GRegexMatchFlags
 * - match_info: struct _GMatchInfo **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_regex_match_full(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value regex;
  char * native_string = NULL;
  mrb_int native_string_len;
  mrb_int native_start_position;
  mrb_int native_match_options;
  mrb_value match_info;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!iiio", &regex, &native_string, &native_string_len, &native_start_position, &native_match_options, &match_info);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }
  TODO_type_check__GMatchInfo_PTR_PTR(match_info);

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  struct _GMatchInfo ** native_match_info = TODO_mruby_unbox__GMatchInfo_PTR_PTR(match_info);

  /* Invocation */
  gboolean native_return_value = g_regex_match_full(native_regex, native_string, native_string_len, native_start_position, native_match_options, native_match_info, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_regex_match_simple_FUNCTION
#define g_regex_match_simple_REQUIRED_ARGC 4
#define g_regex_match_simple_OPTIONAL_ARGC 0
/* g_regex_match_simple
 *
 * Parameters:
 * - pattern: const char *
 * - string: const char *
 * - compile_options: GRegexCompileFlags
 * - match_options: GRegexMatchFlags
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_regex_match_simple(mrb_state* mrb, mrb_value self) {
  char * native_pattern = NULL;
  char * native_string = NULL;
  mrb_int native_compile_options;
  mrb_int native_match_options;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!ii", &native_pattern, &native_string, &native_compile_options, &native_match_options);

  /* Invocation */
  gboolean native_return_value = g_regex_match_simple(native_pattern, native_string, native_compile_options, native_match_options);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_new_FUNCTION
#define g_regex_new_REQUIRED_ARGC 3
#define g_regex_new_OPTIONAL_ARGC 0
/* g_regex_new
 *
 * Parameters:
 * - pattern: const char *
 * - compile_options: GRegexCompileFlags
 * - match_options: GRegexMatchFlags
 * Return Type: GRegex *
 */
mrb_value
mrb_GLib_g_regex_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_pattern = NULL;
  mrb_int native_compile_options;
  mrb_int native_match_options;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ii", &native_pattern, &native_compile_options, &native_match_options);

  /* Invocation */
  GRegex * native_return_value = g_regex_new(native_pattern, native_compile_options, native_match_options, &native_error);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GRegex(mrb, native_return_value));
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_regex_ref_FUNCTION
#define g_regex_ref_REQUIRED_ARGC 1
#define g_regex_ref_OPTIONAL_ARGC 0
/* g_regex_ref
 *
 * Parameters:
 * - regex: struct _GRegex *
 * Return Type: GRegex *
 */
mrb_value
mrb_GLib_g_regex_ref(mrb_state* mrb, mrb_value self) {
  mrb_value regex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &regex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  GRegex * native_return_value = g_regex_ref(native_regex);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GRegex(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_regex_replace_FUNCTION
#define g_regex_replace_REQUIRED_ARGC 6
#define g_regex_replace_OPTIONAL_ARGC 0
/* g_regex_replace
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * - string: const char *
 * - string_len: long
 * - start_position: int
 * - replacement: const char *
 * - match_options: GRegexMatchFlags
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_regex_replace(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value regex;
  char * native_string = NULL;
  mrb_int native_string_len;
  mrb_int native_start_position;
  char * native_replacement = NULL;
  mrb_int native_match_options;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!iiz!i", &regex, &native_string, &native_string_len, &native_start_position, &native_replacement, &native_match_options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  gchar * native_return_value = g_regex_replace(native_regex, native_string, native_string_len, native_start_position, native_replacement, native_match_options, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_regex_replace_eval_FUNCTION
#define g_regex_replace_eval_REQUIRED_ARGC 7
#define g_regex_replace_eval_OPTIONAL_ARGC 0
/* g_regex_replace_eval
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * - string: const char *
 * - string_len: long
 * - start_position: int
 * - match_options: GRegexMatchFlags
 * - eval: int (*)(const struct _GMatchInfo *, struct _GString *, void *)
 * - user_data: void *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_regex_replace_eval(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value regex;
  char * native_string = NULL;
  mrb_int native_string_len;
  mrb_int native_start_position;
  mrb_int native_match_options;
  mrb_value eval;
  mrb_value user_data;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!iiioo", &regex, &native_string, &native_string_len, &native_start_position, &native_match_options, &eval, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GMatchInfo_PTR_COMMA_struct__GString_PTR_COMMA_void_PTR_RPAREN(eval);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  int (*native_eval)(const struct _GMatchInfo *, struct _GString *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GMatchInfo_PTR_COMMA_struct__GString_PTR_COMMA_void_PTR_RPAREN(eval);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  gchar * native_return_value = g_regex_replace_eval(native_regex, native_string, native_string_len, native_start_position, native_match_options, native_eval, native_user_data, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_regex_replace_literal_FUNCTION
#define g_regex_replace_literal_REQUIRED_ARGC 6
#define g_regex_replace_literal_OPTIONAL_ARGC 0
/* g_regex_replace_literal
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * - string: const char *
 * - string_len: long
 * - start_position: int
 * - replacement: const char *
 * - match_options: GRegexMatchFlags
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_regex_replace_literal(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value regex;
  char * native_string = NULL;
  mrb_int native_string_len;
  mrb_int native_start_position;
  char * native_replacement = NULL;
  mrb_int native_match_options;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!iiz!i", &regex, &native_string, &native_string_len, &native_start_position, &native_replacement, &native_match_options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  gchar * native_return_value = g_regex_replace_literal(native_regex, native_string, native_string_len, native_start_position, native_replacement, native_match_options, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_regex_split_FUNCTION
#define g_regex_split_REQUIRED_ARGC 3
#define g_regex_split_OPTIONAL_ARGC 0
/* g_regex_split
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * - string: const char *
 * - match_options: GRegexMatchFlags
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_regex_split(mrb_state* mrb, mrb_value self) {
  mrb_value regex;
  char * native_string = NULL;
  mrb_int native_match_options;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &regex, &native_string, &native_match_options);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  gchar ** native_return_value = g_regex_split(native_regex, native_string, native_match_options);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_split_full_FUNCTION
#define g_regex_split_full_REQUIRED_ARGC 6
#define g_regex_split_full_OPTIONAL_ARGC 0
/* g_regex_split_full
 *
 * Parameters:
 * - regex: const struct _GRegex *
 * - string: const char *
 * - string_len: long
 * - start_position: int
 * - match_options: GRegexMatchFlags
 * - max_tokens: int
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_regex_split_full(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value regex;
  char * native_string = NULL;
  mrb_int native_string_len;
  mrb_int native_start_position;
  mrb_int native_match_options;
  mrb_int native_max_tokens;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!iiii", &regex, &native_string, &native_string_len, &native_start_position, &native_match_options, &native_max_tokens);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  gchar ** native_return_value = g_regex_split_full(native_regex, native_string, native_string_len, native_start_position, native_match_options, native_max_tokens, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_regex_split_simple_FUNCTION
#define g_regex_split_simple_REQUIRED_ARGC 4
#define g_regex_split_simple_OPTIONAL_ARGC 0
/* g_regex_split_simple
 *
 * Parameters:
 * - pattern: const char *
 * - string: const char *
 * - compile_options: GRegexCompileFlags
 * - match_options: GRegexMatchFlags
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_regex_split_simple(mrb_state* mrb, mrb_value self) {
  char * native_pattern = NULL;
  char * native_string = NULL;
  mrb_int native_compile_options;
  mrb_int native_match_options;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!ii", &native_pattern, &native_string, &native_compile_options, &native_match_options);

  /* Invocation */
  gchar ** native_return_value = g_regex_split_simple(native_pattern, native_string, native_compile_options, native_match_options);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_regex_unref_FUNCTION
#define g_regex_unref_REQUIRED_ARGC 1
#define g_regex_unref_OPTIONAL_ARGC 0
/* g_regex_unref
 *
 * Parameters:
 * - regex: struct _GRegex *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_regex_unref(mrb_state* mrb, mrb_value self) {
  mrb_value regex;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &regex);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, regex, GRegex_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRegex expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRegex * native_regex = (mrb_nil_p(regex) ? NULL : mruby_unbox__GRegex(regex));

  /* Invocation */
  g_regex_unref(native_regex);

  return mrb_nil_value();
}
#endif

#if BIND_g_reload_user_special_dirs_cache_FUNCTION
#define g_reload_user_special_dirs_cache_REQUIRED_ARGC 0
#define g_reload_user_special_dirs_cache_OPTIONAL_ARGC 0
/* g_reload_user_special_dirs_cache
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_GLib_g_reload_user_special_dirs_cache(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  g_reload_user_special_dirs_cache();

  return mrb_nil_value();
}
#endif

#if BIND_g_return_if_fail_warning_FUNCTION
#define g_return_if_fail_warning_REQUIRED_ARGC 3
#define g_return_if_fail_warning_OPTIONAL_ARGC 0
/* g_return_if_fail_warning
 *
 * Parameters:
 * - log_domain: const char *
 * - pretty_function: const char *
 * - expression: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_return_if_fail_warning(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  char * native_pretty_function = NULL;
  char * native_expression = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!z!", &native_log_domain, &native_pretty_function, &native_expression);

  /* Invocation */
  g_return_if_fail_warning(native_log_domain, native_pretty_function, native_expression);

  return mrb_nil_value();
}
#endif

#if BIND_g_rmdir_FUNCTION
#define g_rmdir_REQUIRED_ARGC 1
#define g_rmdir_OPTIONAL_ARGC 0
/* g_rmdir
 *
 * Parameters:
 * - filename: const char *
 * Return Type: int
 */
mrb_value
mrb_GLib_g_rmdir(mrb_state* mrb, mrb_value self) {
  char * native_filename = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_filename);

  /* Invocation */
  int native_return_value = g_rmdir(native_filename);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_rw_lock_clear_FUNCTION
#define g_rw_lock_clear_REQUIRED_ARGC 1
#define g_rw_lock_clear_OPTIONAL_ARGC 0
/* g_rw_lock_clear
 *
 * Parameters:
 * - rw_lock: struct _GRWLock *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rw_lock_clear(mrb_state* mrb, mrb_value self) {
  mrb_value rw_lock;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rw_lock);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rw_lock, GRWLock_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRWLock expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRWLock * native_rw_lock = (mrb_nil_p(rw_lock) ? NULL : mruby_unbox__GRWLock(rw_lock));

  /* Invocation */
  g_rw_lock_clear(native_rw_lock);

  return mrb_nil_value();
}
#endif

#if BIND_g_rw_lock_init_FUNCTION
#define g_rw_lock_init_REQUIRED_ARGC 1
#define g_rw_lock_init_OPTIONAL_ARGC 0
/* g_rw_lock_init
 *
 * Parameters:
 * - rw_lock: struct _GRWLock *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rw_lock_init(mrb_state* mrb, mrb_value self) {
  mrb_value rw_lock;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rw_lock);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rw_lock, GRWLock_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRWLock expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRWLock * native_rw_lock = (mrb_nil_p(rw_lock) ? NULL : mruby_unbox__GRWLock(rw_lock));

  /* Invocation */
  g_rw_lock_init(native_rw_lock);

  return mrb_nil_value();
}
#endif

#if BIND_g_rw_lock_reader_lock_FUNCTION
#define g_rw_lock_reader_lock_REQUIRED_ARGC 1
#define g_rw_lock_reader_lock_OPTIONAL_ARGC 0
/* g_rw_lock_reader_lock
 *
 * Parameters:
 * - rw_lock: struct _GRWLock *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rw_lock_reader_lock(mrb_state* mrb, mrb_value self) {
  mrb_value rw_lock;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rw_lock);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rw_lock, GRWLock_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRWLock expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRWLock * native_rw_lock = (mrb_nil_p(rw_lock) ? NULL : mruby_unbox__GRWLock(rw_lock));

  /* Invocation */
  g_rw_lock_reader_lock(native_rw_lock);

  return mrb_nil_value();
}
#endif

#if BIND_g_rw_lock_reader_trylock_FUNCTION
#define g_rw_lock_reader_trylock_REQUIRED_ARGC 1
#define g_rw_lock_reader_trylock_OPTIONAL_ARGC 0
/* g_rw_lock_reader_trylock
 *
 * Parameters:
 * - rw_lock: struct _GRWLock *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_rw_lock_reader_trylock(mrb_state* mrb, mrb_value self) {
  mrb_value rw_lock;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rw_lock);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rw_lock, GRWLock_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRWLock expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRWLock * native_rw_lock = (mrb_nil_p(rw_lock) ? NULL : mruby_unbox__GRWLock(rw_lock));

  /* Invocation */
  gboolean native_return_value = g_rw_lock_reader_trylock(native_rw_lock);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_rw_lock_reader_unlock_FUNCTION
#define g_rw_lock_reader_unlock_REQUIRED_ARGC 1
#define g_rw_lock_reader_unlock_OPTIONAL_ARGC 0
/* g_rw_lock_reader_unlock
 *
 * Parameters:
 * - rw_lock: struct _GRWLock *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rw_lock_reader_unlock(mrb_state* mrb, mrb_value self) {
  mrb_value rw_lock;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rw_lock);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rw_lock, GRWLock_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRWLock expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRWLock * native_rw_lock = (mrb_nil_p(rw_lock) ? NULL : mruby_unbox__GRWLock(rw_lock));

  /* Invocation */
  g_rw_lock_reader_unlock(native_rw_lock);

  return mrb_nil_value();
}
#endif

#if BIND_g_rw_lock_writer_lock_FUNCTION
#define g_rw_lock_writer_lock_REQUIRED_ARGC 1
#define g_rw_lock_writer_lock_OPTIONAL_ARGC 0
/* g_rw_lock_writer_lock
 *
 * Parameters:
 * - rw_lock: struct _GRWLock *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rw_lock_writer_lock(mrb_state* mrb, mrb_value self) {
  mrb_value rw_lock;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rw_lock);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rw_lock, GRWLock_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRWLock expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRWLock * native_rw_lock = (mrb_nil_p(rw_lock) ? NULL : mruby_unbox__GRWLock(rw_lock));

  /* Invocation */
  g_rw_lock_writer_lock(native_rw_lock);

  return mrb_nil_value();
}
#endif

#if BIND_g_rw_lock_writer_trylock_FUNCTION
#define g_rw_lock_writer_trylock_REQUIRED_ARGC 1
#define g_rw_lock_writer_trylock_OPTIONAL_ARGC 0
/* g_rw_lock_writer_trylock
 *
 * Parameters:
 * - rw_lock: struct _GRWLock *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_rw_lock_writer_trylock(mrb_state* mrb, mrb_value self) {
  mrb_value rw_lock;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rw_lock);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rw_lock, GRWLock_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRWLock expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRWLock * native_rw_lock = (mrb_nil_p(rw_lock) ? NULL : mruby_unbox__GRWLock(rw_lock));

  /* Invocation */
  gboolean native_return_value = g_rw_lock_writer_trylock(native_rw_lock);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_rw_lock_writer_unlock_FUNCTION
#define g_rw_lock_writer_unlock_REQUIRED_ARGC 1
#define g_rw_lock_writer_unlock_OPTIONAL_ARGC 0
/* g_rw_lock_writer_unlock
 *
 * Parameters:
 * - rw_lock: struct _GRWLock *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_rw_lock_writer_unlock(mrb_state* mrb, mrb_value self) {
  mrb_value rw_lock;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &rw_lock);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, rw_lock, GRWLock_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GRWLock expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GRWLock * native_rw_lock = (mrb_nil_p(rw_lock) ? NULL : mruby_unbox__GRWLock(rw_lock));

  /* Invocation */
  g_rw_lock_writer_unlock(native_rw_lock);

  return mrb_nil_value();
}
#endif

#if BIND_g_scanner_cur_line_FUNCTION
#define g_scanner_cur_line_REQUIRED_ARGC 1
#define g_scanner_cur_line_OPTIONAL_ARGC 0
/* g_scanner_cur_line
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_scanner_cur_line(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &scanner);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  guint native_return_value = g_scanner_cur_line(native_scanner);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_scanner_cur_position_FUNCTION
#define g_scanner_cur_position_REQUIRED_ARGC 1
#define g_scanner_cur_position_OPTIONAL_ARGC 0
/* g_scanner_cur_position
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_scanner_cur_position(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &scanner);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  guint native_return_value = g_scanner_cur_position(native_scanner);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_scanner_cur_token_FUNCTION
#define g_scanner_cur_token_REQUIRED_ARGC 1
#define g_scanner_cur_token_OPTIONAL_ARGC 0
/* g_scanner_cur_token
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * Return Type: GTokenType
 */
mrb_value
mrb_GLib_g_scanner_cur_token(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &scanner);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  GTokenType native_return_value = g_scanner_cur_token(native_scanner);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_scanner_cur_value_FUNCTION
#define g_scanner_cur_value_REQUIRED_ARGC 1
#define g_scanner_cur_value_OPTIONAL_ARGC 0
/* g_scanner_cur_value
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * Return Type: GTokenValue
 */
mrb_value
mrb_GLib_g_scanner_cur_value(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &scanner);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  GTokenValue native_return_value = g_scanner_cur_value(native_scanner);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GTokenValue(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_scanner_destroy_FUNCTION
#define g_scanner_destroy_REQUIRED_ARGC 1
#define g_scanner_destroy_OPTIONAL_ARGC 0
/* g_scanner_destroy
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_scanner_destroy(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &scanner);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  g_scanner_destroy(native_scanner);

  return mrb_nil_value();
}
#endif

#if BIND_g_scanner_eof_FUNCTION
#define g_scanner_eof_REQUIRED_ARGC 1
#define g_scanner_eof_OPTIONAL_ARGC 0
/* g_scanner_eof
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_scanner_eof(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &scanner);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  gboolean native_return_value = g_scanner_eof(native_scanner);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_scanner_error_FUNCTION
#define g_scanner_error_REQUIRED_ARGC 2
#define g_scanner_error_OPTIONAL_ARGC 0
/* g_scanner_error
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_scanner_error(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &scanner, &native_format);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  g_scanner_error(native_scanner, native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_scanner_get_next_token_FUNCTION
#define g_scanner_get_next_token_REQUIRED_ARGC 1
#define g_scanner_get_next_token_OPTIONAL_ARGC 0
/* g_scanner_get_next_token
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * Return Type: GTokenType
 */
mrb_value
mrb_GLib_g_scanner_get_next_token(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &scanner);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  GTokenType native_return_value = g_scanner_get_next_token(native_scanner);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_scanner_input_file_FUNCTION
#define g_scanner_input_file_REQUIRED_ARGC 2
#define g_scanner_input_file_OPTIONAL_ARGC 0
/* g_scanner_input_file
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - input_fd: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_scanner_input_file(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  mrb_int native_input_fd;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &scanner, &native_input_fd);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  g_scanner_input_file(native_scanner, native_input_fd);

  return mrb_nil_value();
}
#endif

#if BIND_g_scanner_input_text_FUNCTION
#define g_scanner_input_text_REQUIRED_ARGC 3
#define g_scanner_input_text_OPTIONAL_ARGC 0
/* g_scanner_input_text
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - text: const char *
 * - text_len: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_scanner_input_text(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  char * native_text = NULL;
  mrb_int native_text_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &scanner, &native_text, &native_text_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  g_scanner_input_text(native_scanner, native_text, native_text_len);

  return mrb_nil_value();
}
#endif

#if BIND_g_scanner_lookup_symbol_FUNCTION
#define g_scanner_lookup_symbol_REQUIRED_ARGC 2
#define g_scanner_lookup_symbol_OPTIONAL_ARGC 0
/* g_scanner_lookup_symbol
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - symbol: const char *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_scanner_lookup_symbol(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  char * native_symbol = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &scanner, &native_symbol);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  gpointer native_return_value = g_scanner_lookup_symbol(native_scanner, native_symbol);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_scanner_new_FUNCTION
#define g_scanner_new_REQUIRED_ARGC 1
#define g_scanner_new_OPTIONAL_ARGC 0
/* g_scanner_new
 *
 * Parameters:
 * - config_templ: const struct _GScannerConfig *
 * Return Type: GScanner *
 */
mrb_value
mrb_GLib_g_scanner_new(mrb_state* mrb, mrb_value self) {
  mrb_value config_templ;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &config_templ);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, config_templ, GScannerConfig_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScannerConfig expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GScannerConfig * native_config_templ = (mrb_nil_p(config_templ) ? NULL : mruby_unbox__GScannerConfig(config_templ));

  /* Invocation */
  GScanner * native_return_value = g_scanner_new(native_config_templ);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GScanner(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_scanner_peek_next_token_FUNCTION
#define g_scanner_peek_next_token_REQUIRED_ARGC 1
#define g_scanner_peek_next_token_OPTIONAL_ARGC 0
/* g_scanner_peek_next_token
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * Return Type: GTokenType
 */
mrb_value
mrb_GLib_g_scanner_peek_next_token(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &scanner);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  GTokenType native_return_value = g_scanner_peek_next_token(native_scanner);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_scanner_scope_add_symbol_FUNCTION
#define g_scanner_scope_add_symbol_REQUIRED_ARGC 4
#define g_scanner_scope_add_symbol_OPTIONAL_ARGC 0
/* g_scanner_scope_add_symbol
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - scope_id: unsigned int
 * - symbol: const char *
 * - value: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_scanner_scope_add_symbol(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  mrb_int native_scope_id;
  char * native_symbol = NULL;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz!o", &scanner, &native_scope_id, &native_symbol, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(value);

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  void * native_value = TODO_mruby_unbox_void_PTR(value);

  /* Invocation */
  g_scanner_scope_add_symbol(native_scanner, native_scope_id, native_symbol, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_scanner_scope_foreach_symbol_FUNCTION
#define g_scanner_scope_foreach_symbol_REQUIRED_ARGC 4
#define g_scanner_scope_foreach_symbol_OPTIONAL_ARGC 0
/* g_scanner_scope_foreach_symbol
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - scope_id: unsigned int
 * - func: void (*)(void *, void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_scanner_scope_foreach_symbol(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  mrb_int native_scope_id;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &scanner, &native_scope_id, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  void (*native_func)(void *, void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_scanner_scope_foreach_symbol(native_scanner, native_scope_id, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_scanner_scope_lookup_symbol_FUNCTION
#define g_scanner_scope_lookup_symbol_REQUIRED_ARGC 3
#define g_scanner_scope_lookup_symbol_OPTIONAL_ARGC 0
/* g_scanner_scope_lookup_symbol
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - scope_id: unsigned int
 * - symbol: const char *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_scanner_scope_lookup_symbol(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  mrb_int native_scope_id;
  char * native_symbol = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz!", &scanner, &native_scope_id, &native_symbol);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  gpointer native_return_value = g_scanner_scope_lookup_symbol(native_scanner, native_scope_id, native_symbol);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_scanner_scope_remove_symbol_FUNCTION
#define g_scanner_scope_remove_symbol_REQUIRED_ARGC 3
#define g_scanner_scope_remove_symbol_OPTIONAL_ARGC 0
/* g_scanner_scope_remove_symbol
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - scope_id: unsigned int
 * - symbol: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_scanner_scope_remove_symbol(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  mrb_int native_scope_id;
  char * native_symbol = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz!", &scanner, &native_scope_id, &native_symbol);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  g_scanner_scope_remove_symbol(native_scanner, native_scope_id, native_symbol);

  return mrb_nil_value();
}
#endif

#if BIND_g_scanner_set_scope_FUNCTION
#define g_scanner_set_scope_REQUIRED_ARGC 2
#define g_scanner_set_scope_OPTIONAL_ARGC 0
/* g_scanner_set_scope
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - scope_id: unsigned int
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_scanner_set_scope(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  mrb_int native_scope_id;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &scanner, &native_scope_id);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  guint native_return_value = g_scanner_set_scope(native_scanner, native_scope_id);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_scanner_sync_file_offset_FUNCTION
#define g_scanner_sync_file_offset_REQUIRED_ARGC 1
#define g_scanner_sync_file_offset_OPTIONAL_ARGC 0
/* g_scanner_sync_file_offset
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_scanner_sync_file_offset(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &scanner);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  g_scanner_sync_file_offset(native_scanner);

  return mrb_nil_value();
}
#endif

#if BIND_g_scanner_unexp_token_FUNCTION
#define g_scanner_unexp_token_REQUIRED_ARGC 7
#define g_scanner_unexp_token_OPTIONAL_ARGC 0
/* g_scanner_unexp_token
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - expected_token: GTokenType
 * - identifier_spec: const char *
 * - symbol_spec: const char *
 * - symbol_name: const char *
 * - message: const char *
 * - is_error: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_scanner_unexp_token(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  mrb_int native_expected_token;
  char * native_identifier_spec = NULL;
  char * native_symbol_spec = NULL;
  char * native_symbol_name = NULL;
  char * native_message = NULL;
  mrb_int native_is_error;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz!z!z!z!i", &scanner, &native_expected_token, &native_identifier_spec, &native_symbol_spec, &native_symbol_name, &native_message, &native_is_error);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  g_scanner_unexp_token(native_scanner, native_expected_token, native_identifier_spec, native_symbol_spec, native_symbol_name, native_message, native_is_error);

  return mrb_nil_value();
}
#endif

#if BIND_g_scanner_warn_FUNCTION
#define g_scanner_warn_REQUIRED_ARGC 2
#define g_scanner_warn_OPTIONAL_ARGC 0
/* g_scanner_warn
 *
 * Parameters:
 * - scanner: struct _GScanner *
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_scanner_warn(mrb_state* mrb, mrb_value self) {
  mrb_value scanner;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &scanner, &native_format);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, scanner, GScanner_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GScanner expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GScanner * native_scanner = (mrb_nil_p(scanner) ? NULL : mruby_unbox__GScanner(scanner));

  /* Invocation */
  g_scanner_warn(native_scanner, native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_append_FUNCTION
#define g_sequence_append_REQUIRED_ARGC 2
#define g_sequence_append_OPTIONAL_ARGC 0
/* g_sequence_append
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - data: void *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_append(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &seq, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_append(native_seq, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_foreach_FUNCTION
#define g_sequence_foreach_REQUIRED_ARGC 3
#define g_sequence_foreach_OPTIONAL_ARGC 0
/* g_sequence_foreach
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - func: void (*)(void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &seq, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  void (*native_func)(void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_sequence_foreach(native_seq, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_foreach_range_FUNCTION
#define g_sequence_foreach_range_REQUIRED_ARGC 4
#define g_sequence_foreach_range_OPTIONAL_ARGC 0
/* g_sequence_foreach_range
 *
 * Parameters:
 * - begin: struct _GSequenceNode *
 * - end: struct _GSequenceNode *
 * - func: void (*)(void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_foreach_range(mrb_state* mrb, mrb_value self) {
  mrb_value begin;
  mrb_value end;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &begin, &end, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, begin, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, end, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GSequenceNode * native_begin = (mrb_nil_p(begin) ? NULL : mruby_unbox__GSequenceNode(begin));

  struct _GSequenceNode * native_end = (mrb_nil_p(end) ? NULL : mruby_unbox__GSequenceNode(end));

  void (*native_func)(void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_sequence_foreach_range(native_begin, native_end, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_free_FUNCTION
#define g_sequence_free_REQUIRED_ARGC 1
#define g_sequence_free_OPTIONAL_ARGC 0
/* g_sequence_free
 *
 * Parameters:
 * - seq: struct _GSequence *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_free(mrb_state* mrb, mrb_value self) {
  mrb_value seq;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &seq);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  /* Invocation */
  g_sequence_free(native_seq);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_get_FUNCTION
#define g_sequence_get_REQUIRED_ARGC 1
#define g_sequence_get_OPTIONAL_ARGC 0
/* g_sequence_get
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_sequence_get(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  /* Invocation */
  gpointer native_return_value = g_sequence_get(native_iter);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_sequence_get_begin_iter_FUNCTION
#define g_sequence_get_begin_iter_REQUIRED_ARGC 1
#define g_sequence_get_begin_iter_OPTIONAL_ARGC 0
/* g_sequence_get_begin_iter
 *
 * Parameters:
 * - seq: struct _GSequence *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_get_begin_iter(mrb_state* mrb, mrb_value self) {
  mrb_value seq;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &seq);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_get_begin_iter(native_seq);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_get_end_iter_FUNCTION
#define g_sequence_get_end_iter_REQUIRED_ARGC 1
#define g_sequence_get_end_iter_OPTIONAL_ARGC 0
/* g_sequence_get_end_iter
 *
 * Parameters:
 * - seq: struct _GSequence *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_get_end_iter(mrb_state* mrb, mrb_value self) {
  mrb_value seq;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &seq);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_get_end_iter(native_seq);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_get_iter_at_pos_FUNCTION
#define g_sequence_get_iter_at_pos_REQUIRED_ARGC 2
#define g_sequence_get_iter_at_pos_OPTIONAL_ARGC 0
/* g_sequence_get_iter_at_pos
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - pos: int
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_get_iter_at_pos(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_int native_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &seq, &native_pos);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_get_iter_at_pos(native_seq, native_pos);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_get_length_FUNCTION
#define g_sequence_get_length_REQUIRED_ARGC 1
#define g_sequence_get_length_OPTIONAL_ARGC 0
/* g_sequence_get_length
 *
 * Parameters:
 * - seq: struct _GSequence *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_sequence_get_length(mrb_state* mrb, mrb_value self) {
  mrb_value seq;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &seq);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  /* Invocation */
  gint native_return_value = g_sequence_get_length(native_seq);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_sequence_insert_before_FUNCTION
#define g_sequence_insert_before_REQUIRED_ARGC 2
#define g_sequence_insert_before_OPTIONAL_ARGC 0
/* g_sequence_insert_before
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * - data: void *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_insert_before(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &iter, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_insert_before(native_iter, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_insert_sorted_FUNCTION
#define g_sequence_insert_sorted_REQUIRED_ARGC 4
#define g_sequence_insert_sorted_OPTIONAL_ARGC 0
/* g_sequence_insert_sorted
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - data: void *
 * - cmp_func: int (*)(const void *, const void *, void *)
 * - cmp_data: void *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_insert_sorted(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value data;
  mrb_value cmp_func;
  mrb_value cmp_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &seq, &data, &cmp_func, &cmp_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(cmp_func);
  TODO_type_check_void_PTR(cmp_data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_cmp_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(cmp_func);

  void * native_cmp_data = TODO_mruby_unbox_void_PTR(cmp_data);

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_insert_sorted(native_seq, native_data, native_cmp_func, native_cmp_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_insert_sorted_iter_FUNCTION
#define g_sequence_insert_sorted_iter_REQUIRED_ARGC 4
#define g_sequence_insert_sorted_iter_OPTIONAL_ARGC 0
/* g_sequence_insert_sorted_iter
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - data: void *
 * - iter_cmp: int (*)(struct _GSequenceNode *, struct _GSequenceNode *, void *)
 * - cmp_data: void *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_insert_sorted_iter(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value data;
  mrb_value iter_cmp;
  mrb_value cmp_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &seq, &data, &iter_cmp, &cmp_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GSequenceNode_PTR_COMMA_struct__GSequenceNode_PTR_COMMA_void_PTR_RPAREN(iter_cmp);
  TODO_type_check_void_PTR(cmp_data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_iter_cmp)(struct _GSequenceNode *, struct _GSequenceNode *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GSequenceNode_PTR_COMMA_struct__GSequenceNode_PTR_COMMA_void_PTR_RPAREN(iter_cmp);

  void * native_cmp_data = TODO_mruby_unbox_void_PTR(cmp_data);

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_insert_sorted_iter(native_seq, native_data, native_iter_cmp, native_cmp_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_iter_compare_FUNCTION
#define g_sequence_iter_compare_REQUIRED_ARGC 2
#define g_sequence_iter_compare_OPTIONAL_ARGC 0
/* g_sequence_iter_compare
 *
 * Parameters:
 * - a: struct _GSequenceNode *
 * - b: struct _GSequenceNode *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_sequence_iter_compare(mrb_state* mrb, mrb_value self) {
  mrb_value a;
  mrb_value b;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &a, &b);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, a, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, b, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_a = (mrb_nil_p(a) ? NULL : mruby_unbox__GSequenceNode(a));

  struct _GSequenceNode * native_b = (mrb_nil_p(b) ? NULL : mruby_unbox__GSequenceNode(b));

  /* Invocation */
  gint native_return_value = g_sequence_iter_compare(native_a, native_b);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_sequence_iter_get_position_FUNCTION
#define g_sequence_iter_get_position_REQUIRED_ARGC 1
#define g_sequence_iter_get_position_OPTIONAL_ARGC 0
/* g_sequence_iter_get_position
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_sequence_iter_get_position(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  /* Invocation */
  gint native_return_value = g_sequence_iter_get_position(native_iter);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_sequence_iter_get_sequence_FUNCTION
#define g_sequence_iter_get_sequence_REQUIRED_ARGC 1
#define g_sequence_iter_get_sequence_OPTIONAL_ARGC 0
/* g_sequence_iter_get_sequence
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * Return Type: GSequence *
 */
mrb_value
mrb_GLib_g_sequence_iter_get_sequence(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  /* Invocation */
  GSequence * native_return_value = g_sequence_iter_get_sequence(native_iter);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequence(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_iter_is_begin_FUNCTION
#define g_sequence_iter_is_begin_REQUIRED_ARGC 1
#define g_sequence_iter_is_begin_OPTIONAL_ARGC 0
/* g_sequence_iter_is_begin
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_sequence_iter_is_begin(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  /* Invocation */
  gboolean native_return_value = g_sequence_iter_is_begin(native_iter);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_sequence_iter_is_end_FUNCTION
#define g_sequence_iter_is_end_REQUIRED_ARGC 1
#define g_sequence_iter_is_end_OPTIONAL_ARGC 0
/* g_sequence_iter_is_end
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_sequence_iter_is_end(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  /* Invocation */
  gboolean native_return_value = g_sequence_iter_is_end(native_iter);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_sequence_iter_move_FUNCTION
#define g_sequence_iter_move_REQUIRED_ARGC 2
#define g_sequence_iter_move_OPTIONAL_ARGC 0
/* g_sequence_iter_move
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * - delta: int
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_iter_move(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  mrb_int native_delta;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &iter, &native_delta);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_iter_move(native_iter, native_delta);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_iter_next_FUNCTION
#define g_sequence_iter_next_REQUIRED_ARGC 1
#define g_sequence_iter_next_OPTIONAL_ARGC 0
/* g_sequence_iter_next
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_iter_next(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_iter_next(native_iter);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_iter_prev_FUNCTION
#define g_sequence_iter_prev_REQUIRED_ARGC 1
#define g_sequence_iter_prev_OPTIONAL_ARGC 0
/* g_sequence_iter_prev
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_iter_prev(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_iter_prev(native_iter);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_lookup_FUNCTION
#define g_sequence_lookup_REQUIRED_ARGC 4
#define g_sequence_lookup_OPTIONAL_ARGC 0
/* g_sequence_lookup
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - data: void *
 * - cmp_func: int (*)(const void *, const void *, void *)
 * - cmp_data: void *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value data;
  mrb_value cmp_func;
  mrb_value cmp_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &seq, &data, &cmp_func, &cmp_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(cmp_func);
  TODO_type_check_void_PTR(cmp_data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_cmp_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(cmp_func);

  void * native_cmp_data = TODO_mruby_unbox_void_PTR(cmp_data);

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_lookup(native_seq, native_data, native_cmp_func, native_cmp_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_lookup_iter_FUNCTION
#define g_sequence_lookup_iter_REQUIRED_ARGC 4
#define g_sequence_lookup_iter_OPTIONAL_ARGC 0
/* g_sequence_lookup_iter
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - data: void *
 * - iter_cmp: int (*)(struct _GSequenceNode *, struct _GSequenceNode *, void *)
 * - cmp_data: void *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_lookup_iter(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value data;
  mrb_value iter_cmp;
  mrb_value cmp_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &seq, &data, &iter_cmp, &cmp_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GSequenceNode_PTR_COMMA_struct__GSequenceNode_PTR_COMMA_void_PTR_RPAREN(iter_cmp);
  TODO_type_check_void_PTR(cmp_data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_iter_cmp)(struct _GSequenceNode *, struct _GSequenceNode *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GSequenceNode_PTR_COMMA_struct__GSequenceNode_PTR_COMMA_void_PTR_RPAREN(iter_cmp);

  void * native_cmp_data = TODO_mruby_unbox_void_PTR(cmp_data);

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_lookup_iter(native_seq, native_data, native_iter_cmp, native_cmp_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_move_FUNCTION
#define g_sequence_move_REQUIRED_ARGC 2
#define g_sequence_move_OPTIONAL_ARGC 0
/* g_sequence_move
 *
 * Parameters:
 * - src: struct _GSequenceNode *
 * - dest: struct _GSequenceNode *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_move(mrb_state* mrb, mrb_value self) {
  mrb_value src;
  mrb_value dest;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &src, &dest);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, src, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, dest, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_src = (mrb_nil_p(src) ? NULL : mruby_unbox__GSequenceNode(src));

  struct _GSequenceNode * native_dest = (mrb_nil_p(dest) ? NULL : mruby_unbox__GSequenceNode(dest));

  /* Invocation */
  g_sequence_move(native_src, native_dest);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_move_range_FUNCTION
#define g_sequence_move_range_REQUIRED_ARGC 3
#define g_sequence_move_range_OPTIONAL_ARGC 0
/* g_sequence_move_range
 *
 * Parameters:
 * - dest: struct _GSequenceNode *
 * - begin: struct _GSequenceNode *
 * - end: struct _GSequenceNode *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_move_range(mrb_state* mrb, mrb_value self) {
  mrb_value dest;
  mrb_value begin;
  mrb_value end;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &dest, &begin, &end);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dest, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, begin, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, end, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_dest = (mrb_nil_p(dest) ? NULL : mruby_unbox__GSequenceNode(dest));

  struct _GSequenceNode * native_begin = (mrb_nil_p(begin) ? NULL : mruby_unbox__GSequenceNode(begin));

  struct _GSequenceNode * native_end = (mrb_nil_p(end) ? NULL : mruby_unbox__GSequenceNode(end));

  /* Invocation */
  g_sequence_move_range(native_dest, native_begin, native_end);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_new_FUNCTION
#define g_sequence_new_REQUIRED_ARGC 1
#define g_sequence_new_OPTIONAL_ARGC 0
/* g_sequence_new
 *
 * Parameters:
 * - data_destroy: void (*)(void *)
 * Return Type: GSequence *
 */
mrb_value
mrb_GLib_g_sequence_new(mrb_state* mrb, mrb_value self) {
  mrb_value data_destroy;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &data_destroy);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(data_destroy);

  /* Unbox parameters */
  void (*native_data_destroy)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(data_destroy);

  /* Invocation */
  GSequence * native_return_value = g_sequence_new(native_data_destroy);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequence(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_prepend_FUNCTION
#define g_sequence_prepend_REQUIRED_ARGC 2
#define g_sequence_prepend_OPTIONAL_ARGC 0
/* g_sequence_prepend
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - data: void *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_prepend(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &seq, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_prepend(native_seq, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_range_get_midpoint_FUNCTION
#define g_sequence_range_get_midpoint_REQUIRED_ARGC 2
#define g_sequence_range_get_midpoint_OPTIONAL_ARGC 0
/* g_sequence_range_get_midpoint
 *
 * Parameters:
 * - begin: struct _GSequenceNode *
 * - end: struct _GSequenceNode *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_range_get_midpoint(mrb_state* mrb, mrb_value self) {
  mrb_value begin;
  mrb_value end;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &begin, &end);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, begin, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, end, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_begin = (mrb_nil_p(begin) ? NULL : mruby_unbox__GSequenceNode(begin));

  struct _GSequenceNode * native_end = (mrb_nil_p(end) ? NULL : mruby_unbox__GSequenceNode(end));

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_range_get_midpoint(native_begin, native_end);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_remove_FUNCTION
#define g_sequence_remove_REQUIRED_ARGC 1
#define g_sequence_remove_OPTIONAL_ARGC 0
/* g_sequence_remove
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_remove(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  /* Invocation */
  g_sequence_remove(native_iter);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_remove_range_FUNCTION
#define g_sequence_remove_range_REQUIRED_ARGC 2
#define g_sequence_remove_range_OPTIONAL_ARGC 0
/* g_sequence_remove_range
 *
 * Parameters:
 * - begin: struct _GSequenceNode *
 * - end: struct _GSequenceNode *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_remove_range(mrb_state* mrb, mrb_value self) {
  mrb_value begin;
  mrb_value end;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &begin, &end);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, begin, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, end, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_begin = (mrb_nil_p(begin) ? NULL : mruby_unbox__GSequenceNode(begin));

  struct _GSequenceNode * native_end = (mrb_nil_p(end) ? NULL : mruby_unbox__GSequenceNode(end));

  /* Invocation */
  g_sequence_remove_range(native_begin, native_end);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_search_FUNCTION
#define g_sequence_search_REQUIRED_ARGC 4
#define g_sequence_search_OPTIONAL_ARGC 0
/* g_sequence_search
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - data: void *
 * - cmp_func: int (*)(const void *, const void *, void *)
 * - cmp_data: void *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_search(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value data;
  mrb_value cmp_func;
  mrb_value cmp_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &seq, &data, &cmp_func, &cmp_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(cmp_func);
  TODO_type_check_void_PTR(cmp_data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_cmp_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(cmp_func);

  void * native_cmp_data = TODO_mruby_unbox_void_PTR(cmp_data);

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_search(native_seq, native_data, native_cmp_func, native_cmp_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_search_iter_FUNCTION
#define g_sequence_search_iter_REQUIRED_ARGC 4
#define g_sequence_search_iter_OPTIONAL_ARGC 0
/* g_sequence_search_iter
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - data: void *
 * - iter_cmp: int (*)(struct _GSequenceNode *, struct _GSequenceNode *, void *)
 * - cmp_data: void *
 * Return Type: GSequenceIter *
 */
mrb_value
mrb_GLib_g_sequence_search_iter(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value data;
  mrb_value iter_cmp;
  mrb_value cmp_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &seq, &data, &iter_cmp, &cmp_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GSequenceNode_PTR_COMMA_struct__GSequenceNode_PTR_COMMA_void_PTR_RPAREN(iter_cmp);
  TODO_type_check_void_PTR(cmp_data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_iter_cmp)(struct _GSequenceNode *, struct _GSequenceNode *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GSequenceNode_PTR_COMMA_struct__GSequenceNode_PTR_COMMA_void_PTR_RPAREN(iter_cmp);

  void * native_cmp_data = TODO_mruby_unbox_void_PTR(cmp_data);

  /* Invocation */
  GSequenceIter * native_return_value = g_sequence_search_iter(native_seq, native_data, native_iter_cmp, native_cmp_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSequenceNode(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_sequence_set_FUNCTION
#define g_sequence_set_REQUIRED_ARGC 2
#define g_sequence_set_OPTIONAL_ARGC 0
/* g_sequence_set
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_set(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &iter, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_sequence_set(native_iter, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_sort_FUNCTION
#define g_sequence_sort_REQUIRED_ARGC 3
#define g_sequence_sort_OPTIONAL_ARGC 0
/* g_sequence_sort
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - cmp_func: int (*)(const void *, const void *, void *)
 * - cmp_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_sort(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value cmp_func;
  mrb_value cmp_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &seq, &cmp_func, &cmp_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(cmp_func);
  TODO_type_check_void_PTR(cmp_data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  int (*native_cmp_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(cmp_func);

  void * native_cmp_data = TODO_mruby_unbox_void_PTR(cmp_data);

  /* Invocation */
  g_sequence_sort(native_seq, native_cmp_func, native_cmp_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_sort_changed_FUNCTION
#define g_sequence_sort_changed_REQUIRED_ARGC 3
#define g_sequence_sort_changed_OPTIONAL_ARGC 0
/* g_sequence_sort_changed
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * - cmp_func: int (*)(const void *, const void *, void *)
 * - cmp_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_sort_changed(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  mrb_value cmp_func;
  mrb_value cmp_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &iter, &cmp_func, &cmp_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(cmp_func);
  TODO_type_check_void_PTR(cmp_data);

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  int (*native_cmp_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(cmp_func);

  void * native_cmp_data = TODO_mruby_unbox_void_PTR(cmp_data);

  /* Invocation */
  g_sequence_sort_changed(native_iter, native_cmp_func, native_cmp_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_sort_changed_iter_FUNCTION
#define g_sequence_sort_changed_iter_REQUIRED_ARGC 3
#define g_sequence_sort_changed_iter_OPTIONAL_ARGC 0
/* g_sequence_sort_changed_iter
 *
 * Parameters:
 * - iter: struct _GSequenceNode *
 * - iter_cmp: int (*)(struct _GSequenceNode *, struct _GSequenceNode *, void *)
 * - cmp_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_sort_changed_iter(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  mrb_value iter_cmp;
  mrb_value cmp_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &iter, &iter_cmp, &cmp_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GSequenceNode_PTR_COMMA_struct__GSequenceNode_PTR_COMMA_void_PTR_RPAREN(iter_cmp);
  TODO_type_check_void_PTR(cmp_data);

  /* Unbox parameters */
  struct _GSequenceNode * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GSequenceNode(iter));

  int (*native_iter_cmp)(struct _GSequenceNode *, struct _GSequenceNode *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GSequenceNode_PTR_COMMA_struct__GSequenceNode_PTR_COMMA_void_PTR_RPAREN(iter_cmp);

  void * native_cmp_data = TODO_mruby_unbox_void_PTR(cmp_data);

  /* Invocation */
  g_sequence_sort_changed_iter(native_iter, native_iter_cmp, native_cmp_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_sort_iter_FUNCTION
#define g_sequence_sort_iter_REQUIRED_ARGC 3
#define g_sequence_sort_iter_OPTIONAL_ARGC 0
/* g_sequence_sort_iter
 *
 * Parameters:
 * - seq: struct _GSequence *
 * - cmp_func: int (*)(struct _GSequenceNode *, struct _GSequenceNode *, void *)
 * - cmp_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_sort_iter(mrb_state* mrb, mrb_value self) {
  mrb_value seq;
  mrb_value cmp_func;
  mrb_value cmp_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &seq, &cmp_func, &cmp_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, seq, GSequence_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequence expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN__GSequenceNode_PTR_COMMA_struct__GSequenceNode_PTR_COMMA_void_PTR_RPAREN(cmp_func);
  TODO_type_check_void_PTR(cmp_data);

  /* Unbox parameters */
  struct _GSequence * native_seq = (mrb_nil_p(seq) ? NULL : mruby_unbox__GSequence(seq));

  int (*native_cmp_func)(struct _GSequenceNode *, struct _GSequenceNode *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN__GSequenceNode_PTR_COMMA_struct__GSequenceNode_PTR_COMMA_void_PTR_RPAREN(cmp_func);

  void * native_cmp_data = TODO_mruby_unbox_void_PTR(cmp_data);

  /* Invocation */
  g_sequence_sort_iter(native_seq, native_cmp_func, native_cmp_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_sequence_swap_FUNCTION
#define g_sequence_swap_REQUIRED_ARGC 2
#define g_sequence_swap_OPTIONAL_ARGC 0
/* g_sequence_swap
 *
 * Parameters:
 * - a: struct _GSequenceNode *
 * - b: struct _GSequenceNode *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_sequence_swap(mrb_state* mrb, mrb_value self) {
  mrb_value a;
  mrb_value b;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &a, &b);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, a, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, b, GSequenceNode_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSequenceNode expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSequenceNode * native_a = (mrb_nil_p(a) ? NULL : mruby_unbox__GSequenceNode(a));

  struct _GSequenceNode * native_b = (mrb_nil_p(b) ? NULL : mruby_unbox__GSequenceNode(b));

  /* Invocation */
  g_sequence_swap(native_a, native_b);

  return mrb_nil_value();
}
#endif

#if BIND_g_set_application_name_FUNCTION
#define g_set_application_name_REQUIRED_ARGC 1
#define g_set_application_name_OPTIONAL_ARGC 0
/* g_set_application_name
 *
 * Parameters:
 * - application_name: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_set_application_name(mrb_state* mrb, mrb_value self) {
  char * native_application_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_application_name);

  /* Invocation */
  g_set_application_name(native_application_name);

  return mrb_nil_value();
}
#endif

#if BIND_g_set_error_FUNCTION
#define g_set_error_REQUIRED_ARGC 3
#define g_set_error_OPTIONAL_ARGC 0
/* g_set_error
 *
 * Parameters:
 * - domain: unsigned int
 * - code: int
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_set_error(mrb_state* mrb, mrb_value self) {
  struct GError * native_err = NULL;
  mrb_int native_domain;
  mrb_int native_code;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "iiz!", &native_domain, &native_code, &native_format);

  /* Invocation */
  g_set_error(&native_err, native_domain, native_code, native_format);

  /* Box the out parameters */
  mrb_value err = (native_err == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_err));

  return err;
}
#endif

#if BIND_g_set_error_literal_FUNCTION
#define g_set_error_literal_REQUIRED_ARGC 3
#define g_set_error_literal_OPTIONAL_ARGC 0
/* g_set_error_literal
 *
 * Parameters:
 * - domain: unsigned int
 * - code: int
 * - message: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_set_error_literal(mrb_state* mrb, mrb_value self) {
  struct GError * native_err = NULL;
  mrb_int native_domain;
  mrb_int native_code;
  char * native_message = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "iiz!", &native_domain, &native_code, &native_message);

  /* Invocation */
  g_set_error_literal(&native_err, native_domain, native_code, native_message);

  /* Box the out parameters */
  mrb_value err = (native_err == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_err));

  return err;
}
#endif

#if BIND_g_set_prgname_FUNCTION
#define g_set_prgname_REQUIRED_ARGC 1
#define g_set_prgname_OPTIONAL_ARGC 0
/* g_set_prgname
 *
 * Parameters:
 * - prgname: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_set_prgname(mrb_state* mrb, mrb_value self) {
  char * native_prgname = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_prgname);

  /* Invocation */
  g_set_prgname(native_prgname);

  return mrb_nil_value();
}
#endif

#if BIND_g_set_print_handler_FUNCTION
#define g_set_print_handler_REQUIRED_ARGC 1
#define g_set_print_handler_OPTIONAL_ARGC 0
/* g_set_print_handler
 *
 * Parameters:
 * - func: void (*)(const char *)
 * Return Type: GPrintFunc
 */
mrb_value
mrb_GLib_g_set_print_handler(mrb_state* mrb, mrb_value self) {
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &func);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_char_PTR_RPAREN(func);

  /* Unbox parameters */
  void (*native_func)(const char *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_char_PTR_RPAREN(func);

  /* Invocation */
  GPrintFunc native_return_value = g_set_print_handler(native_func);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GPrintFunc(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_set_printerr_handler_FUNCTION
#define g_set_printerr_handler_REQUIRED_ARGC 1
#define g_set_printerr_handler_OPTIONAL_ARGC 0
/* g_set_printerr_handler
 *
 * Parameters:
 * - func: void (*)(const char *)
 * Return Type: GPrintFunc
 */
mrb_value
mrb_GLib_g_set_printerr_handler(mrb_state* mrb, mrb_value self) {
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &func);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_char_PTR_RPAREN(func);

  /* Unbox parameters */
  void (*native_func)(const char *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_char_PTR_RPAREN(func);

  /* Invocation */
  GPrintFunc native_return_value = g_set_printerr_handler(native_func);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_GPrintFunc(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_setenv_FUNCTION
#define g_setenv_REQUIRED_ARGC 3
#define g_setenv_OPTIONAL_ARGC 0
/* g_setenv
 *
 * Parameters:
 * - variable: const char *
 * - value: const char *
 * - overwrite: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_setenv(mrb_state* mrb, mrb_value self) {
  char * native_variable = NULL;
  char * native_value = NULL;
  mrb_int native_overwrite;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &native_variable, &native_value, &native_overwrite);

  /* Invocation */
  gboolean native_return_value = g_setenv(native_variable, native_value, native_overwrite);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_shell_error_quark_FUNCTION
#define g_shell_error_quark_REQUIRED_ARGC 0
#define g_shell_error_quark_OPTIONAL_ARGC 0
/* g_shell_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_shell_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_shell_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_shell_parse_argv_FUNCTION
#define g_shell_parse_argv_REQUIRED_ARGC 3
#define g_shell_parse_argv_OPTIONAL_ARGC 0
/* g_shell_parse_argv
 *
 * Parameters:
 * - command_line: const char *
 * - argcp: int *
 * - argvp: char ***
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_shell_parse_argv(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_command_line = NULL;
  mrb_value argcp;
  mrb_value argvp;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!oo", &native_command_line, &argcp, &argvp);

  /* Type checking */
  TODO_type_check_int_PTR(argcp);
  TODO_type_check_char_PTR_PTR_PTR(argvp);

  /* Unbox parameters */
  int * native_argcp = TODO_mruby_unbox_int_PTR(argcp);

  char *** native_argvp = TODO_mruby_unbox_char_PTR_PTR_PTR(argvp);

  /* Invocation */
  gboolean native_return_value = g_shell_parse_argv(native_command_line, native_argcp, native_argvp, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_shell_quote_FUNCTION
#define g_shell_quote_REQUIRED_ARGC 1
#define g_shell_quote_OPTIONAL_ARGC 0
/* g_shell_quote
 *
 * Parameters:
 * - unquoted_string: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_shell_quote(mrb_state* mrb, mrb_value self) {
  char * native_unquoted_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_unquoted_string);

  /* Invocation */
  gchar * native_return_value = g_shell_quote(native_unquoted_string);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_shell_unquote_FUNCTION
#define g_shell_unquote_REQUIRED_ARGC 1
#define g_shell_unquote_OPTIONAL_ARGC 0
/* g_shell_unquote
 *
 * Parameters:
 * - quoted_string: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_shell_unquote(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_quoted_string = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_quoted_string);

  /* Invocation */
  gchar * native_return_value = g_shell_unquote(native_quoted_string, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_slice_alloc_FUNCTION
#define g_slice_alloc_REQUIRED_ARGC 1
#define g_slice_alloc_OPTIONAL_ARGC 0
/* g_slice_alloc
 *
 * Parameters:
 * - block_size: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_slice_alloc(mrb_state* mrb, mrb_value self) {
  mrb_int native_block_size;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_block_size);

  /* Invocation */
  gpointer native_return_value = g_slice_alloc(native_block_size);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_slice_alloc0_FUNCTION
#define g_slice_alloc0_REQUIRED_ARGC 1
#define g_slice_alloc0_OPTIONAL_ARGC 0
/* g_slice_alloc0
 *
 * Parameters:
 * - block_size: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_slice_alloc0(mrb_state* mrb, mrb_value self) {
  mrb_int native_block_size;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_block_size);

  /* Invocation */
  gpointer native_return_value = g_slice_alloc0(native_block_size);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_slice_copy_FUNCTION
#define g_slice_copy_REQUIRED_ARGC 2
#define g_slice_copy_OPTIONAL_ARGC 0
/* g_slice_copy
 *
 * Parameters:
 * - block_size: unsigned long
 * - mem_block: const void *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_slice_copy(mrb_state* mrb, mrb_value self) {
  mrb_int native_block_size;
  mrb_value mem_block;

  /* Fetch the args */
  mrb_get_args(mrb, "io", &native_block_size, &mem_block);

  /* Type checking */
  TODO_type_check_void_PTR(mem_block);

  /* Unbox parameters */
  const void * native_mem_block = TODO_mruby_unbox_void_PTR(mem_block);

  /* Invocation */
  gpointer native_return_value = g_slice_copy(native_block_size, native_mem_block);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_slice_free1_FUNCTION
#define g_slice_free1_REQUIRED_ARGC 2
#define g_slice_free1_OPTIONAL_ARGC 0
/* g_slice_free1
 *
 * Parameters:
 * - block_size: unsigned long
 * - mem_block: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_slice_free1(mrb_state* mrb, mrb_value self) {
  mrb_int native_block_size;
  mrb_value mem_block;

  /* Fetch the args */
  mrb_get_args(mrb, "io", &native_block_size, &mem_block);

  /* Type checking */
  TODO_type_check_void_PTR(mem_block);

  /* Unbox parameters */
  void * native_mem_block = TODO_mruby_unbox_void_PTR(mem_block);

  /* Invocation */
  g_slice_free1(native_block_size, native_mem_block);

  return mrb_nil_value();
}
#endif

#if BIND_g_slice_free_chain_with_offset_FUNCTION
#define g_slice_free_chain_with_offset_REQUIRED_ARGC 3
#define g_slice_free_chain_with_offset_OPTIONAL_ARGC 0
/* g_slice_free_chain_with_offset
 *
 * Parameters:
 * - block_size: unsigned long
 * - mem_chain: void *
 * - next_offset: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_slice_free_chain_with_offset(mrb_state* mrb, mrb_value self) {
  mrb_int native_block_size;
  mrb_value mem_chain;
  mrb_int native_next_offset;

  /* Fetch the args */
  mrb_get_args(mrb, "ioi", &native_block_size, &mem_chain, &native_next_offset);

  /* Type checking */
  TODO_type_check_void_PTR(mem_chain);

  /* Unbox parameters */
  void * native_mem_chain = TODO_mruby_unbox_void_PTR(mem_chain);

  /* Invocation */
  g_slice_free_chain_with_offset(native_block_size, native_mem_chain, native_next_offset);

  return mrb_nil_value();
}
#endif

#if BIND_g_slice_get_config_FUNCTION
#define g_slice_get_config_REQUIRED_ARGC 1
#define g_slice_get_config_OPTIONAL_ARGC 0
/* g_slice_get_config
 *
 * Parameters:
 * - ckey: GSliceConfig
 * Return Type: gint64
 */
mrb_value
mrb_GLib_g_slice_get_config(mrb_state* mrb, mrb_value self) {
  mrb_int native_ckey;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_ckey);

  /* Invocation */
  gint64 native_return_value = g_slice_get_config(native_ckey);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint64(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_slice_get_config_state_FUNCTION
#define g_slice_get_config_state_REQUIRED_ARGC 3
#define g_slice_get_config_state_OPTIONAL_ARGC 0
/* g_slice_get_config_state
 *
 * Parameters:
 * - ckey: GSliceConfig
 * - address: long
 * - n_values: unsigned int *
 * Return Type: gint64 *
 */
mrb_value
mrb_GLib_g_slice_get_config_state(mrb_state* mrb, mrb_value self) {
  mrb_int native_ckey;
  mrb_int native_address;
  mrb_value n_values;

  /* Fetch the args */
  mrb_get_args(mrb, "iio", &native_ckey, &native_address, &n_values);

  /* Type checking */
  TODO_type_check_unsigned_int_PTR(n_values);

  /* Unbox parameters */
  unsigned int * native_n_values = TODO_mruby_unbox_unsigned_int_PTR(n_values);

  /* Invocation */
  gint64 * native_return_value = g_slice_get_config_state(native_ckey, native_address, native_n_values);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint64_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_slice_set_config_FUNCTION
#define g_slice_set_config_REQUIRED_ARGC 2
#define g_slice_set_config_OPTIONAL_ARGC 0
/* g_slice_set_config
 *
 * Parameters:
 * - ckey: GSliceConfig
 * - value: long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_slice_set_config(mrb_state* mrb, mrb_value self) {
  mrb_int native_ckey;
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_ckey, &native_value);

  /* Invocation */
  g_slice_set_config(native_ckey, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_slist_alloc_FUNCTION
#define g_slist_alloc_REQUIRED_ARGC 0
#define g_slist_alloc_OPTIONAL_ARGC 0
/* g_slist_alloc
 *
 * Parameters: None
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_alloc(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GSList * native_return_value = g_slist_alloc();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_append_FUNCTION
#define g_slist_append_REQUIRED_ARGC 2
#define g_slist_append_OPTIONAL_ARGC 0
/* g_slist_append
 *
 * Parameters:
 * - list: struct _GSList *
 * - data: void *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_append(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GSList * native_return_value = g_slist_append(native_list, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_concat_FUNCTION
#define g_slist_concat_REQUIRED_ARGC 2
#define g_slist_concat_OPTIONAL_ARGC 0
/* g_slist_concat
 *
 * Parameters:
 * - list1: struct _GSList *
 * - list2: struct _GSList *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_concat(mrb_state* mrb, mrb_value self) {
  mrb_value list1;
  mrb_value list2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list1, &list2);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list1, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, list2, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list1 = (mrb_nil_p(list1) ? NULL : mruby_unbox__GSList(list1));

  struct _GSList * native_list2 = (mrb_nil_p(list2) ? NULL : mruby_unbox__GSList(list2));

  /* Invocation */
  GSList * native_return_value = g_slist_concat(native_list1, native_list2);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_copy_FUNCTION
#define g_slist_copy_REQUIRED_ARGC 1
#define g_slist_copy_OPTIONAL_ARGC 0
/* g_slist_copy
 *
 * Parameters:
 * - list: struct _GSList *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_copy(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  /* Invocation */
  GSList * native_return_value = g_slist_copy(native_list);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_copy_deep_FUNCTION
#define g_slist_copy_deep_REQUIRED_ARGC 3
#define g_slist_copy_deep_OPTIONAL_ARGC 0
/* g_slist_copy_deep
 *
 * Parameters:
 * - list: struct _GSList *
 * - func: void *(*)(const void *, void *)
 * - user_data: void *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_copy_deep(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  void *(*native_func)(const void *, void *) = TODO_mruby_unbox_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GSList * native_return_value = g_slist_copy_deep(native_list, native_func, native_user_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_delete_link_FUNCTION
#define g_slist_delete_link_REQUIRED_ARGC 2
#define g_slist_delete_link_OPTIONAL_ARGC 0
/* g_slist_delete_link
 *
 * Parameters:
 * - list: struct _GSList *
 * - link_: struct _GSList *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_delete_link(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value link_;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &link_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, link_, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  struct _GSList * native_link_ = (mrb_nil_p(link_) ? NULL : mruby_unbox__GSList(link_));

  /* Invocation */
  GSList * native_return_value = g_slist_delete_link(native_list, native_link_);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_find_FUNCTION
#define g_slist_find_REQUIRED_ARGC 2
#define g_slist_find_OPTIONAL_ARGC 0
/* g_slist_find
 *
 * Parameters:
 * - list: struct _GSList *
 * - data: const void *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_find(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GSList * native_return_value = g_slist_find(native_list, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_find_custom_FUNCTION
#define g_slist_find_custom_REQUIRED_ARGC 3
#define g_slist_find_custom_OPTIONAL_ARGC 0
/* g_slist_find_custom
 *
 * Parameters:
 * - list: struct _GSList *
 * - data: const void *
 * - func: int (*)(const void *, const void *)
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_find_custom(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &data, &func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(func);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(func);

  /* Invocation */
  GSList * native_return_value = g_slist_find_custom(native_list, native_data, native_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_foreach_FUNCTION
#define g_slist_foreach_REQUIRED_ARGC 3
#define g_slist_foreach_OPTIONAL_ARGC 0
/* g_slist_foreach
 *
 * Parameters:
 * - list: struct _GSList *
 * - func: void (*)(void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_slist_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  void (*native_func)(void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_slist_foreach(native_list, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_slist_free_FUNCTION
#define g_slist_free_REQUIRED_ARGC 1
#define g_slist_free_OPTIONAL_ARGC 0
/* g_slist_free
 *
 * Parameters:
 * - list: struct _GSList *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_slist_free(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  /* Invocation */
  g_slist_free(native_list);

  return mrb_nil_value();
}
#endif

#if BIND_g_slist_free_1_FUNCTION
#define g_slist_free_1_REQUIRED_ARGC 1
#define g_slist_free_1_OPTIONAL_ARGC 0
/* g_slist_free_1
 *
 * Parameters:
 * - list: struct _GSList *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_slist_free_1(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  /* Invocation */
  g_slist_free_1(native_list);

  return mrb_nil_value();
}
#endif

#if BIND_g_slist_free_full_FUNCTION
#define g_slist_free_full_REQUIRED_ARGC 2
#define g_slist_free_full_OPTIONAL_ARGC 0
/* g_slist_free_full
 *
 * Parameters:
 * - list: struct _GSList *
 * - free_func: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_slist_free_full(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value free_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &free_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(free_func);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  void (*native_free_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(free_func);

  /* Invocation */
  g_slist_free_full(native_list, native_free_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_slist_index_FUNCTION
#define g_slist_index_REQUIRED_ARGC 2
#define g_slist_index_OPTIONAL_ARGC 0
/* g_slist_index
 *
 * Parameters:
 * - list: struct _GSList *
 * - data: const void *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_slist_index(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  gint native_return_value = g_slist_index(native_list, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_slist_insert_FUNCTION
#define g_slist_insert_REQUIRED_ARGC 3
#define g_slist_insert_OPTIONAL_ARGC 0
/* g_slist_insert
 *
 * Parameters:
 * - list: struct _GSList *
 * - data: void *
 * - position: int
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_insert(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;
  mrb_int native_position;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &list, &data, &native_position);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GSList * native_return_value = g_slist_insert(native_list, native_data, native_position);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_insert_before_FUNCTION
#define g_slist_insert_before_REQUIRED_ARGC 3
#define g_slist_insert_before_OPTIONAL_ARGC 0
/* g_slist_insert_before
 *
 * Parameters:
 * - slist: struct _GSList *
 * - sibling: struct _GSList *
 * - data: void *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_insert_before(mrb_state* mrb, mrb_value self) {
  mrb_value slist;
  mrb_value sibling;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &slist, &sibling, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, slist, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, sibling, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSList * native_slist = (mrb_nil_p(slist) ? NULL : mruby_unbox__GSList(slist));

  struct _GSList * native_sibling = (mrb_nil_p(sibling) ? NULL : mruby_unbox__GSList(sibling));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GSList * native_return_value = g_slist_insert_before(native_slist, native_sibling, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_insert_sorted_FUNCTION
#define g_slist_insert_sorted_REQUIRED_ARGC 3
#define g_slist_insert_sorted_OPTIONAL_ARGC 0
/* g_slist_insert_sorted
 *
 * Parameters:
 * - list: struct _GSList *
 * - data: void *
 * - func: int (*)(const void *, const void *)
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_insert_sorted(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;
  mrb_value func;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &data, &func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(func);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(func);

  /* Invocation */
  GSList * native_return_value = g_slist_insert_sorted(native_list, native_data, native_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_insert_sorted_with_data_FUNCTION
#define g_slist_insert_sorted_with_data_REQUIRED_ARGC 4
#define g_slist_insert_sorted_with_data_OPTIONAL_ARGC 0
/* g_slist_insert_sorted_with_data
 *
 * Parameters:
 * - list: struct _GSList *
 * - data: void *
 * - func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_insert_sorted_with_data(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &list, &data, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  int (*native_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GSList * native_return_value = g_slist_insert_sorted_with_data(native_list, native_data, native_func, native_user_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_last_FUNCTION
#define g_slist_last_REQUIRED_ARGC 1
#define g_slist_last_OPTIONAL_ARGC 0
/* g_slist_last
 *
 * Parameters:
 * - list: struct _GSList *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_last(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  /* Invocation */
  GSList * native_return_value = g_slist_last(native_list);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_length_FUNCTION
#define g_slist_length_REQUIRED_ARGC 1
#define g_slist_length_OPTIONAL_ARGC 0
/* g_slist_length
 *
 * Parameters:
 * - list: struct _GSList *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_slist_length(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  /* Invocation */
  guint native_return_value = g_slist_length(native_list);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_slist_nth_FUNCTION
#define g_slist_nth_REQUIRED_ARGC 2
#define g_slist_nth_OPTIONAL_ARGC 0
/* g_slist_nth
 *
 * Parameters:
 * - list: struct _GSList *
 * - n: unsigned int
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_nth(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &list, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  /* Invocation */
  GSList * native_return_value = g_slist_nth(native_list, native_n);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_nth_data_FUNCTION
#define g_slist_nth_data_REQUIRED_ARGC 2
#define g_slist_nth_data_OPTIONAL_ARGC 0
/* g_slist_nth_data
 *
 * Parameters:
 * - list: struct _GSList *
 * - n: unsigned int
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_slist_nth_data(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &list, &native_n);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  /* Invocation */
  gpointer native_return_value = g_slist_nth_data(native_list, native_n);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_slist_position_FUNCTION
#define g_slist_position_REQUIRED_ARGC 2
#define g_slist_position_OPTIONAL_ARGC 0
/* g_slist_position
 *
 * Parameters:
 * - list: struct _GSList *
 * - llink: struct _GSList *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_slist_position(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value llink;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &llink);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, llink, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  struct _GSList * native_llink = (mrb_nil_p(llink) ? NULL : mruby_unbox__GSList(llink));

  /* Invocation */
  gint native_return_value = g_slist_position(native_list, native_llink);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_slist_prepend_FUNCTION
#define g_slist_prepend_REQUIRED_ARGC 2
#define g_slist_prepend_OPTIONAL_ARGC 0
/* g_slist_prepend
 *
 * Parameters:
 * - list: struct _GSList *
 * - data: void *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_prepend(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GSList * native_return_value = g_slist_prepend(native_list, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_remove_FUNCTION
#define g_slist_remove_REQUIRED_ARGC 2
#define g_slist_remove_OPTIONAL_ARGC 0
/* g_slist_remove
 *
 * Parameters:
 * - list: struct _GSList *
 * - data: const void *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_remove(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GSList * native_return_value = g_slist_remove(native_list, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_remove_all_FUNCTION
#define g_slist_remove_all_REQUIRED_ARGC 2
#define g_slist_remove_all_OPTIONAL_ARGC 0
/* g_slist_remove_all
 *
 * Parameters:
 * - list: struct _GSList *
 * - data: const void *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_remove_all(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GSList * native_return_value = g_slist_remove_all(native_list, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_remove_link_FUNCTION
#define g_slist_remove_link_REQUIRED_ARGC 2
#define g_slist_remove_link_OPTIONAL_ARGC 0
/* g_slist_remove_link
 *
 * Parameters:
 * - list: struct _GSList *
 * - link_: struct _GSList *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_remove_link(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value link_;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &link_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, link_, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  struct _GSList * native_link_ = (mrb_nil_p(link_) ? NULL : mruby_unbox__GSList(link_));

  /* Invocation */
  GSList * native_return_value = g_slist_remove_link(native_list, native_link_);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_reverse_FUNCTION
#define g_slist_reverse_REQUIRED_ARGC 1
#define g_slist_reverse_OPTIONAL_ARGC 0
/* g_slist_reverse
 *
 * Parameters:
 * - list: struct _GSList *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_reverse(mrb_state* mrb, mrb_value self) {
  mrb_value list;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &list);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  /* Invocation */
  GSList * native_return_value = g_slist_reverse(native_list);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_sort_FUNCTION
#define g_slist_sort_REQUIRED_ARGC 2
#define g_slist_sort_OPTIONAL_ARGC 0
/* g_slist_sort
 *
 * Parameters:
 * - list: struct _GSList *
 * - compare_func: int (*)(const void *, const void *)
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_sort(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value compare_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &list, &compare_func);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(compare_func);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  int (*native_compare_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(compare_func);

  /* Invocation */
  GSList * native_return_value = g_slist_sort(native_list, native_compare_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_slist_sort_with_data_FUNCTION
#define g_slist_sort_with_data_REQUIRED_ARGC 3
#define g_slist_sort_with_data_OPTIONAL_ARGC 0
/* g_slist_sort_with_data
 *
 * Parameters:
 * - list: struct _GSList *
 * - compare_func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: GSList *
 */
mrb_value
mrb_GLib_g_slist_sort_with_data(mrb_state* mrb, mrb_value self) {
  mrb_value list;
  mrb_value compare_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &list, &compare_func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, list, GSList_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSList expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GSList * native_list = (mrb_nil_p(list) ? NULL : mruby_unbox__GSList(list));

  int (*native_compare_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(compare_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GSList * native_return_value = g_slist_sort_with_data(native_list, native_compare_func, native_user_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSList(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_snprintf_FUNCTION
#define g_snprintf_REQUIRED_ARGC 3
#define g_snprintf_OPTIONAL_ARGC 0
/* g_snprintf
 *
 * Parameters:
 * - string: char *
 * - n: unsigned long
 * - format: const char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_snprintf(mrb_state* mrb, mrb_value self) {
  char * string = NULL;
  mrb_int native_n;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!", &string, &native_n, &native_format);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  gint native_return_value = g_snprintf(native_string, native_n, native_format);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_source_add_child_source_FUNCTION
#define g_source_add_child_source_REQUIRED_ARGC 2
#define g_source_add_child_source_OPTIONAL_ARGC 0
/* g_source_add_child_source
 *
 * Parameters:
 * - source: struct _GSource *
 * - child_source: struct _GSource *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_add_child_source(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value child_source;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &source, &child_source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, child_source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  struct _GSource * native_child_source = (mrb_nil_p(child_source) ? NULL : mruby_unbox__GSource(child_source));

  /* Invocation */
  g_source_add_child_source(native_source, native_child_source);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_add_poll_FUNCTION
#define g_source_add_poll_REQUIRED_ARGC 2
#define g_source_add_poll_OPTIONAL_ARGC 0
/* g_source_add_poll
 *
 * Parameters:
 * - source: struct _GSource *
 * - fd: struct _GPollFD *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_add_poll(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value fd;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &source, &fd);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, fd, GPollFD_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPollFD expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  struct _GPollFD * native_fd = (mrb_nil_p(fd) ? NULL : mruby_unbox__GPollFD(fd));

  /* Invocation */
  g_source_add_poll(native_source, native_fd);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_add_unix_fd_FUNCTION
#define g_source_add_unix_fd_REQUIRED_ARGC 3
#define g_source_add_unix_fd_OPTIONAL_ARGC 0
/* g_source_add_unix_fd
 *
 * Parameters:
 * - source: struct _GSource *
 * - fd: int
 * - events: GIOCondition
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_source_add_unix_fd(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_int native_fd;
  mrb_int native_events;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &source, &native_fd, &native_events);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  gpointer native_return_value = g_source_add_unix_fd(native_source, native_fd, native_events);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_attach_FUNCTION
#define g_source_attach_REQUIRED_ARGC 2
#define g_source_attach_OPTIONAL_ARGC 0
/* g_source_attach
 *
 * Parameters:
 * - source: struct _GSource *
 * - context: struct _GMainContext *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_source_attach(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value context;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &source, &context);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, context, GMainContext_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GMainContext expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  struct _GMainContext * native_context = (mrb_nil_p(context) ? NULL : mruby_unbox__GMainContext(context));

  /* Invocation */
  guint native_return_value = g_source_attach(native_source, native_context);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_destroy_FUNCTION
#define g_source_destroy_REQUIRED_ARGC 1
#define g_source_destroy_OPTIONAL_ARGC 0
/* g_source_destroy
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_destroy(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  g_source_destroy(native_source);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_get_can_recurse_FUNCTION
#define g_source_get_can_recurse_REQUIRED_ARGC 1
#define g_source_get_can_recurse_OPTIONAL_ARGC 0
/* g_source_get_can_recurse
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_source_get_can_recurse(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  gboolean native_return_value = g_source_get_can_recurse(native_source);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_get_context_FUNCTION
#define g_source_get_context_REQUIRED_ARGC 1
#define g_source_get_context_OPTIONAL_ARGC 0
/* g_source_get_context
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: GMainContext *
 */
mrb_value
mrb_GLib_g_source_get_context(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  GMainContext * native_return_value = g_source_get_context(native_source);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GMainContext(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_source_get_current_time_FUNCTION
#define g_source_get_current_time_REQUIRED_ARGC 2
#define g_source_get_current_time_OPTIONAL_ARGC 0
/* g_source_get_current_time
 *
 * Parameters:
 * - source: struct _GSource *
 * - timeval: struct _GTimeVal *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_get_current_time(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value timeval;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &source, &timeval);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, timeval, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  struct _GTimeVal * native_timeval = (mrb_nil_p(timeval) ? NULL : mruby_unbox__GTimeVal(timeval));

  /* Invocation */
  g_source_get_current_time(native_source, native_timeval);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_get_id_FUNCTION
#define g_source_get_id_REQUIRED_ARGC 1
#define g_source_get_id_OPTIONAL_ARGC 0
/* g_source_get_id
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_source_get_id(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  guint native_return_value = g_source_get_id(native_source);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_get_name_FUNCTION
#define g_source_get_name_REQUIRED_ARGC 1
#define g_source_get_name_OPTIONAL_ARGC 0
/* g_source_get_name
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: const char *
 */
mrb_value
mrb_GLib_g_source_get_name(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  const char * native_return_value = g_source_get_name(native_source);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_get_priority_FUNCTION
#define g_source_get_priority_REQUIRED_ARGC 1
#define g_source_get_priority_OPTIONAL_ARGC 0
/* g_source_get_priority
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_source_get_priority(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  gint native_return_value = g_source_get_priority(native_source);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_get_ready_time_FUNCTION
#define g_source_get_ready_time_REQUIRED_ARGC 1
#define g_source_get_ready_time_OPTIONAL_ARGC 0
/* g_source_get_ready_time
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: gint64
 */
mrb_value
mrb_GLib_g_source_get_ready_time(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  gint64 native_return_value = g_source_get_ready_time(native_source);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint64(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_get_time_FUNCTION
#define g_source_get_time_REQUIRED_ARGC 1
#define g_source_get_time_OPTIONAL_ARGC 0
/* g_source_get_time
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: gint64
 */
mrb_value
mrb_GLib_g_source_get_time(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  gint64 native_return_value = g_source_get_time(native_source);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint64(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_is_destroyed_FUNCTION
#define g_source_is_destroyed_REQUIRED_ARGC 1
#define g_source_is_destroyed_OPTIONAL_ARGC 0
/* g_source_is_destroyed
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_source_is_destroyed(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  gboolean native_return_value = g_source_is_destroyed(native_source);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_modify_unix_fd_FUNCTION
#define g_source_modify_unix_fd_REQUIRED_ARGC 3
#define g_source_modify_unix_fd_OPTIONAL_ARGC 0
/* g_source_modify_unix_fd
 *
 * Parameters:
 * - source: struct _GSource *
 * - tag: void *
 * - new_events: GIOCondition
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_modify_unix_fd(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value tag;
  mrb_int native_new_events;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &source, &tag, &native_new_events);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(tag);

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  void * native_tag = TODO_mruby_unbox_void_PTR(tag);

  /* Invocation */
  g_source_modify_unix_fd(native_source, native_tag, native_new_events);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_new_FUNCTION
#define g_source_new_REQUIRED_ARGC 2
#define g_source_new_OPTIONAL_ARGC 0
/* g_source_new
 *
 * Parameters:
 * - source_funcs: struct _GSourceFuncs *
 * - struct_size: unsigned int
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_source_new(mrb_state* mrb, mrb_value self) {
  mrb_value source_funcs;
  mrb_int native_struct_size;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &source_funcs, &native_struct_size);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source_funcs, GSourceFuncs_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSourceFuncs expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSourceFuncs * native_source_funcs = (mrb_nil_p(source_funcs) ? NULL : mruby_unbox__GSourceFuncs(source_funcs));

  /* Invocation */
  GSource * native_return_value = g_source_new(native_source_funcs, native_struct_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_source_query_unix_fd_FUNCTION
#define g_source_query_unix_fd_REQUIRED_ARGC 2
#define g_source_query_unix_fd_OPTIONAL_ARGC 0
/* g_source_query_unix_fd
 *
 * Parameters:
 * - source: struct _GSource *
 * - tag: void *
 * Return Type: GIOCondition
 */
mrb_value
mrb_GLib_g_source_query_unix_fd(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &source, &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(tag);

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  void * native_tag = TODO_mruby_unbox_void_PTR(tag);

  /* Invocation */
  GIOCondition native_return_value = g_source_query_unix_fd(native_source, native_tag);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_ref_FUNCTION
#define g_source_ref_REQUIRED_ARGC 1
#define g_source_ref_OPTIONAL_ARGC 0
/* g_source_ref
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_source_ref(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  GSource * native_return_value = g_source_ref(native_source);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_source_remove_FUNCTION
#define g_source_remove_REQUIRED_ARGC 1
#define g_source_remove_OPTIONAL_ARGC 0
/* g_source_remove
 *
 * Parameters:
 * - tag: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_source_remove(mrb_state* mrb, mrb_value self) {
  mrb_int native_tag;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_tag);

  /* Invocation */
  gboolean native_return_value = g_source_remove(native_tag);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_remove_by_funcs_user_data_FUNCTION
#define g_source_remove_by_funcs_user_data_REQUIRED_ARGC 2
#define g_source_remove_by_funcs_user_data_OPTIONAL_ARGC 0
/* g_source_remove_by_funcs_user_data
 *
 * Parameters:
 * - funcs: struct _GSourceFuncs *
 * - user_data: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_source_remove_by_funcs_user_data(mrb_state* mrb, mrb_value self) {
  mrb_value funcs;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &funcs, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, funcs, GSourceFuncs_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSourceFuncs expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GSourceFuncs * native_funcs = (mrb_nil_p(funcs) ? NULL : mruby_unbox__GSourceFuncs(funcs));

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  gboolean native_return_value = g_source_remove_by_funcs_user_data(native_funcs, native_user_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_remove_by_user_data_FUNCTION
#define g_source_remove_by_user_data_REQUIRED_ARGC 1
#define g_source_remove_by_user_data_OPTIONAL_ARGC 0
/* g_source_remove_by_user_data
 *
 * Parameters:
 * - user_data: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_source_remove_by_user_data(mrb_state* mrb, mrb_value self) {
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &user_data);

  /* Type checking */
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  gboolean native_return_value = g_source_remove_by_user_data(native_user_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_source_remove_child_source_FUNCTION
#define g_source_remove_child_source_REQUIRED_ARGC 2
#define g_source_remove_child_source_OPTIONAL_ARGC 0
/* g_source_remove_child_source
 *
 * Parameters:
 * - source: struct _GSource *
 * - child_source: struct _GSource *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_remove_child_source(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value child_source;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &source, &child_source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, child_source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  struct _GSource * native_child_source = (mrb_nil_p(child_source) ? NULL : mruby_unbox__GSource(child_source));

  /* Invocation */
  g_source_remove_child_source(native_source, native_child_source);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_remove_poll_FUNCTION
#define g_source_remove_poll_REQUIRED_ARGC 2
#define g_source_remove_poll_OPTIONAL_ARGC 0
/* g_source_remove_poll
 *
 * Parameters:
 * - source: struct _GSource *
 * - fd: struct _GPollFD *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_remove_poll(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value fd;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &source, &fd);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, fd, GPollFD_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GPollFD expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  struct _GPollFD * native_fd = (mrb_nil_p(fd) ? NULL : mruby_unbox__GPollFD(fd));

  /* Invocation */
  g_source_remove_poll(native_source, native_fd);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_remove_unix_fd_FUNCTION
#define g_source_remove_unix_fd_REQUIRED_ARGC 2
#define g_source_remove_unix_fd_OPTIONAL_ARGC 0
/* g_source_remove_unix_fd
 *
 * Parameters:
 * - source: struct _GSource *
 * - tag: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_remove_unix_fd(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value tag;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &source, &tag);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(tag);

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  void * native_tag = TODO_mruby_unbox_void_PTR(tag);

  /* Invocation */
  g_source_remove_unix_fd(native_source, native_tag);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_set_callback_FUNCTION
#define g_source_set_callback_REQUIRED_ARGC 4
#define g_source_set_callback_OPTIONAL_ARGC 0
/* g_source_set_callback
 *
 * Parameters:
 * - source: struct _GSource *
 * - func: int (*)(void *)
 * - data: void *
 * - notify: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_set_callback(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value func;
  mrb_value data;
  mrb_value notify;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &source, &func, &data, &notify);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  int (*native_func)(void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(func);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_notify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Invocation */
  g_source_set_callback(native_source, native_func, native_data, native_notify);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_set_callback_indirect_FUNCTION
#define g_source_set_callback_indirect_REQUIRED_ARGC 3
#define g_source_set_callback_indirect_OPTIONAL_ARGC 0
/* g_source_set_callback_indirect
 *
 * Parameters:
 * - source: struct _GSource *
 * - callback_data: void *
 * - callback_funcs: struct _GSourceCallbackFuncs *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_set_callback_indirect(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value callback_data;
  mrb_value callback_funcs;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &source, &callback_data, &callback_funcs);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(callback_data);
  if (!mrb_obj_is_kind_of(mrb, callback_funcs, GSourceCallbackFuncs_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSourceCallbackFuncs expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  void * native_callback_data = TODO_mruby_unbox_void_PTR(callback_data);

  struct _GSourceCallbackFuncs * native_callback_funcs = (mrb_nil_p(callback_funcs) ? NULL : mruby_unbox__GSourceCallbackFuncs(callback_funcs));

  /* Invocation */
  g_source_set_callback_indirect(native_source, native_callback_data, native_callback_funcs);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_set_can_recurse_FUNCTION
#define g_source_set_can_recurse_REQUIRED_ARGC 2
#define g_source_set_can_recurse_OPTIONAL_ARGC 0
/* g_source_set_can_recurse
 *
 * Parameters:
 * - source: struct _GSource *
 * - can_recurse: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_set_can_recurse(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_int native_can_recurse;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &source, &native_can_recurse);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  g_source_set_can_recurse(native_source, native_can_recurse);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_set_funcs_FUNCTION
#define g_source_set_funcs_REQUIRED_ARGC 2
#define g_source_set_funcs_OPTIONAL_ARGC 0
/* g_source_set_funcs
 *
 * Parameters:
 * - source: struct _GSource *
 * - funcs: struct _GSourceFuncs *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_set_funcs(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_value funcs;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &source, &funcs);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, funcs, GSourceFuncs_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSourceFuncs expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  struct _GSourceFuncs * native_funcs = (mrb_nil_p(funcs) ? NULL : mruby_unbox__GSourceFuncs(funcs));

  /* Invocation */
  g_source_set_funcs(native_source, native_funcs);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_set_name_FUNCTION
#define g_source_set_name_REQUIRED_ARGC 2
#define g_source_set_name_OPTIONAL_ARGC 0
/* g_source_set_name
 *
 * Parameters:
 * - source: struct _GSource *
 * - name: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_set_name(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &source, &native_name);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  g_source_set_name(native_source, native_name);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_set_name_by_id_FUNCTION
#define g_source_set_name_by_id_REQUIRED_ARGC 2
#define g_source_set_name_by_id_OPTIONAL_ARGC 0
/* g_source_set_name_by_id
 *
 * Parameters:
 * - tag: unsigned int
 * - name: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_set_name_by_id(mrb_state* mrb, mrb_value self) {
  mrb_int native_tag;
  char * native_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "iz!", &native_tag, &native_name);

  /* Invocation */
  g_source_set_name_by_id(native_tag, native_name);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_set_priority_FUNCTION
#define g_source_set_priority_REQUIRED_ARGC 2
#define g_source_set_priority_OPTIONAL_ARGC 0
/* g_source_set_priority
 *
 * Parameters:
 * - source: struct _GSource *
 * - priority: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_set_priority(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_int native_priority;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &source, &native_priority);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  g_source_set_priority(native_source, native_priority);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_set_ready_time_FUNCTION
#define g_source_set_ready_time_REQUIRED_ARGC 2
#define g_source_set_ready_time_OPTIONAL_ARGC 0
/* g_source_set_ready_time
 *
 * Parameters:
 * - source: struct _GSource *
 * - ready_time: long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_set_ready_time(mrb_state* mrb, mrb_value self) {
  mrb_value source;
  mrb_int native_ready_time;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &source, &native_ready_time);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  g_source_set_ready_time(native_source, native_ready_time);

  return mrb_nil_value();
}
#endif

#if BIND_g_source_unref_FUNCTION
#define g_source_unref_REQUIRED_ARGC 1
#define g_source_unref_OPTIONAL_ARGC 0
/* g_source_unref
 *
 * Parameters:
 * - source: struct _GSource *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_source_unref(mrb_state* mrb, mrb_value self) {
  mrb_value source;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &source);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, source, GSource_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GSource expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GSource * native_source = (mrb_nil_p(source) ? NULL : mruby_unbox__GSource(source));

  /* Invocation */
  g_source_unref(native_source);

  return mrb_nil_value();
}
#endif

#if BIND_g_spaced_primes_closest_FUNCTION
#define g_spaced_primes_closest_REQUIRED_ARGC 1
#define g_spaced_primes_closest_OPTIONAL_ARGC 0
/* g_spaced_primes_closest
 *
 * Parameters:
 * - num: unsigned int
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_spaced_primes_closest(mrb_state* mrb, mrb_value self) {
  mrb_int native_num;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_num);

  /* Invocation */
  guint native_return_value = g_spaced_primes_closest(native_num);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_spawn_async_FUNCTION
#define g_spawn_async_REQUIRED_ARGC 6
#define g_spawn_async_OPTIONAL_ARGC 0
/* g_spawn_async
 *
 * Parameters:
 * - working_directory: const char *
 * - argv: char **
 * - envp: char **
 * - flags: GSpawnFlags
 * - child_setup: void (*)(void *)
 * - user_data: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_spawn_async(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_working_directory = NULL;
  mrb_value argv;
  mrb_value envp;
  mrb_int native_flags;
  mrb_value child_setup;
  mrb_value user_data;
  int native_child_pid;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!A!A!ioo", &native_working_directory, &argv, &envp, &native_flags, &child_setup, &user_data);

  /* Unbox parameters */
  char ** native_argv = NULL;
  do {
    if (mrb_nil_p(argv)) {
      native_argv = NULL;
    } else {
      int len = mrb_ary_len(mrb, argv);
      native_argv = (char**)calloc((len + 1), sizeof(char*));
      for (int i = 0; i < len; i++) {
        mrb_value str = mrb_ary_ref(mrb, argv, i);
        native_argv[i] = mrb_string_value_cstr(mrb, &str);
      }
      native_argv[len] = NULL;
    }
  } while (0);

  char ** native_envp = NULL;
  do {
    if (mrb_nil_p(envp)) {
      native_envp = NULL;
    } else {
      int len = mrb_ary_len(mrb, envp);
      native_envp = (char**)calloc((len + 1), sizeof(char*));
      for (int i = 0; i < len; i++) {
        mrb_value str = mrb_ary_ref(mrb, envp, i);
        native_envp[i] = mrb_string_value_cstr(mrb, &str);
      }
      native_envp[len] = NULL;
    }
  } while (0);

  void * native_child_setup = NULL; /* Unused parameter */

  void * native_user_data = NULL; /* Unused parameter */

  /* Invocation */
  gboolean native_return_value = g_spawn_async(native_working_directory, native_argv, native_envp, native_flags, native_child_setup, native_user_data, &native_child_pid, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value child_pid = mrb_fixnum_value(native_child_pid);
  mrb_ary_push(mrb, results, child_pid);
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  /* Clean up temporary values from unboxing */
  if (native_argv != NULL) free(native_argv);

  if (native_envp != NULL) free(native_envp);

  return results;
}
#endif

#if BIND_g_spawn_async_with_pipes_FUNCTION
#define g_spawn_async_with_pipes_REQUIRED_ARGC 6
#define g_spawn_async_with_pipes_OPTIONAL_ARGC 0
/* g_spawn_async_with_pipes
 *
 * Parameters:
 * - working_directory: const char *
 * - argv: char **
 * - envp: char **
 * - flags: GSpawnFlags
 * - child_setup: void (*)(void *)
 * - user_data: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_spawn_async_with_pipes(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_working_directory = NULL;
  mrb_value argv;
  mrb_value envp;
  mrb_int native_flags;
  mrb_value child_setup;
  mrb_value user_data;
  int native_child_pid;
  int native_standard_input;
  int native_standard_output;
  int native_standard_error;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!A!A!ioo", &native_working_directory, &argv, &envp, &native_flags, &child_setup, &user_data);

  /* Unbox parameters */
  char ** native_argv = NULL;
  do {
    if (mrb_nil_p(argv)) {
      native_argv = NULL;
    } else {
      int len = mrb_ary_len(mrb, argv);
      native_argv = (char**)calloc((len + 1), sizeof(char*));
      for (int i = 0; i < len; i++) {
        mrb_value str = mrb_ary_ref(mrb, argv, i);
        native_argv[i] = mrb_string_value_cstr(mrb, &str);
      }
      native_argv[len] = NULL;
    }
  } while (0);

  char ** native_envp = NULL;
  do {
    if (mrb_nil_p(envp)) {
      native_envp = NULL;
    } else {
      int len = mrb_ary_len(mrb, envp);
      native_envp = (char**)calloc((len + 1), sizeof(char*));
      for (int i = 0; i < len; i++) {
        mrb_value str = mrb_ary_ref(mrb, envp, i);
        native_envp[i] = mrb_string_value_cstr(mrb, &str);
      }
      native_envp[len] = NULL;
    }
  } while (0);

  void * native_child_setup = NULL; /* Unused parameter */

  void * native_user_data = NULL; /* Unused parameter */

  /* Invocation */
  gboolean native_return_value = g_spawn_async_with_pipes(native_working_directory, native_argv, native_envp, native_flags, native_child_setup, native_user_data, &native_child_pid, &native_standard_input, &native_standard_output, &native_standard_error, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value child_pid = mrb_fixnum_value(native_child_pid);
  mrb_ary_push(mrb, results, child_pid);
  mrb_value standard_input = mrb_fixnum_value(native_standard_input);
  mrb_ary_push(mrb, results, standard_input);
  mrb_value standard_output = mrb_fixnum_value(native_standard_output);
  mrb_ary_push(mrb, results, standard_output);
  mrb_value standard_error = mrb_fixnum_value(native_standard_error);
  mrb_ary_push(mrb, results, standard_error);
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  /* Clean up temporary values from unboxing */
  if (native_argv != NULL) free(native_argv);

  if (native_envp != NULL) free(native_envp);

  return results;
}
#endif

#if BIND_g_spawn_check_exit_status_FUNCTION
#define g_spawn_check_exit_status_REQUIRED_ARGC 1
#define g_spawn_check_exit_status_OPTIONAL_ARGC 0
/* g_spawn_check_exit_status
 *
 * Parameters:
 * - exit_status: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_spawn_check_exit_status(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_int native_exit_status;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_exit_status);

  /* Invocation */
  gboolean native_return_value = g_spawn_check_exit_status(native_exit_status, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_spawn_close_pid_FUNCTION
#define g_spawn_close_pid_REQUIRED_ARGC 1
#define g_spawn_close_pid_OPTIONAL_ARGC 0
/* g_spawn_close_pid
 *
 * Parameters:
 * - pid: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_spawn_close_pid(mrb_state* mrb, mrb_value self) {
  mrb_int native_pid;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_pid);

  /* Invocation */
  g_spawn_close_pid(native_pid);

  return mrb_nil_value();
}
#endif

#if BIND_g_spawn_command_line_async_FUNCTION
#define g_spawn_command_line_async_REQUIRED_ARGC 1
#define g_spawn_command_line_async_OPTIONAL_ARGC 0
/* g_spawn_command_line_async
 *
 * Parameters:
 * - command_line: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_spawn_command_line_async(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_command_line = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_command_line);

  /* Invocation */
  gboolean native_return_value = g_spawn_command_line_async(native_command_line, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_spawn_command_line_sync_FUNCTION
#define g_spawn_command_line_sync_REQUIRED_ARGC 1
#define g_spawn_command_line_sync_OPTIONAL_ARGC 0
/* g_spawn_command_line_sync
 *
 * Parameters:
 * - command_line: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_spawn_command_line_sync(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_command_line = NULL;
  int native_standard_output;
  int native_standard_error;
  char * native_exit_status = NULL;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_command_line);

  /* Invocation */
  gboolean native_return_value = g_spawn_command_line_sync(native_command_line, &native_standard_output, &native_standard_error, &native_exit_status, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value standard_output = mrb_fixnum_value(native_standard_output);
  mrb_ary_push(mrb, results, standard_output);
  mrb_value standard_error = mrb_fixnum_value(native_standard_error);
  mrb_ary_push(mrb, results, standard_error);
  mrb_value exit_status = mrb_str_new_cstr(mrb, native_exit_status);
  free(native_exit_status);
  mrb_ary_push(mrb, results, exit_status);
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_spawn_error_quark_FUNCTION
#define g_spawn_error_quark_REQUIRED_ARGC 0
#define g_spawn_error_quark_OPTIONAL_ARGC 0
/* g_spawn_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_spawn_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_spawn_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_spawn_exit_error_quark_FUNCTION
#define g_spawn_exit_error_quark_REQUIRED_ARGC 0
#define g_spawn_exit_error_quark_OPTIONAL_ARGC 0
/* g_spawn_exit_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_spawn_exit_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_spawn_exit_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_spawn_sync_FUNCTION
#define g_spawn_sync_REQUIRED_ARGC 6
#define g_spawn_sync_OPTIONAL_ARGC 0
/* g_spawn_sync
 *
 * Parameters:
 * - working_directory: const char *
 * - argv: char **
 * - envp: char **
 * - flags: GSpawnFlags
 * - child_setup: void (*)(void *)
 * - user_data: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_spawn_sync(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_working_directory = NULL;
  mrb_value argv;
  mrb_value envp;
  mrb_int native_flags;
  mrb_value child_setup;
  mrb_value user_data;
  char * native_standard_output = NULL;
  char * native_standard_error = NULL;
  int native_exit_status;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!A!A!ioo", &native_working_directory, &argv, &envp, &native_flags, &child_setup, &user_data);

  /* Unbox parameters */
  char ** native_argv = NULL;
  do {
    if (mrb_nil_p(argv)) {
      native_argv = NULL;
    } else {
      int len = mrb_ary_len(mrb, argv);
      native_argv = (char**)calloc((len + 1), sizeof(char*));
      for (int i = 0; i < len; i++) {
        mrb_value str = mrb_ary_ref(mrb, argv, i);
        native_argv[i] = mrb_string_value_cstr(mrb, &str);
      }
      native_argv[len] = NULL;
    }
  } while (0);

  char ** native_envp = NULL;
  do {
    if (mrb_nil_p(envp)) {
      native_envp = NULL;
    } else {
      int len = mrb_ary_len(mrb, envp);
      native_envp = (char**)calloc((len + 1), sizeof(char*));
      for (int i = 0; i < len; i++) {
        mrb_value str = mrb_ary_ref(mrb, envp, i);
        native_envp[i] = mrb_string_value_cstr(mrb, &str);
      }
      native_envp[len] = NULL;
    }
  } while (0);

  void * native_child_setup = NULL; /* Unused parameter */

  void * native_user_data = NULL; /* Unused parameter */

  /* Invocation */
  gboolean native_return_value = g_spawn_sync(native_working_directory, native_argv, native_envp, native_flags, native_child_setup, native_user_data, &native_standard_output, &native_standard_error, &native_exit_status, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value standard_output = mrb_str_new_cstr(mrb, native_standard_output);
  free(native_standard_output);
  mrb_ary_push(mrb, results, standard_output);
  mrb_value standard_error = mrb_str_new_cstr(mrb, native_standard_error);
  free(native_standard_error);
  mrb_ary_push(mrb, results, standard_error);
  mrb_value exit_status = mrb_fixnum_value(native_exit_status);
  mrb_ary_push(mrb, results, exit_status);
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  /* Clean up temporary values from unboxing */
  if (native_argv != NULL) free(native_argv);

  if (native_envp != NULL) free(native_envp);

  return results;
}
#endif

#if BIND_g_sprintf_FUNCTION
#define g_sprintf_REQUIRED_ARGC 2
#define g_sprintf_OPTIONAL_ARGC 0
/* g_sprintf
 *
 * Parameters:
 * - string: char *
 * - format: const char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_sprintf(mrb_state* mrb, mrb_value self) {
  char * string = NULL;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &string, &native_format);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  gint native_return_value = g_sprintf(native_string, native_format);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_steal_pointer_FUNCTION
#define g_steal_pointer_REQUIRED_ARGC 1
#define g_steal_pointer_OPTIONAL_ARGC 0
/* g_steal_pointer
 *
 * Parameters:
 * - pp: void *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_steal_pointer(mrb_state* mrb, mrb_value self) {
  mrb_value pp;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pp);

  /* Type checking */
  TODO_type_check_void_PTR(pp);

  /* Unbox parameters */
  void * native_pp = TODO_mruby_unbox_void_PTR(pp);

  /* Invocation */
  gpointer native_return_value = g_steal_pointer(native_pp);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_stpcpy_FUNCTION
#define g_stpcpy_REQUIRED_ARGC 2
#define g_stpcpy_OPTIONAL_ARGC 0
/* g_stpcpy
 *
 * Parameters:
 * - dest: char *
 * - src: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_stpcpy(mrb_state* mrb, mrb_value self) {
  char * dest = NULL;
  char * native_src = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &dest, &native_src);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_dest = strdup(dest);

  /* Invocation */
  gchar * native_return_value = g_stpcpy(native_dest, native_src);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_dest);
  native_dest = NULL;

  return return_value;
}
#endif

#if BIND_g_str_equal_FUNCTION
#define g_str_equal_REQUIRED_ARGC 2
#define g_str_equal_OPTIONAL_ARGC 0
/* g_str_equal
 *
 * Parameters:
 * - v1: const void *
 * - v2: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_str_equal(mrb_state* mrb, mrb_value self) {
  mrb_value v1;
  mrb_value v2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &v1, &v2);

  /* Type checking */
  TODO_type_check_void_PTR(v1);
  TODO_type_check_void_PTR(v2);

  /* Unbox parameters */
  const void * native_v1 = TODO_mruby_unbox_void_PTR(v1);

  const void * native_v2 = TODO_mruby_unbox_void_PTR(v2);

  /* Invocation */
  gboolean native_return_value = g_str_equal(native_v1, native_v2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_str_has_prefix_FUNCTION
#define g_str_has_prefix_REQUIRED_ARGC 2
#define g_str_has_prefix_OPTIONAL_ARGC 0
/* g_str_has_prefix
 *
 * Parameters:
 * - str: const char *
 * - prefix: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_str_has_prefix(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  char * native_prefix = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_str, &native_prefix);

  /* Invocation */
  gboolean native_return_value = g_str_has_prefix(native_str, native_prefix);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_str_has_suffix_FUNCTION
#define g_str_has_suffix_REQUIRED_ARGC 2
#define g_str_has_suffix_OPTIONAL_ARGC 0
/* g_str_has_suffix
 *
 * Parameters:
 * - str: const char *
 * - suffix: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_str_has_suffix(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  char * native_suffix = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_str, &native_suffix);

  /* Invocation */
  gboolean native_return_value = g_str_has_suffix(native_str, native_suffix);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_str_hash_FUNCTION
#define g_str_hash_REQUIRED_ARGC 1
#define g_str_hash_OPTIONAL_ARGC 0
/* g_str_hash
 *
 * Parameters:
 * - v: const void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_str_hash(mrb_state* mrb, mrb_value self) {
  mrb_value v;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &v);

  /* Type checking */
  TODO_type_check_void_PTR(v);

  /* Unbox parameters */
  const void * native_v = TODO_mruby_unbox_void_PTR(v);

  /* Invocation */
  guint native_return_value = g_str_hash(native_v);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_str_is_ascii_FUNCTION
#define g_str_is_ascii_REQUIRED_ARGC 1
#define g_str_is_ascii_OPTIONAL_ARGC 0
/* g_str_is_ascii
 *
 * Parameters:
 * - str: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_str_is_ascii(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_str);

  /* Invocation */
  gboolean native_return_value = g_str_is_ascii(native_str);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_str_match_string_FUNCTION
#define g_str_match_string_REQUIRED_ARGC 3
#define g_str_match_string_OPTIONAL_ARGC 0
/* g_str_match_string
 *
 * Parameters:
 * - search_term: const char *
 * - potential_hit: const char *
 * - accept_alternates: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_str_match_string(mrb_state* mrb, mrb_value self) {
  char * native_search_term = NULL;
  char * native_potential_hit = NULL;
  mrb_int native_accept_alternates;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &native_search_term, &native_potential_hit, &native_accept_alternates);

  /* Invocation */
  gboolean native_return_value = g_str_match_string(native_search_term, native_potential_hit, native_accept_alternates);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_str_to_ascii_FUNCTION
#define g_str_to_ascii_REQUIRED_ARGC 2
#define g_str_to_ascii_OPTIONAL_ARGC 0
/* g_str_to_ascii
 *
 * Parameters:
 * - str: const char *
 * - from_locale: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_str_to_ascii(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  char * native_from_locale = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_str, &native_from_locale);

  /* Invocation */
  gchar * native_return_value = g_str_to_ascii(native_str, native_from_locale);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_str_tokenize_and_fold_FUNCTION
#define g_str_tokenize_and_fold_REQUIRED_ARGC 3
#define g_str_tokenize_and_fold_OPTIONAL_ARGC 0
/* g_str_tokenize_and_fold
 *
 * Parameters:
 * - string: const char *
 * - translit_locale: const char *
 * - ascii_alternates: char ***
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_str_tokenize_and_fold(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;
  char * native_translit_locale = NULL;
  mrb_value ascii_alternates;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!o", &native_string, &native_translit_locale, &ascii_alternates);

  /* Type checking */
  TODO_type_check_char_PTR_PTR_PTR(ascii_alternates);

  /* Unbox parameters */
  char *** native_ascii_alternates = TODO_mruby_unbox_char_PTR_PTR_PTR(ascii_alternates);

  /* Invocation */
  gchar ** native_return_value = g_str_tokenize_and_fold(native_string, native_translit_locale, native_ascii_alternates);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strcanon_FUNCTION
#define g_strcanon_REQUIRED_ARGC 3
#define g_strcanon_OPTIONAL_ARGC 0
/* g_strcanon
 *
 * Parameters:
 * - string: char *
 * - valid_chars: const char *
 * - substitutor: char
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strcanon(mrb_state* mrb, mrb_value self) {
  char * string = NULL;
  char * native_valid_chars = NULL;
  mrb_int native_substitutor;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &string, &native_valid_chars, &native_substitutor);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  gchar * native_return_value = g_strcanon(native_string, native_valid_chars, native_substitutor);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_strcasecmp_FUNCTION
#define g_strcasecmp_REQUIRED_ARGC 2
#define g_strcasecmp_OPTIONAL_ARGC 0
/* g_strcasecmp
 *
 * Parameters:
 * - s1: const char *
 * - s2: const char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_strcasecmp(mrb_state* mrb, mrb_value self) {
  char * native_s1 = NULL;
  char * native_s2 = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_s1, &native_s2);

  /* Invocation */
  gint native_return_value = g_strcasecmp(native_s1, native_s2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strchomp_FUNCTION
#define g_strchomp_REQUIRED_ARGC 1
#define g_strchomp_OPTIONAL_ARGC 0
/* g_strchomp
 *
 * Parameters:
 * - string: char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strchomp(mrb_state* mrb, mrb_value self) {
  char * string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &string);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  gchar * native_return_value = g_strchomp(native_string);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_strchug_FUNCTION
#define g_strchug_REQUIRED_ARGC 1
#define g_strchug_OPTIONAL_ARGC 0
/* g_strchug
 *
 * Parameters:
 * - string: char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strchug(mrb_state* mrb, mrb_value self) {
  char * string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &string);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  gchar * native_return_value = g_strchug(native_string);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_strcmp0_FUNCTION
#define g_strcmp0_REQUIRED_ARGC 2
#define g_strcmp0_OPTIONAL_ARGC 0
/* g_strcmp0
 *
 * Parameters:
 * - str1: const char *
 * - str2: const char *
 * Return Type: int
 */
mrb_value
mrb_GLib_g_strcmp0(mrb_state* mrb, mrb_value self) {
  char * native_str1 = NULL;
  char * native_str2 = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_str1, &native_str2);

  /* Invocation */
  int native_return_value = g_strcmp0(native_str1, native_str2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strcompress_FUNCTION
#define g_strcompress_REQUIRED_ARGC 1
#define g_strcompress_OPTIONAL_ARGC 0
/* g_strcompress
 *
 * Parameters:
 * - source: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strcompress(mrb_state* mrb, mrb_value self) {
  char * native_source = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_source);

  /* Invocation */
  gchar * native_return_value = g_strcompress(native_source);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strconcat_FUNCTION
#define g_strconcat_REQUIRED_ARGC 1
#define g_strconcat_OPTIONAL_ARGC 0
/* g_strconcat
 *
 * Parameters:
 * - string1: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strconcat(mrb_state* mrb, mrb_value self) {
  char * native_string1 = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_string1);

  /* Invocation */
  gchar * native_return_value = g_strconcat(native_string1);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strdelimit_FUNCTION
#define g_strdelimit_REQUIRED_ARGC 3
#define g_strdelimit_OPTIONAL_ARGC 0
/* g_strdelimit
 *
 * Parameters:
 * - string: char *
 * - delimiters: const char *
 * - new_delimiter: char
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strdelimit(mrb_state* mrb, mrb_value self) {
  char * string = NULL;
  char * native_delimiters = NULL;
  mrb_int native_new_delimiter;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &string, &native_delimiters, &native_new_delimiter);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  gchar * native_return_value = g_strdelimit(native_string, native_delimiters, native_new_delimiter);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_strdown_FUNCTION
#define g_strdown_REQUIRED_ARGC 1
#define g_strdown_OPTIONAL_ARGC 0
/* g_strdown
 *
 * Parameters:
 * - string: char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strdown(mrb_state* mrb, mrb_value self) {
  char * string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &string);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  gchar * native_return_value = g_strdown(native_string);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_strdup_FUNCTION
#define g_strdup_REQUIRED_ARGC 1
#define g_strdup_OPTIONAL_ARGC 0
/* g_strdup
 *
 * Parameters:
 * - str: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strdup(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_str);

  /* Invocation */
  gchar * native_return_value = g_strdup(native_str);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strdup_printf_FUNCTION
#define g_strdup_printf_REQUIRED_ARGC 1
#define g_strdup_printf_OPTIONAL_ARGC 0
/* g_strdup_printf
 *
 * Parameters:
 * - format: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strdup_printf(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_format);

  /* Invocation */
  gchar * native_return_value = g_strdup_printf(native_format);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strdup_vprintf_FUNCTION
#define g_strdup_vprintf_REQUIRED_ARGC 2
#define g_strdup_vprintf_OPTIONAL_ARGC 0
/* g_strdup_vprintf
 *
 * Parameters:
 * - format: const char *
 * - args: int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strdup_vprintf(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;
  mrb_int native_args;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_format, &native_args);

  /* Invocation */
  gchar * native_return_value = g_strdup_vprintf(native_format, native_args);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strdupv_FUNCTION
#define g_strdupv_REQUIRED_ARGC 1
#define g_strdupv_OPTIONAL_ARGC 0
/* g_strdupv
 *
 * Parameters:
 * - str_array: char **
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_strdupv(mrb_state* mrb, mrb_value self) {
  mrb_value str_array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &str_array);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(str_array);

  /* Unbox parameters */
  char ** native_str_array = TODO_mruby_unbox_char_PTR_PTR(str_array);

  /* Invocation */
  gchar ** native_return_value = g_strdupv(native_str_array);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strerror_FUNCTION
#define g_strerror_REQUIRED_ARGC 1
#define g_strerror_OPTIONAL_ARGC 0
/* g_strerror
 *
 * Parameters:
 * - errnum: int
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_strerror(mrb_state* mrb, mrb_value self) {
  mrb_int native_errnum;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_errnum);

  /* Invocation */
  const gchar * native_return_value = g_strerror(native_errnum);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strescape_FUNCTION
#define g_strescape_REQUIRED_ARGC 2
#define g_strescape_OPTIONAL_ARGC 0
/* g_strescape
 *
 * Parameters:
 * - source: const char *
 * - exceptions: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strescape(mrb_state* mrb, mrb_value self) {
  char * native_source = NULL;
  char * native_exceptions = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_source, &native_exceptions);

  /* Invocation */
  gchar * native_return_value = g_strescape(native_source, native_exceptions);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strfreev_FUNCTION
#define g_strfreev_REQUIRED_ARGC 1
#define g_strfreev_OPTIONAL_ARGC 0
/* g_strfreev
 *
 * Parameters:
 * - str_array: char **
 * Return Type: void
 */
mrb_value
mrb_GLib_g_strfreev(mrb_state* mrb, mrb_value self) {
  mrb_value str_array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &str_array);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(str_array);

  /* Unbox parameters */
  char ** native_str_array = TODO_mruby_unbox_char_PTR_PTR(str_array);

  /* Invocation */
  g_strfreev(native_str_array);

  return mrb_nil_value();
}
#endif

#if BIND_g_string_append_FUNCTION
#define g_string_append_REQUIRED_ARGC 2
#define g_string_append_OPTIONAL_ARGC 0
/* g_string_append
 *
 * Parameters:
 * - string: struct _GString *
 * - val: const char *
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_append(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_val = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &string, &native_val);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_append(native_string, native_val);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_append_c_FUNCTION
#define g_string_append_c_REQUIRED_ARGC 2
#define g_string_append_c_OPTIONAL_ARGC 0
/* g_string_append_c
 *
 * Parameters:
 * - string: struct _GString *
 * - c: char
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_append_c(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &string, &native_c);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_append_c(native_string, native_c);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_append_c_inline_FUNCTION
#define g_string_append_c_inline_REQUIRED_ARGC 2
#define g_string_append_c_inline_OPTIONAL_ARGC 0
/* g_string_append_c_inline
 *
 * Parameters:
 * - gstring: struct _GString *
 * - c: char
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_append_c_inline(mrb_state* mrb, mrb_value self) {
  mrb_value gstring;
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &gstring, &native_c);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, gstring, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_gstring = (mrb_nil_p(gstring) ? NULL : mruby_unbox__GString(gstring));

  /* Invocation */
  GString * native_return_value = g_string_append_c_inline(native_gstring, native_c);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_append_len_FUNCTION
#define g_string_append_len_REQUIRED_ARGC 3
#define g_string_append_len_OPTIONAL_ARGC 0
/* g_string_append_len
 *
 * Parameters:
 * - string: struct _GString *
 * - val: const char *
 * - len: long
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_append_len(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_val = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &string, &native_val, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_append_len(native_string, native_val, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_append_printf_FUNCTION
#define g_string_append_printf_REQUIRED_ARGC 2
#define g_string_append_printf_OPTIONAL_ARGC 0
/* g_string_append_printf
 *
 * Parameters:
 * - string: struct _GString *
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_string_append_printf(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &string, &native_format);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  g_string_append_printf(native_string, native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_string_append_unichar_FUNCTION
#define g_string_append_unichar_REQUIRED_ARGC 2
#define g_string_append_unichar_OPTIONAL_ARGC 0
/* g_string_append_unichar
 *
 * Parameters:
 * - string: struct _GString *
 * - wc: unsigned int
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_append_unichar(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_wc;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &string, &native_wc);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_append_unichar(native_string, native_wc);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_append_uri_escaped_FUNCTION
#define g_string_append_uri_escaped_REQUIRED_ARGC 4
#define g_string_append_uri_escaped_OPTIONAL_ARGC 0
/* g_string_append_uri_escaped
 *
 * Parameters:
 * - string: struct _GString *
 * - unescaped: const char *
 * - reserved_chars_allowed: const char *
 * - allow_utf8: int
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_append_uri_escaped(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_unescaped = NULL;
  char * native_reserved_chars_allowed = NULL;
  mrb_int native_allow_utf8;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!i", &string, &native_unescaped, &native_reserved_chars_allowed, &native_allow_utf8);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_append_uri_escaped(native_string, native_unescaped, native_reserved_chars_allowed, native_allow_utf8);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_append_vprintf_FUNCTION
#define g_string_append_vprintf_REQUIRED_ARGC 3
#define g_string_append_vprintf_OPTIONAL_ARGC 0
/* g_string_append_vprintf
 *
 * Parameters:
 * - string: struct _GString *
 * - format: const char *
 * - args: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_string_append_vprintf(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_format = NULL;
  mrb_int native_args;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &string, &native_format, &native_args);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  g_string_append_vprintf(native_string, native_format, native_args);

  return mrb_nil_value();
}
#endif

#if BIND_g_string_ascii_down_FUNCTION
#define g_string_ascii_down_REQUIRED_ARGC 1
#define g_string_ascii_down_OPTIONAL_ARGC 0
/* g_string_ascii_down
 *
 * Parameters:
 * - string: struct _GString *
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_ascii_down(mrb_state* mrb, mrb_value self) {
  mrb_value string;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_ascii_down(native_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_ascii_up_FUNCTION
#define g_string_ascii_up_REQUIRED_ARGC 1
#define g_string_ascii_up_OPTIONAL_ARGC 0
/* g_string_ascii_up
 *
 * Parameters:
 * - string: struct _GString *
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_ascii_up(mrb_state* mrb, mrb_value self) {
  mrb_value string;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_ascii_up(native_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_assign_FUNCTION
#define g_string_assign_REQUIRED_ARGC 2
#define g_string_assign_OPTIONAL_ARGC 0
/* g_string_assign
 *
 * Parameters:
 * - string: struct _GString *
 * - rval: const char *
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_assign(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_rval = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &string, &native_rval);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_assign(native_string, native_rval);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_chunk_clear_FUNCTION
#define g_string_chunk_clear_REQUIRED_ARGC 1
#define g_string_chunk_clear_OPTIONAL_ARGC 0
/* g_string_chunk_clear
 *
 * Parameters:
 * - chunk: struct _GStringChunk *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_string_chunk_clear(mrb_state* mrb, mrb_value self) {
  mrb_value chunk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &chunk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, chunk, GStringChunk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GStringChunk expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GStringChunk * native_chunk = (mrb_nil_p(chunk) ? NULL : mruby_unbox__GStringChunk(chunk));

  /* Invocation */
  g_string_chunk_clear(native_chunk);

  return mrb_nil_value();
}
#endif

#if BIND_g_string_chunk_free_FUNCTION
#define g_string_chunk_free_REQUIRED_ARGC 1
#define g_string_chunk_free_OPTIONAL_ARGC 0
/* g_string_chunk_free
 *
 * Parameters:
 * - chunk: struct _GStringChunk *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_string_chunk_free(mrb_state* mrb, mrb_value self) {
  mrb_value chunk;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &chunk);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, chunk, GStringChunk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GStringChunk expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GStringChunk * native_chunk = (mrb_nil_p(chunk) ? NULL : mruby_unbox__GStringChunk(chunk));

  /* Invocation */
  g_string_chunk_free(native_chunk);

  return mrb_nil_value();
}
#endif

#if BIND_g_string_chunk_insert_FUNCTION
#define g_string_chunk_insert_REQUIRED_ARGC 2
#define g_string_chunk_insert_OPTIONAL_ARGC 0
/* g_string_chunk_insert
 *
 * Parameters:
 * - chunk: struct _GStringChunk *
 * - string: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_string_chunk_insert(mrb_state* mrb, mrb_value self) {
  mrb_value chunk;
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &chunk, &native_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, chunk, GStringChunk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GStringChunk expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GStringChunk * native_chunk = (mrb_nil_p(chunk) ? NULL : mruby_unbox__GStringChunk(chunk));

  /* Invocation */
  gchar * native_return_value = g_string_chunk_insert(native_chunk, native_string);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_string_chunk_insert_const_FUNCTION
#define g_string_chunk_insert_const_REQUIRED_ARGC 2
#define g_string_chunk_insert_const_OPTIONAL_ARGC 0
/* g_string_chunk_insert_const
 *
 * Parameters:
 * - chunk: struct _GStringChunk *
 * - string: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_string_chunk_insert_const(mrb_state* mrb, mrb_value self) {
  mrb_value chunk;
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &chunk, &native_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, chunk, GStringChunk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GStringChunk expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GStringChunk * native_chunk = (mrb_nil_p(chunk) ? NULL : mruby_unbox__GStringChunk(chunk));

  /* Invocation */
  gchar * native_return_value = g_string_chunk_insert_const(native_chunk, native_string);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_string_chunk_insert_len_FUNCTION
#define g_string_chunk_insert_len_REQUIRED_ARGC 3
#define g_string_chunk_insert_len_OPTIONAL_ARGC 0
/* g_string_chunk_insert_len
 *
 * Parameters:
 * - chunk: struct _GStringChunk *
 * - string: const char *
 * - len: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_string_chunk_insert_len(mrb_state* mrb, mrb_value self) {
  mrb_value chunk;
  char * native_string = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &chunk, &native_string, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, chunk, GStringChunk_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GStringChunk expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GStringChunk * native_chunk = (mrb_nil_p(chunk) ? NULL : mruby_unbox__GStringChunk(chunk));

  /* Invocation */
  gchar * native_return_value = g_string_chunk_insert_len(native_chunk, native_string, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_string_chunk_new_FUNCTION
#define g_string_chunk_new_REQUIRED_ARGC 1
#define g_string_chunk_new_OPTIONAL_ARGC 0
/* g_string_chunk_new
 *
 * Parameters:
 * - size: unsigned long
 * Return Type: GStringChunk *
 */
mrb_value
mrb_GLib_g_string_chunk_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_size;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_size);

  /* Invocation */
  GStringChunk * native_return_value = g_string_chunk_new(native_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GStringChunk(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_down_FUNCTION
#define g_string_down_REQUIRED_ARGC 1
#define g_string_down_OPTIONAL_ARGC 0
/* g_string_down
 *
 * Parameters:
 * - string: struct _GString *
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_down(mrb_state* mrb, mrb_value self) {
  mrb_value string;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_down(native_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_equal_FUNCTION
#define g_string_equal_REQUIRED_ARGC 2
#define g_string_equal_OPTIONAL_ARGC 0
/* g_string_equal
 *
 * Parameters:
 * - v: const struct _GString *
 * - v2: const struct _GString *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_string_equal(mrb_state* mrb, mrb_value self) {
  mrb_value v;
  mrb_value v2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &v, &v2);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, v, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, v2, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GString * native_v = (mrb_nil_p(v) ? NULL : mruby_unbox__GString(v));

  const struct _GString * native_v2 = (mrb_nil_p(v2) ? NULL : mruby_unbox__GString(v2));

  /* Invocation */
  gboolean native_return_value = g_string_equal(native_v, native_v2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_string_erase_FUNCTION
#define g_string_erase_REQUIRED_ARGC 3
#define g_string_erase_OPTIONAL_ARGC 0
/* g_string_erase
 *
 * Parameters:
 * - string: struct _GString *
 * - pos: long
 * - len: long
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_erase(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_pos;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &string, &native_pos, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_erase(native_string, native_pos, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_free_FUNCTION
#define g_string_free_REQUIRED_ARGC 2
#define g_string_free_OPTIONAL_ARGC 0
/* g_string_free
 *
 * Parameters:
 * - string: struct _GString *
 * - free_segment: int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_string_free(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_free_segment;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &string, &native_free_segment);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  gchar * native_return_value = g_string_free(native_string, native_free_segment);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_string_free_to_bytes_FUNCTION
#define g_string_free_to_bytes_REQUIRED_ARGC 1
#define g_string_free_to_bytes_OPTIONAL_ARGC 0
/* g_string_free_to_bytes
 *
 * Parameters:
 * - string: struct _GString *
 * Return Type: GBytes *
 */
mrb_value
mrb_GLib_g_string_free_to_bytes(mrb_state* mrb, mrb_value self) {
  mrb_value string;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GBytes * native_return_value = g_string_free_to_bytes(native_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBytes(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_hash_FUNCTION
#define g_string_hash_REQUIRED_ARGC 1
#define g_string_hash_OPTIONAL_ARGC 0
/* g_string_hash
 *
 * Parameters:
 * - str: const struct _GString *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_string_hash(mrb_state* mrb, mrb_value self) {
  mrb_value str;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &str);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, str, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GString * native_str = (mrb_nil_p(str) ? NULL : mruby_unbox__GString(str));

  /* Invocation */
  guint native_return_value = g_string_hash(native_str);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_string_insert_FUNCTION
#define g_string_insert_REQUIRED_ARGC 3
#define g_string_insert_OPTIONAL_ARGC 0
/* g_string_insert
 *
 * Parameters:
 * - string: struct _GString *
 * - pos: long
 * - val: const char *
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_insert(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_pos;
  char * native_val = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz!", &string, &native_pos, &native_val);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_insert(native_string, native_pos, native_val);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_insert_c_FUNCTION
#define g_string_insert_c_REQUIRED_ARGC 3
#define g_string_insert_c_OPTIONAL_ARGC 0
/* g_string_insert_c
 *
 * Parameters:
 * - string: struct _GString *
 * - pos: long
 * - c: char
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_insert_c(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_pos;
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &string, &native_pos, &native_c);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_insert_c(native_string, native_pos, native_c);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_insert_len_FUNCTION
#define g_string_insert_len_REQUIRED_ARGC 4
#define g_string_insert_len_OPTIONAL_ARGC 0
/* g_string_insert_len
 *
 * Parameters:
 * - string: struct _GString *
 * - pos: long
 * - val: const char *
 * - len: long
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_insert_len(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_pos;
  char * native_val = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz!i", &string, &native_pos, &native_val, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_insert_len(native_string, native_pos, native_val, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_insert_unichar_FUNCTION
#define g_string_insert_unichar_REQUIRED_ARGC 3
#define g_string_insert_unichar_OPTIONAL_ARGC 0
/* g_string_insert_unichar
 *
 * Parameters:
 * - string: struct _GString *
 * - pos: long
 * - wc: unsigned int
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_insert_unichar(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_pos;
  mrb_int native_wc;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &string, &native_pos, &native_wc);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_insert_unichar(native_string, native_pos, native_wc);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_new_FUNCTION
#define g_string_new_REQUIRED_ARGC 1
#define g_string_new_OPTIONAL_ARGC 0
/* g_string_new
 *
 * Parameters:
 * - init: const char *
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_new(mrb_state* mrb, mrb_value self) {
  char * native_init = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_init);

  /* Invocation */
  GString * native_return_value = g_string_new(native_init);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_new_len_FUNCTION
#define g_string_new_len_REQUIRED_ARGC 2
#define g_string_new_len_OPTIONAL_ARGC 0
/* g_string_new_len
 *
 * Parameters:
 * - init: const char *
 * - len: long
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_new_len(mrb_state* mrb, mrb_value self) {
  char * native_init = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_init, &native_len);

  /* Invocation */
  GString * native_return_value = g_string_new_len(native_init, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_overwrite_FUNCTION
#define g_string_overwrite_REQUIRED_ARGC 3
#define g_string_overwrite_OPTIONAL_ARGC 0
/* g_string_overwrite
 *
 * Parameters:
 * - string: struct _GString *
 * - pos: unsigned long
 * - val: const char *
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_overwrite(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_pos;
  char * native_val = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz!", &string, &native_pos, &native_val);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_overwrite(native_string, native_pos, native_val);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_overwrite_len_FUNCTION
#define g_string_overwrite_len_REQUIRED_ARGC 4
#define g_string_overwrite_len_OPTIONAL_ARGC 0
/* g_string_overwrite_len
 *
 * Parameters:
 * - string: struct _GString *
 * - pos: unsigned long
 * - val: const char *
 * - len: long
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_overwrite_len(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_pos;
  char * native_val = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz!i", &string, &native_pos, &native_val, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_overwrite_len(native_string, native_pos, native_val, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_prepend_FUNCTION
#define g_string_prepend_REQUIRED_ARGC 2
#define g_string_prepend_OPTIONAL_ARGC 0
/* g_string_prepend
 *
 * Parameters:
 * - string: struct _GString *
 * - val: const char *
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_prepend(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_val = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &string, &native_val);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_prepend(native_string, native_val);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_prepend_c_FUNCTION
#define g_string_prepend_c_REQUIRED_ARGC 2
#define g_string_prepend_c_OPTIONAL_ARGC 0
/* g_string_prepend_c
 *
 * Parameters:
 * - string: struct _GString *
 * - c: char
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_prepend_c(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &string, &native_c);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_prepend_c(native_string, native_c);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_prepend_len_FUNCTION
#define g_string_prepend_len_REQUIRED_ARGC 3
#define g_string_prepend_len_OPTIONAL_ARGC 0
/* g_string_prepend_len
 *
 * Parameters:
 * - string: struct _GString *
 * - val: const char *
 * - len: long
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_prepend_len(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_val = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &string, &native_val, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_prepend_len(native_string, native_val, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_prepend_unichar_FUNCTION
#define g_string_prepend_unichar_REQUIRED_ARGC 2
#define g_string_prepend_unichar_OPTIONAL_ARGC 0
/* g_string_prepend_unichar
 *
 * Parameters:
 * - string: struct _GString *
 * - wc: unsigned int
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_prepend_unichar(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_wc;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &string, &native_wc);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_prepend_unichar(native_string, native_wc);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_printf_FUNCTION
#define g_string_printf_REQUIRED_ARGC 2
#define g_string_printf_OPTIONAL_ARGC 0
/* g_string_printf
 *
 * Parameters:
 * - string: struct _GString *
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_string_printf(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &string, &native_format);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  g_string_printf(native_string, native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_string_set_size_FUNCTION
#define g_string_set_size_REQUIRED_ARGC 2
#define g_string_set_size_OPTIONAL_ARGC 0
/* g_string_set_size
 *
 * Parameters:
 * - string: struct _GString *
 * - len: unsigned long
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_set_size(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &string, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_set_size(native_string, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_sized_new_FUNCTION
#define g_string_sized_new_REQUIRED_ARGC 1
#define g_string_sized_new_OPTIONAL_ARGC 0
/* g_string_sized_new
 *
 * Parameters:
 * - dfl_size: unsigned long
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_sized_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_dfl_size;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_dfl_size);

  /* Invocation */
  GString * native_return_value = g_string_sized_new(native_dfl_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_truncate_FUNCTION
#define g_string_truncate_REQUIRED_ARGC 2
#define g_string_truncate_OPTIONAL_ARGC 0
/* g_string_truncate
 *
 * Parameters:
 * - string: struct _GString *
 * - len: unsigned long
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_truncate(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &string, &native_len);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_truncate(native_string, native_len);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_up_FUNCTION
#define g_string_up_REQUIRED_ARGC 1
#define g_string_up_OPTIONAL_ARGC 0
/* g_string_up
 *
 * Parameters:
 * - string: struct _GString *
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_string_up(mrb_state* mrb, mrb_value self) {
  mrb_value string;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_string_up(native_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_string_vprintf_FUNCTION
#define g_string_vprintf_REQUIRED_ARGC 3
#define g_string_vprintf_OPTIONAL_ARGC 0
/* g_string_vprintf
 *
 * Parameters:
 * - string: struct _GString *
 * - format: const char *
 * - args: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_string_vprintf(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_format = NULL;
  mrb_int native_args;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &string, &native_format, &native_args);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  g_string_vprintf(native_string, native_format, native_args);

  return mrb_nil_value();
}
#endif

#if BIND_g_strip_context_FUNCTION
#define g_strip_context_REQUIRED_ARGC 2
#define g_strip_context_OPTIONAL_ARGC 0
/* g_strip_context
 *
 * Parameters:
 * - msgid: const char *
 * - msgval: const char *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_strip_context(mrb_state* mrb, mrb_value self) {
  char * native_msgid = NULL;
  char * native_msgval = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_msgid, &native_msgval);

  /* Invocation */
  const gchar * native_return_value = g_strip_context(native_msgid, native_msgval);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strjoin_FUNCTION
#define g_strjoin_REQUIRED_ARGC 1
#define g_strjoin_OPTIONAL_ARGC 0
/* g_strjoin
 *
 * Parameters:
 * - separator: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strjoin(mrb_state* mrb, mrb_value self) {
  char * native_separator = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_separator);

  /* Invocation */
  gchar * native_return_value = g_strjoin(native_separator);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strjoinv_FUNCTION
#define g_strjoinv_REQUIRED_ARGC 2
#define g_strjoinv_OPTIONAL_ARGC 0
/* g_strjoinv
 *
 * Parameters:
 * - separator: const char *
 * - str_array: char **
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strjoinv(mrb_state* mrb, mrb_value self) {
  char * native_separator = NULL;
  mrb_value str_array;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_separator, &str_array);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(str_array);

  /* Unbox parameters */
  char ** native_str_array = TODO_mruby_unbox_char_PTR_PTR(str_array);

  /* Invocation */
  gchar * native_return_value = g_strjoinv(native_separator, native_str_array);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strlcat_FUNCTION
#define g_strlcat_REQUIRED_ARGC 3
#define g_strlcat_OPTIONAL_ARGC 0
/* g_strlcat
 *
 * Parameters:
 * - dest: char *
 * - src: const char *
 * - dest_size: unsigned long
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_strlcat(mrb_state* mrb, mrb_value self) {
  char * dest = NULL;
  char * native_src = NULL;
  mrb_int native_dest_size;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &dest, &native_src, &native_dest_size);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_dest = strdup(dest);

  /* Invocation */
  gsize native_return_value = g_strlcat(native_dest, native_src, native_dest_size);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_dest);
  native_dest = NULL;

  return return_value;
}
#endif

#if BIND_g_strlcpy_FUNCTION
#define g_strlcpy_REQUIRED_ARGC 3
#define g_strlcpy_OPTIONAL_ARGC 0
/* g_strlcpy
 *
 * Parameters:
 * - dest: char *
 * - src: const char *
 * - dest_size: unsigned long
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_strlcpy(mrb_state* mrb, mrb_value self) {
  char * dest = NULL;
  char * native_src = NULL;
  mrb_int native_dest_size;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &dest, &native_src, &native_dest_size);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_dest = strdup(dest);

  /* Invocation */
  gsize native_return_value = g_strlcpy(native_dest, native_src, native_dest_size);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_dest);
  native_dest = NULL;

  return return_value;
}
#endif

#if BIND_g_strncasecmp_FUNCTION
#define g_strncasecmp_REQUIRED_ARGC 3
#define g_strncasecmp_OPTIONAL_ARGC 0
/* g_strncasecmp
 *
 * Parameters:
 * - s1: const char *
 * - s2: const char *
 * - n: unsigned int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_strncasecmp(mrb_state* mrb, mrb_value self) {
  char * native_s1 = NULL;
  char * native_s2 = NULL;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &native_s1, &native_s2, &native_n);

  /* Invocation */
  gint native_return_value = g_strncasecmp(native_s1, native_s2, native_n);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strndup_FUNCTION
#define g_strndup_REQUIRED_ARGC 2
#define g_strndup_OPTIONAL_ARGC 0
/* g_strndup
 *
 * Parameters:
 * - str: const char *
 * - n: unsigned long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strndup(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_str, &native_n);

  /* Invocation */
  gchar * native_return_value = g_strndup(native_str, native_n);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strnfill_FUNCTION
#define g_strnfill_REQUIRED_ARGC 2
#define g_strnfill_OPTIONAL_ARGC 0
/* g_strnfill
 *
 * Parameters:
 * - length: unsigned long
 * - fill_char: char
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strnfill(mrb_state* mrb, mrb_value self) {
  mrb_int native_length;
  mrb_int native_fill_char;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_length, &native_fill_char);

  /* Invocation */
  gchar * native_return_value = g_strnfill(native_length, native_fill_char);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strreverse_FUNCTION
#define g_strreverse_REQUIRED_ARGC 1
#define g_strreverse_OPTIONAL_ARGC 0
/* g_strreverse
 *
 * Parameters:
 * - string: char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strreverse(mrb_state* mrb, mrb_value self) {
  char * string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &string);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  gchar * native_return_value = g_strreverse(native_string);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_strrstr_FUNCTION
#define g_strrstr_REQUIRED_ARGC 2
#define g_strrstr_OPTIONAL_ARGC 0
/* g_strrstr
 *
 * Parameters:
 * - haystack: const char *
 * - needle: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strrstr(mrb_state* mrb, mrb_value self) {
  char * native_haystack = NULL;
  char * native_needle = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_haystack, &native_needle);

  /* Invocation */
  gchar * native_return_value = g_strrstr(native_haystack, native_needle);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strrstr_len_FUNCTION
#define g_strrstr_len_REQUIRED_ARGC 3
#define g_strrstr_len_OPTIONAL_ARGC 0
/* g_strrstr_len
 *
 * Parameters:
 * - haystack: const char *
 * - haystack_len: long
 * - needle: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strrstr_len(mrb_state* mrb, mrb_value self) {
  char * native_haystack = NULL;
  mrb_int native_haystack_len;
  char * native_needle = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!", &native_haystack, &native_haystack_len, &native_needle);

  /* Invocation */
  gchar * native_return_value = g_strrstr_len(native_haystack, native_haystack_len, native_needle);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strsignal_FUNCTION
#define g_strsignal_REQUIRED_ARGC 1
#define g_strsignal_OPTIONAL_ARGC 0
/* g_strsignal
 *
 * Parameters:
 * - signum: int
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_strsignal(mrb_state* mrb, mrb_value self) {
  mrb_int native_signum;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_signum);

  /* Invocation */
  const gchar * native_return_value = g_strsignal(native_signum);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strsplit_FUNCTION
#define g_strsplit_REQUIRED_ARGC 3
#define g_strsplit_OPTIONAL_ARGC 0
/* g_strsplit
 *
 * Parameters:
 * - string: const char *
 * - delimiter: const char *
 * - max_tokens: int
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_strsplit(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;
  char * native_delimiter = NULL;
  mrb_int native_max_tokens;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &native_string, &native_delimiter, &native_max_tokens);

  /* Invocation */
  gchar ** native_return_value = g_strsplit(native_string, native_delimiter, native_max_tokens);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strsplit_set_FUNCTION
#define g_strsplit_set_REQUIRED_ARGC 3
#define g_strsplit_set_OPTIONAL_ARGC 0
/* g_strsplit_set
 *
 * Parameters:
 * - string: const char *
 * - delimiters: const char *
 * - max_tokens: int
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_strsplit_set(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;
  char * native_delimiters = NULL;
  mrb_int native_max_tokens;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &native_string, &native_delimiters, &native_max_tokens);

  /* Invocation */
  gchar ** native_return_value = g_strsplit_set(native_string, native_delimiters, native_max_tokens);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strstr_len_FUNCTION
#define g_strstr_len_REQUIRED_ARGC 3
#define g_strstr_len_OPTIONAL_ARGC 0
/* g_strstr_len
 *
 * Parameters:
 * - haystack: const char *
 * - haystack_len: long
 * - needle: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strstr_len(mrb_state* mrb, mrb_value self) {
  char * native_haystack = NULL;
  mrb_int native_haystack_len;
  char * native_needle = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!", &native_haystack, &native_haystack_len, &native_needle);

  /* Invocation */
  gchar * native_return_value = g_strstr_len(native_haystack, native_haystack_len, native_needle);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strtod_FUNCTION
#define g_strtod_REQUIRED_ARGC 2
#define g_strtod_OPTIONAL_ARGC 0
/* g_strtod
 *
 * Parameters:
 * - nptr: const char *
 * - endptr: char **
 * Return Type: gdouble
 */
mrb_value
mrb_GLib_g_strtod(mrb_state* mrb, mrb_value self) {
  char * native_nptr = NULL;
  mrb_value endptr;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_nptr, &endptr);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(endptr);

  /* Unbox parameters */
  char ** native_endptr = TODO_mruby_unbox_char_PTR_PTR(endptr);

  /* Invocation */
  gdouble native_return_value = g_strtod(native_nptr, native_endptr);

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strup_FUNCTION
#define g_strup_REQUIRED_ARGC 1
#define g_strup_OPTIONAL_ARGC 0
/* g_strup
 *
 * Parameters:
 * - string: char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_strup(mrb_state* mrb, mrb_value self) {
  char * string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &string);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  gchar * native_return_value = g_strup(native_string);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_strv_contains_FUNCTION
#define g_strv_contains_REQUIRED_ARGC 2
#define g_strv_contains_OPTIONAL_ARGC 0
/* g_strv_contains
 *
 * Parameters:
 * - strv: const char *const *
 * - str: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_strv_contains(mrb_state* mrb, mrb_value self) {
  mrb_value strv;
  char * native_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &strv, &native_str);

  /* Type checking */
  TODO_type_check_char_PTR_const_PTR(strv);

  /* Unbox parameters */
  const char *const * native_strv = TODO_mruby_unbox_char_PTR_const_PTR(strv);

  /* Invocation */
  gboolean native_return_value = g_strv_contains(native_strv, native_str);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_strv_length_FUNCTION
#define g_strv_length_REQUIRED_ARGC 1
#define g_strv_length_OPTIONAL_ARGC 0
/* g_strv_length
 *
 * Parameters:
 * - str_array: char **
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_strv_length(mrb_state* mrb, mrb_value self) {
  mrb_value str_array;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &str_array);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(str_array);

  /* Unbox parameters */
  char ** native_str_array = TODO_mruby_unbox_char_PTR_PTR(str_array);

  /* Invocation */
  guint native_return_value = g_strv_length(native_str_array);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_add_data_func_FUNCTION
#define g_test_add_data_func_REQUIRED_ARGC 3
#define g_test_add_data_func_OPTIONAL_ARGC 0
/* g_test_add_data_func
 *
 * Parameters:
 * - testpath: const char *
 * - test_data: const void *
 * - test_func: void (*)(const void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_add_data_func(mrb_state* mrb, mrb_value self) {
  char * native_testpath = NULL;
  mrb_value test_data;
  mrb_value test_func;

  /* Fetch the args */
  mrb_get_args(mrb, "z!oo", &native_testpath, &test_data, &test_func);

  /* Type checking */
  TODO_type_check_void_PTR(test_data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(test_func);

  /* Unbox parameters */
  const void * native_test_data = TODO_mruby_unbox_void_PTR(test_data);

  void (*native_test_func)(const void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(test_func);

  /* Invocation */
  g_test_add_data_func(native_testpath, native_test_data, native_test_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_add_data_func_full_FUNCTION
#define g_test_add_data_func_full_REQUIRED_ARGC 4
#define g_test_add_data_func_full_OPTIONAL_ARGC 0
/* g_test_add_data_func_full
 *
 * Parameters:
 * - testpath: const char *
 * - test_data: void *
 * - test_func: void (*)(const void *)
 * - data_free_func: void (*)(void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_add_data_func_full(mrb_state* mrb, mrb_value self) {
  char * native_testpath = NULL;
  mrb_value test_data;
  mrb_value test_func;
  mrb_value data_free_func;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ooo", &native_testpath, &test_data, &test_func, &data_free_func);

  /* Type checking */
  TODO_type_check_void_PTR(test_data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(test_func);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(data_free_func);

  /* Unbox parameters */
  void * native_test_data = TODO_mruby_unbox_void_PTR(test_data);

  void (*native_test_func)(const void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(test_func);

  void (*native_data_free_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(data_free_func);

  /* Invocation */
  g_test_add_data_func_full(native_testpath, native_test_data, native_test_func, native_data_free_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_add_func_FUNCTION
#define g_test_add_func_REQUIRED_ARGC 2
#define g_test_add_func_OPTIONAL_ARGC 0
/* g_test_add_func
 *
 * Parameters:
 * - testpath: const char *
 * - test_func: void (*)(void)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_add_func(mrb_state* mrb, mrb_value self) {
  char * native_testpath = NULL;
  mrb_value test_func;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_testpath, &test_func);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_RPAREN(test_func);

  /* Unbox parameters */
  void (*native_test_func)(void) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_RPAREN(test_func);

  /* Invocation */
  g_test_add_func(native_testpath, native_test_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_add_vtable_FUNCTION
#define g_test_add_vtable_REQUIRED_ARGC 6
#define g_test_add_vtable_OPTIONAL_ARGC 0
/* g_test_add_vtable
 *
 * Parameters:
 * - testpath: const char *
 * - data_size: unsigned long
 * - test_data: const void *
 * - data_setup: void (*)(void *, const void *)
 * - data_test: void (*)(void *, const void *)
 * - data_teardown: void (*)(void *, const void *)
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_add_vtable(mrb_state* mrb, mrb_value self) {
  char * native_testpath = NULL;
  mrb_int native_data_size;
  mrb_value test_data;
  mrb_value data_setup;
  mrb_value data_test;
  mrb_value data_teardown;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ioooo", &native_testpath, &native_data_size, &test_data, &data_setup, &data_test, &data_teardown);

  /* Type checking */
  TODO_type_check_void_PTR(test_data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_setup);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_test);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_teardown);

  /* Unbox parameters */
  const void * native_test_data = TODO_mruby_unbox_void_PTR(test_data);

  void (*native_data_setup)(void *, const void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_setup);

  void (*native_data_test)(void *, const void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_test);

  void (*native_data_teardown)(void *, const void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_teardown);

  /* Invocation */
  g_test_add_vtable(native_testpath, native_data_size, native_test_data, native_data_setup, native_data_test, native_data_teardown);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_assert_expected_messages_internal_FUNCTION
#define g_test_assert_expected_messages_internal_REQUIRED_ARGC 4
#define g_test_assert_expected_messages_internal_OPTIONAL_ARGC 0
/* g_test_assert_expected_messages_internal
 *
 * Parameters:
 * - domain: const char *
 * - file: const char *
 * - line: int
 * - func: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_assert_expected_messages_internal(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_file = NULL;
  mrb_int native_line;
  char * native_func = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!iz!", &native_domain, &native_file, &native_line, &native_func);

  /* Invocation */
  g_test_assert_expected_messages_internal(native_domain, native_file, native_line, native_func);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_bug_FUNCTION
#define g_test_bug_REQUIRED_ARGC 1
#define g_test_bug_OPTIONAL_ARGC 0
/* g_test_bug
 *
 * Parameters:
 * - bug_uri_snippet: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_bug(mrb_state* mrb, mrb_value self) {
  char * native_bug_uri_snippet = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_bug_uri_snippet);

  /* Invocation */
  g_test_bug(native_bug_uri_snippet);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_bug_base_FUNCTION
#define g_test_bug_base_REQUIRED_ARGC 1
#define g_test_bug_base_OPTIONAL_ARGC 0
/* g_test_bug_base
 *
 * Parameters:
 * - uri_pattern: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_bug_base(mrb_state* mrb, mrb_value self) {
  char * native_uri_pattern = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_uri_pattern);

  /* Invocation */
  g_test_bug_base(native_uri_pattern);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_build_filename_FUNCTION
#define g_test_build_filename_REQUIRED_ARGC 2
#define g_test_build_filename_OPTIONAL_ARGC 0
/* g_test_build_filename
 *
 * Parameters:
 * - file_type: GTestFileType
 * - first_path: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_test_build_filename(mrb_state* mrb, mrb_value self) {
  mrb_int native_file_type;
  char * native_first_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "iz!", &native_file_type, &native_first_path);

  /* Invocation */
  gchar * native_return_value = g_test_build_filename(native_file_type, native_first_path);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_create_case_FUNCTION
#define g_test_create_case_REQUIRED_ARGC 6
#define g_test_create_case_OPTIONAL_ARGC 0
/* g_test_create_case
 *
 * Parameters:
 * - test_name: const char *
 * - data_size: unsigned long
 * - test_data: const void *
 * - data_setup: void (*)(void *, const void *)
 * - data_test: void (*)(void *, const void *)
 * - data_teardown: void (*)(void *, const void *)
 * Return Type: GTestCase *
 */
mrb_value
mrb_GLib_g_test_create_case(mrb_state* mrb, mrb_value self) {
  char * native_test_name = NULL;
  mrb_int native_data_size;
  mrb_value test_data;
  mrb_value data_setup;
  mrb_value data_test;
  mrb_value data_teardown;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ioooo", &native_test_name, &native_data_size, &test_data, &data_setup, &data_test, &data_teardown);

  /* Type checking */
  TODO_type_check_void_PTR(test_data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_setup);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_test);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_teardown);

  /* Unbox parameters */
  const void * native_test_data = TODO_mruby_unbox_void_PTR(test_data);

  void (*native_data_setup)(void *, const void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_setup);

  void (*native_data_test)(void *, const void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_test);

  void (*native_data_teardown)(void *, const void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMAvoid_PTR_RPAREN(data_teardown);

  /* Invocation */
  GTestCase * native_return_value = g_test_create_case(native_test_name, native_data_size, native_test_data, native_data_setup, native_data_test, native_data_teardown);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_GTestCase(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_test_create_suite_FUNCTION
#define g_test_create_suite_REQUIRED_ARGC 1
#define g_test_create_suite_OPTIONAL_ARGC 0
/* g_test_create_suite
 *
 * Parameters:
 * - suite_name: const char *
 * Return Type: GTestSuite *
 */
mrb_value
mrb_GLib_g_test_create_suite(mrb_state* mrb, mrb_value self) {
  char * native_suite_name = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_suite_name);

  /* Invocation */
  GTestSuite * native_return_value = g_test_create_suite(native_suite_name);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_GTestSuite(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_test_expect_message_FUNCTION
#define g_test_expect_message_REQUIRED_ARGC 3
#define g_test_expect_message_OPTIONAL_ARGC 0
/* g_test_expect_message
 *
 * Parameters:
 * - log_domain: const char *
 * - log_level: GLogLevelFlags
 * - pattern: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_expect_message(mrb_state* mrb, mrb_value self) {
  char * native_log_domain = NULL;
  mrb_int native_log_level;
  char * native_pattern = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!", &native_log_domain, &native_log_level, &native_pattern);

  /* Invocation */
  g_test_expect_message(native_log_domain, native_log_level, native_pattern);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_fail_FUNCTION
#define g_test_fail_REQUIRED_ARGC 0
#define g_test_fail_OPTIONAL_ARGC 0
/* g_test_fail
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_fail(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  g_test_fail();

  return mrb_nil_value();
}
#endif

#if BIND_g_test_failed_FUNCTION
#define g_test_failed_REQUIRED_ARGC 0
#define g_test_failed_OPTIONAL_ARGC 0
/* g_test_failed
 *
 * Parameters: None
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_test_failed(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gboolean native_return_value = g_test_failed();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_get_dir_FUNCTION
#define g_test_get_dir_REQUIRED_ARGC 1
#define g_test_get_dir_OPTIONAL_ARGC 0
/* g_test_get_dir
 *
 * Parameters:
 * - file_type: GTestFileType
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_test_get_dir(mrb_state* mrb, mrb_value self) {
  mrb_int native_file_type;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_file_type);

  /* Invocation */
  const gchar * native_return_value = g_test_get_dir(native_file_type);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_get_filename_FUNCTION
#define g_test_get_filename_REQUIRED_ARGC 2
#define g_test_get_filename_OPTIONAL_ARGC 0
/* g_test_get_filename
 *
 * Parameters:
 * - file_type: GTestFileType
 * - first_path: const char *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_test_get_filename(mrb_state* mrb, mrb_value self) {
  mrb_int native_file_type;
  char * native_first_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "iz!", &native_file_type, &native_first_path);

  /* Invocation */
  const gchar * native_return_value = g_test_get_filename(native_file_type, native_first_path);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_get_root_FUNCTION
#define g_test_get_root_REQUIRED_ARGC 0
#define g_test_get_root_OPTIONAL_ARGC 0
/* g_test_get_root
 *
 * Parameters: None
 * Return Type: GTestSuite *
 */
mrb_value
mrb_GLib_g_test_get_root(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GTestSuite * native_return_value = g_test_get_root();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_GTestSuite(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_test_incomplete_FUNCTION
#define g_test_incomplete_REQUIRED_ARGC 1
#define g_test_incomplete_OPTIONAL_ARGC 0
/* g_test_incomplete
 *
 * Parameters:
 * - msg: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_incomplete(mrb_state* mrb, mrb_value self) {
  char * native_msg = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_msg);

  /* Invocation */
  g_test_incomplete(native_msg);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_init_FUNCTION
#define g_test_init_REQUIRED_ARGC 2
#define g_test_init_OPTIONAL_ARGC 0
/* g_test_init
 *
 * Parameters:
 * - argc: int *
 * - argv: char ***
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_init(mrb_state* mrb, mrb_value self) {
  mrb_value argc;
  mrb_value argv;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &argc, &argv);

  /* Type checking */
  TODO_type_check_int_PTR(argc);
  TODO_type_check_char_PTR_PTR_PTR(argv);

  /* Unbox parameters */
  int * native_argc = TODO_mruby_unbox_int_PTR(argc);

  char *** native_argv = TODO_mruby_unbox_char_PTR_PTR_PTR(argv);

  /* Invocation */
  g_test_init(native_argc, native_argv);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_log_buffer_free_FUNCTION
#define g_test_log_buffer_free_REQUIRED_ARGC 1
#define g_test_log_buffer_free_OPTIONAL_ARGC 0
/* g_test_log_buffer_free
 *
 * Parameters:
 * - tbuffer: GTestLogBuffer *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_log_buffer_free(mrb_state* mrb, mrb_value self) {
  mrb_value tbuffer;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tbuffer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tbuffer, GTestLogBuffer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTestLogBuffer expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  GTestLogBuffer * native_tbuffer = (mrb_nil_p(tbuffer) ? NULL : mruby_unbox_GTestLogBuffer(tbuffer));

  /* Invocation */
  g_test_log_buffer_free(native_tbuffer);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_log_buffer_new_FUNCTION
#define g_test_log_buffer_new_REQUIRED_ARGC 0
#define g_test_log_buffer_new_OPTIONAL_ARGC 0
/* g_test_log_buffer_new
 *
 * Parameters: None
 * Return Type: GTestLogBuffer *
 */
mrb_value
mrb_GLib_g_test_log_buffer_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GTestLogBuffer * native_return_value = g_test_log_buffer_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_GTestLogBuffer(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_test_log_buffer_pop_FUNCTION
#define g_test_log_buffer_pop_REQUIRED_ARGC 1
#define g_test_log_buffer_pop_OPTIONAL_ARGC 0
/* g_test_log_buffer_pop
 *
 * Parameters:
 * - tbuffer: GTestLogBuffer *
 * Return Type: GTestLogMsg *
 */
mrb_value
mrb_GLib_g_test_log_buffer_pop(mrb_state* mrb, mrb_value self) {
  mrb_value tbuffer;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tbuffer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tbuffer, GTestLogBuffer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTestLogBuffer expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  GTestLogBuffer * native_tbuffer = (mrb_nil_p(tbuffer) ? NULL : mruby_unbox_GTestLogBuffer(tbuffer));

  /* Invocation */
  GTestLogMsg * native_return_value = g_test_log_buffer_pop(native_tbuffer);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box_GTestLogMsg(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_test_log_buffer_push_FUNCTION
#define g_test_log_buffer_push_REQUIRED_ARGC 3
#define g_test_log_buffer_push_OPTIONAL_ARGC 0
/* g_test_log_buffer_push
 *
 * Parameters:
 * - tbuffer: GTestLogBuffer *
 * - n_bytes: unsigned int
 * - bytes: const unsigned char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_log_buffer_push(mrb_state* mrb, mrb_value self) {
  mrb_value tbuffer;
  mrb_int native_n_bytes;
  mrb_value bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &tbuffer, &native_n_bytes, &bytes);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tbuffer, GTestLogBuffer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTestLogBuffer expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_char_PTR(bytes);

  /* Unbox parameters */
  GTestLogBuffer * native_tbuffer = (mrb_nil_p(tbuffer) ? NULL : mruby_unbox_GTestLogBuffer(tbuffer));

  const unsigned char * native_bytes = TODO_mruby_unbox_unsigned_char_PTR(bytes);

  /* Invocation */
  g_test_log_buffer_push(native_tbuffer, native_n_bytes, native_bytes);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_log_msg_free_FUNCTION
#define g_test_log_msg_free_REQUIRED_ARGC 1
#define g_test_log_msg_free_OPTIONAL_ARGC 0
/* g_test_log_msg_free
 *
 * Parameters:
 * - tmsg: GTestLogMsg *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_log_msg_free(mrb_state* mrb, mrb_value self) {
  mrb_value tmsg;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tmsg);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tmsg, GTestLogMsg_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTestLogMsg expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  GTestLogMsg * native_tmsg = (mrb_nil_p(tmsg) ? NULL : mruby_unbox_GTestLogMsg(tmsg));

  /* Invocation */
  g_test_log_msg_free(native_tmsg);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_log_set_fatal_handler_FUNCTION
#define g_test_log_set_fatal_handler_REQUIRED_ARGC 2
#define g_test_log_set_fatal_handler_OPTIONAL_ARGC 0
/* g_test_log_set_fatal_handler
 *
 * Parameters:
 * - log_func: int (*)(const char *, GLogLevelFlags, const char *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_log_set_fatal_handler(mrb_state* mrb, mrb_value self) {
  mrb_value log_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &log_func, &user_data);

  /* Type checking */
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_GLogLevelFlagsCOMMA_const_char_PTR_COMMA_void_PTR_RPAREN(log_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  int (*native_log_func)(const char *, GLogLevelFlags, const char *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_char_PTR_COMMA_GLogLevelFlagsCOMMA_const_char_PTR_COMMA_void_PTR_RPAREN(log_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_test_log_set_fatal_handler(native_log_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_log_type_name_FUNCTION
#define g_test_log_type_name_REQUIRED_ARGC 1
#define g_test_log_type_name_OPTIONAL_ARGC 0
/* g_test_log_type_name
 *
 * Parameters:
 * - log_type: GTestLogType
 * Return Type: const char *
 */
mrb_value
mrb_GLib_g_test_log_type_name(mrb_state* mrb, mrb_value self) {
  mrb_int native_log_type;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_log_type);

  /* Invocation */
  const char * native_return_value = g_test_log_type_name(native_log_type);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_maximized_result_FUNCTION
#define g_test_maximized_result_REQUIRED_ARGC 2
#define g_test_maximized_result_OPTIONAL_ARGC 0
/* g_test_maximized_result
 *
 * Parameters:
 * - maximized_quantity: double
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_maximized_result(mrb_state* mrb, mrb_value self) {
  double native_maximized_quantity;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "fz!", &native_maximized_quantity, &native_format);

  /* Invocation */
  g_test_maximized_result(native_maximized_quantity, native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_message_FUNCTION
#define g_test_message_REQUIRED_ARGC 1
#define g_test_message_OPTIONAL_ARGC 0
/* g_test_message
 *
 * Parameters:
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_message(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_format);

  /* Invocation */
  g_test_message(native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_minimized_result_FUNCTION
#define g_test_minimized_result_REQUIRED_ARGC 2
#define g_test_minimized_result_OPTIONAL_ARGC 0
/* g_test_minimized_result
 *
 * Parameters:
 * - minimized_quantity: double
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_minimized_result(mrb_state* mrb, mrb_value self) {
  double native_minimized_quantity;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "fz!", &native_minimized_quantity, &native_format);

  /* Invocation */
  g_test_minimized_result(native_minimized_quantity, native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_queue_destroy_FUNCTION
#define g_test_queue_destroy_REQUIRED_ARGC 2
#define g_test_queue_destroy_OPTIONAL_ARGC 0
/* g_test_queue_destroy
 *
 * Parameters:
 * - destroy_func: void (*)(void *)
 * - destroy_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_queue_destroy(mrb_state* mrb, mrb_value self) {
  mrb_value destroy_func;
  mrb_value destroy_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &destroy_func, &destroy_data);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy_func);
  TODO_type_check_void_PTR(destroy_data);

  /* Unbox parameters */
  void (*native_destroy_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(destroy_func);

  void * native_destroy_data = TODO_mruby_unbox_void_PTR(destroy_data);

  /* Invocation */
  g_test_queue_destroy(native_destroy_func, native_destroy_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_queue_free_FUNCTION
#define g_test_queue_free_REQUIRED_ARGC 1
#define g_test_queue_free_OPTIONAL_ARGC 0
/* g_test_queue_free
 *
 * Parameters:
 * - gfree_pointer: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_queue_free(mrb_state* mrb, mrb_value self) {
  mrb_value gfree_pointer;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &gfree_pointer);

  /* Type checking */
  TODO_type_check_void_PTR(gfree_pointer);

  /* Unbox parameters */
  void * native_gfree_pointer = TODO_mruby_unbox_void_PTR(gfree_pointer);

  /* Invocation */
  g_test_queue_free(native_gfree_pointer);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_rand_double_FUNCTION
#define g_test_rand_double_REQUIRED_ARGC 0
#define g_test_rand_double_OPTIONAL_ARGC 0
/* g_test_rand_double
 *
 * Parameters: None
 * Return Type: double
 */
mrb_value
mrb_GLib_g_test_rand_double(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  double native_return_value = g_test_rand_double();

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_rand_double_range_FUNCTION
#define g_test_rand_double_range_REQUIRED_ARGC 2
#define g_test_rand_double_range_OPTIONAL_ARGC 0
/* g_test_rand_double_range
 *
 * Parameters:
 * - range_start: double
 * - range_end: double
 * Return Type: double
 */
mrb_value
mrb_GLib_g_test_rand_double_range(mrb_state* mrb, mrb_value self) {
  double native_range_start;
  double native_range_end;

  /* Fetch the args */
  mrb_get_args(mrb, "ff", &native_range_start, &native_range_end);

  /* Invocation */
  double native_return_value = g_test_rand_double_range(native_range_start, native_range_end);

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_rand_int_FUNCTION
#define g_test_rand_int_REQUIRED_ARGC 0
#define g_test_rand_int_OPTIONAL_ARGC 0
/* g_test_rand_int
 *
 * Parameters: None
 * Return Type: gint32
 */
mrb_value
mrb_GLib_g_test_rand_int(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gint32 native_return_value = g_test_rand_int();

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_rand_int_range_FUNCTION
#define g_test_rand_int_range_REQUIRED_ARGC 2
#define g_test_rand_int_range_OPTIONAL_ARGC 0
/* g_test_rand_int_range
 *
 * Parameters:
 * - begin: int
 * - end: int
 * Return Type: gint32
 */
mrb_value
mrb_GLib_g_test_rand_int_range(mrb_state* mrb, mrb_value self) {
  mrb_int native_begin;
  mrb_int native_end;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_begin, &native_end);

  /* Invocation */
  gint32 native_return_value = g_test_rand_int_range(native_begin, native_end);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_run_FUNCTION
#define g_test_run_REQUIRED_ARGC 0
#define g_test_run_OPTIONAL_ARGC 0
/* g_test_run
 *
 * Parameters: None
 * Return Type: int
 */
mrb_value
mrb_GLib_g_test_run(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  int native_return_value = g_test_run();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_run_suite_FUNCTION
#define g_test_run_suite_REQUIRED_ARGC 1
#define g_test_run_suite_OPTIONAL_ARGC 0
/* g_test_run_suite
 *
 * Parameters:
 * - suite: struct GTestSuite *
 * Return Type: int
 */
mrb_value
mrb_GLib_g_test_run_suite(mrb_state* mrb, mrb_value self) {
  mrb_value suite;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &suite);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, suite, GTestSuite_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTestSuite expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct GTestSuite * native_suite = (mrb_nil_p(suite) ? NULL : mruby_unbox_GTestSuite(suite));

  /* Invocation */
  int native_return_value = g_test_run_suite(native_suite);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_set_nonfatal_assertions_FUNCTION
#define g_test_set_nonfatal_assertions_REQUIRED_ARGC 0
#define g_test_set_nonfatal_assertions_OPTIONAL_ARGC 0
/* g_test_set_nonfatal_assertions
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_set_nonfatal_assertions(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  g_test_set_nonfatal_assertions();

  return mrb_nil_value();
}
#endif

#if BIND_g_test_skip_FUNCTION
#define g_test_skip_REQUIRED_ARGC 1
#define g_test_skip_OPTIONAL_ARGC 0
/* g_test_skip
 *
 * Parameters:
 * - msg: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_skip(mrb_state* mrb, mrb_value self) {
  char * native_msg = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_msg);

  /* Invocation */
  g_test_skip(native_msg);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_subprocess_FUNCTION
#define g_test_subprocess_REQUIRED_ARGC 0
#define g_test_subprocess_OPTIONAL_ARGC 0
/* g_test_subprocess
 *
 * Parameters: None
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_test_subprocess(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gboolean native_return_value = g_test_subprocess();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_suite_add_FUNCTION
#define g_test_suite_add_REQUIRED_ARGC 2
#define g_test_suite_add_OPTIONAL_ARGC 0
/* g_test_suite_add
 *
 * Parameters:
 * - suite: struct GTestSuite *
 * - test_case: struct GTestCase *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_suite_add(mrb_state* mrb, mrb_value self) {
  mrb_value suite;
  mrb_value test_case;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &suite, &test_case);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, suite, GTestSuite_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTestSuite expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, test_case, GTestCase_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTestCase expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct GTestSuite * native_suite = (mrb_nil_p(suite) ? NULL : mruby_unbox_GTestSuite(suite));

  struct GTestCase * native_test_case = (mrb_nil_p(test_case) ? NULL : mruby_unbox_GTestCase(test_case));

  /* Invocation */
  g_test_suite_add(native_suite, native_test_case);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_suite_add_suite_FUNCTION
#define g_test_suite_add_suite_REQUIRED_ARGC 2
#define g_test_suite_add_suite_OPTIONAL_ARGC 0
/* g_test_suite_add_suite
 *
 * Parameters:
 * - suite: struct GTestSuite *
 * - nestedsuite: struct GTestSuite *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_suite_add_suite(mrb_state* mrb, mrb_value self) {
  mrb_value suite;
  mrb_value nestedsuite;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &suite, &nestedsuite);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, suite, GTestSuite_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTestSuite expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, nestedsuite, GTestSuite_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTestSuite expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct GTestSuite * native_suite = (mrb_nil_p(suite) ? NULL : mruby_unbox_GTestSuite(suite));

  struct GTestSuite * native_nestedsuite = (mrb_nil_p(nestedsuite) ? NULL : mruby_unbox_GTestSuite(nestedsuite));

  /* Invocation */
  g_test_suite_add_suite(native_suite, native_nestedsuite);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_timer_elapsed_FUNCTION
#define g_test_timer_elapsed_REQUIRED_ARGC 0
#define g_test_timer_elapsed_OPTIONAL_ARGC 0
/* g_test_timer_elapsed
 *
 * Parameters: None
 * Return Type: double
 */
mrb_value
mrb_GLib_g_test_timer_elapsed(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  double native_return_value = g_test_timer_elapsed();

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_timer_last_FUNCTION
#define g_test_timer_last_REQUIRED_ARGC 0
#define g_test_timer_last_OPTIONAL_ARGC 0
/* g_test_timer_last
 *
 * Parameters: None
 * Return Type: double
 */
mrb_value
mrb_GLib_g_test_timer_last(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  double native_return_value = g_test_timer_last();

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_timer_start_FUNCTION
#define g_test_timer_start_REQUIRED_ARGC 0
#define g_test_timer_start_OPTIONAL_ARGC 0
/* g_test_timer_start
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_timer_start(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  g_test_timer_start();

  return mrb_nil_value();
}
#endif

#if BIND_g_test_trap_assertions_FUNCTION
#define g_test_trap_assertions_REQUIRED_ARGC 6
#define g_test_trap_assertions_OPTIONAL_ARGC 0
/* g_test_trap_assertions
 *
 * Parameters:
 * - domain: const char *
 * - file: const char *
 * - line: int
 * - func: const char *
 * - assertion_flags: unsigned long
 * - pattern: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_trap_assertions(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_file = NULL;
  mrb_int native_line;
  char * native_func = NULL;
  mrb_int native_assertion_flags;
  char * native_pattern = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!iz!iz!", &native_domain, &native_file, &native_line, &native_func, &native_assertion_flags, &native_pattern);

  /* Invocation */
  g_test_trap_assertions(native_domain, native_file, native_line, native_func, native_assertion_flags, native_pattern);

  return mrb_nil_value();
}
#endif

#if BIND_g_test_trap_fork_FUNCTION
#define g_test_trap_fork_REQUIRED_ARGC 2
#define g_test_trap_fork_OPTIONAL_ARGC 0
/* g_test_trap_fork
 *
 * Parameters:
 * - usec_timeout: unsigned long
 * - test_trap_flags: GTestTrapFlags
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_test_trap_fork(mrb_state* mrb, mrb_value self) {
  mrb_int native_usec_timeout;
  mrb_int native_test_trap_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_usec_timeout, &native_test_trap_flags);

  /* Invocation */
  gboolean native_return_value = g_test_trap_fork(native_usec_timeout, native_test_trap_flags);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_trap_has_passed_FUNCTION
#define g_test_trap_has_passed_REQUIRED_ARGC 0
#define g_test_trap_has_passed_OPTIONAL_ARGC 0
/* g_test_trap_has_passed
 *
 * Parameters: None
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_test_trap_has_passed(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gboolean native_return_value = g_test_trap_has_passed();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_trap_reached_timeout_FUNCTION
#define g_test_trap_reached_timeout_REQUIRED_ARGC 0
#define g_test_trap_reached_timeout_OPTIONAL_ARGC 0
/* g_test_trap_reached_timeout
 *
 * Parameters: None
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_test_trap_reached_timeout(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gboolean native_return_value = g_test_trap_reached_timeout();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_test_trap_subprocess_FUNCTION
#define g_test_trap_subprocess_REQUIRED_ARGC 3
#define g_test_trap_subprocess_OPTIONAL_ARGC 0
/* g_test_trap_subprocess
 *
 * Parameters:
 * - test_path: const char *
 * - usec_timeout: unsigned long
 * - test_flags: GTestSubprocessFlags
 * Return Type: void
 */
mrb_value
mrb_GLib_g_test_trap_subprocess(mrb_state* mrb, mrb_value self) {
  char * native_test_path = NULL;
  mrb_int native_usec_timeout;
  mrb_int native_test_flags;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ii", &native_test_path, &native_usec_timeout, &native_test_flags);

  /* Invocation */
  g_test_trap_subprocess(native_test_path, native_usec_timeout, native_test_flags);

  return mrb_nil_value();
}
#endif

#if BIND_g_thread_error_quark_FUNCTION
#define g_thread_error_quark_REQUIRED_ARGC 0
#define g_thread_error_quark_OPTIONAL_ARGC 0
/* g_thread_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_thread_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_thread_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_thread_exit_FUNCTION
#define g_thread_exit_REQUIRED_ARGC 1
#define g_thread_exit_OPTIONAL_ARGC 0
/* g_thread_exit
 *
 * Parameters:
 * - retval: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_thread_exit(mrb_state* mrb, mrb_value self) {
  mrb_value retval;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &retval);

  /* Type checking */
  TODO_type_check_void_PTR(retval);

  /* Unbox parameters */
  void * native_retval = TODO_mruby_unbox_void_PTR(retval);

  /* Invocation */
  g_thread_exit(native_retval);

  return mrb_nil_value();
}
#endif

#if BIND_g_thread_join_FUNCTION
#define g_thread_join_REQUIRED_ARGC 1
#define g_thread_join_OPTIONAL_ARGC 0
/* g_thread_join
 *
 * Parameters:
 * - thread: struct _GThread *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_thread_join(mrb_state* mrb, mrb_value self) {
  mrb_value thread;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &thread);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, thread, GThread_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThread expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GThread * native_thread = (mrb_nil_p(thread) ? NULL : mruby_unbox__GThread(thread));

  /* Invocation */
  gpointer native_return_value = g_thread_join(native_thread);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_thread_new_FUNCTION
#define g_thread_new_REQUIRED_ARGC 3
#define g_thread_new_OPTIONAL_ARGC 0
/* g_thread_new
 *
 * Parameters:
 * - name: const char *
 * - func: void *(*)(void *)
 * - data: void *
 * Return Type: GThread *
 */
mrb_value
mrb_GLib_g_thread_new(mrb_state* mrb, mrb_value self) {
  char * native_name = NULL;
  mrb_value func;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "z!oo", &native_name, &func, &data);

  /* Type checking */
  TODO_type_check_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  void *(*native_func)(void *) = TODO_mruby_unbox_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(func);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GThread * native_return_value = g_thread_new(native_name, native_func, native_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GThread(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_thread_pool_free_FUNCTION
#define g_thread_pool_free_REQUIRED_ARGC 3
#define g_thread_pool_free_OPTIONAL_ARGC 0
/* g_thread_pool_free
 *
 * Parameters:
 * - pool: struct _GThreadPool *
 * - immediate: int
 * - wait_: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_thread_pool_free(mrb_state* mrb, mrb_value self) {
  mrb_value pool;
  mrb_int native_immediate;
  mrb_int native_wait_;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &pool, &native_immediate, &native_wait_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pool, GThreadPool_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThreadPool expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GThreadPool * native_pool = (mrb_nil_p(pool) ? NULL : mruby_unbox__GThreadPool(pool));

  /* Invocation */
  g_thread_pool_free(native_pool, native_immediate, native_wait_);

  return mrb_nil_value();
}
#endif

#if BIND_g_thread_pool_get_max_idle_time_FUNCTION
#define g_thread_pool_get_max_idle_time_REQUIRED_ARGC 0
#define g_thread_pool_get_max_idle_time_OPTIONAL_ARGC 0
/* g_thread_pool_get_max_idle_time
 *
 * Parameters: None
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_thread_pool_get_max_idle_time(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  guint native_return_value = g_thread_pool_get_max_idle_time();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_thread_pool_get_max_threads_FUNCTION
#define g_thread_pool_get_max_threads_REQUIRED_ARGC 1
#define g_thread_pool_get_max_threads_OPTIONAL_ARGC 0
/* g_thread_pool_get_max_threads
 *
 * Parameters:
 * - pool: struct _GThreadPool *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_thread_pool_get_max_threads(mrb_state* mrb, mrb_value self) {
  mrb_value pool;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pool);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pool, GThreadPool_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThreadPool expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GThreadPool * native_pool = (mrb_nil_p(pool) ? NULL : mruby_unbox__GThreadPool(pool));

  /* Invocation */
  gint native_return_value = g_thread_pool_get_max_threads(native_pool);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_thread_pool_get_max_unused_threads_FUNCTION
#define g_thread_pool_get_max_unused_threads_REQUIRED_ARGC 0
#define g_thread_pool_get_max_unused_threads_OPTIONAL_ARGC 0
/* g_thread_pool_get_max_unused_threads
 *
 * Parameters: None
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_thread_pool_get_max_unused_threads(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  gint native_return_value = g_thread_pool_get_max_unused_threads();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_thread_pool_get_num_threads_FUNCTION
#define g_thread_pool_get_num_threads_REQUIRED_ARGC 1
#define g_thread_pool_get_num_threads_OPTIONAL_ARGC 0
/* g_thread_pool_get_num_threads
 *
 * Parameters:
 * - pool: struct _GThreadPool *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_thread_pool_get_num_threads(mrb_state* mrb, mrb_value self) {
  mrb_value pool;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pool);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pool, GThreadPool_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThreadPool expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GThreadPool * native_pool = (mrb_nil_p(pool) ? NULL : mruby_unbox__GThreadPool(pool));

  /* Invocation */
  guint native_return_value = g_thread_pool_get_num_threads(native_pool);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_thread_pool_get_num_unused_threads_FUNCTION
#define g_thread_pool_get_num_unused_threads_REQUIRED_ARGC 0
#define g_thread_pool_get_num_unused_threads_OPTIONAL_ARGC 0
/* g_thread_pool_get_num_unused_threads
 *
 * Parameters: None
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_thread_pool_get_num_unused_threads(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  guint native_return_value = g_thread_pool_get_num_unused_threads();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_thread_pool_move_to_front_FUNCTION
#define g_thread_pool_move_to_front_REQUIRED_ARGC 2
#define g_thread_pool_move_to_front_OPTIONAL_ARGC 0
/* g_thread_pool_move_to_front
 *
 * Parameters:
 * - pool: struct _GThreadPool *
 * - data: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_thread_pool_move_to_front(mrb_state* mrb, mrb_value self) {
  mrb_value pool;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &pool, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pool, GThreadPool_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThreadPool expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GThreadPool * native_pool = (mrb_nil_p(pool) ? NULL : mruby_unbox__GThreadPool(pool));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  gboolean native_return_value = g_thread_pool_move_to_front(native_pool, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_thread_pool_new_FUNCTION
#define g_thread_pool_new_REQUIRED_ARGC 4
#define g_thread_pool_new_OPTIONAL_ARGC 0
/* g_thread_pool_new
 *
 * Parameters:
 * - func: void (*)(void *, void *)
 * - user_data: void *
 * - max_threads: int
 * - exclusive: int
 * Return Type: GThreadPool *
 */
mrb_value
mrb_GLib_g_thread_pool_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value func;
  mrb_value user_data;
  mrb_int native_max_threads;
  mrb_int native_exclusive;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "ooii", &func, &user_data, &native_max_threads, &native_exclusive);

  /* Type checking */
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  void (*native_func)(void *, void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GThreadPool * native_return_value = g_thread_pool_new(native_func, native_user_data, native_max_threads, native_exclusive, &native_error);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GThreadPool(mrb, native_return_value));
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_thread_pool_push_FUNCTION
#define g_thread_pool_push_REQUIRED_ARGC 2
#define g_thread_pool_push_OPTIONAL_ARGC 0
/* g_thread_pool_push
 *
 * Parameters:
 * - pool: struct _GThreadPool *
 * - data: void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_thread_pool_push(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value pool;
  mrb_value data;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &pool, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pool, GThreadPool_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThreadPool expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GThreadPool * native_pool = (mrb_nil_p(pool) ? NULL : mruby_unbox__GThreadPool(pool));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  gboolean native_return_value = g_thread_pool_push(native_pool, native_data, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_thread_pool_set_max_idle_time_FUNCTION
#define g_thread_pool_set_max_idle_time_REQUIRED_ARGC 1
#define g_thread_pool_set_max_idle_time_OPTIONAL_ARGC 0
/* g_thread_pool_set_max_idle_time
 *
 * Parameters:
 * - interval: unsigned int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_thread_pool_set_max_idle_time(mrb_state* mrb, mrb_value self) {
  mrb_int native_interval;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_interval);

  /* Invocation */
  g_thread_pool_set_max_idle_time(native_interval);

  return mrb_nil_value();
}
#endif

#if BIND_g_thread_pool_set_max_threads_FUNCTION
#define g_thread_pool_set_max_threads_REQUIRED_ARGC 2
#define g_thread_pool_set_max_threads_OPTIONAL_ARGC 0
/* g_thread_pool_set_max_threads
 *
 * Parameters:
 * - pool: struct _GThreadPool *
 * - max_threads: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_thread_pool_set_max_threads(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value pool;
  mrb_int native_max_threads;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &pool, &native_max_threads);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pool, GThreadPool_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThreadPool expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GThreadPool * native_pool = (mrb_nil_p(pool) ? NULL : mruby_unbox__GThreadPool(pool));

  /* Invocation */
  gboolean native_return_value = g_thread_pool_set_max_threads(native_pool, native_max_threads, &native_error);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_thread_pool_set_max_unused_threads_FUNCTION
#define g_thread_pool_set_max_unused_threads_REQUIRED_ARGC 1
#define g_thread_pool_set_max_unused_threads_OPTIONAL_ARGC 0
/* g_thread_pool_set_max_unused_threads
 *
 * Parameters:
 * - max_threads: int
 * Return Type: void
 */
mrb_value
mrb_GLib_g_thread_pool_set_max_unused_threads(mrb_state* mrb, mrb_value self) {
  mrb_int native_max_threads;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_max_threads);

  /* Invocation */
  g_thread_pool_set_max_unused_threads(native_max_threads);

  return mrb_nil_value();
}
#endif

#if BIND_g_thread_pool_set_sort_function_FUNCTION
#define g_thread_pool_set_sort_function_REQUIRED_ARGC 3
#define g_thread_pool_set_sort_function_OPTIONAL_ARGC 0
/* g_thread_pool_set_sort_function
 *
 * Parameters:
 * - pool: struct _GThreadPool *
 * - func: int (*)(const void *, const void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_thread_pool_set_sort_function(mrb_state* mrb, mrb_value self) {
  mrb_value pool;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &pool, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pool, GThreadPool_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThreadPool expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GThreadPool * native_pool = (mrb_nil_p(pool) ? NULL : mruby_unbox__GThreadPool(pool));

  int (*native_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_thread_pool_set_sort_function(native_pool, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_thread_pool_stop_unused_threads_FUNCTION
#define g_thread_pool_stop_unused_threads_REQUIRED_ARGC 0
#define g_thread_pool_stop_unused_threads_OPTIONAL_ARGC 0
/* g_thread_pool_stop_unused_threads
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_GLib_g_thread_pool_stop_unused_threads(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  g_thread_pool_stop_unused_threads();

  return mrb_nil_value();
}
#endif

#if BIND_g_thread_pool_unprocessed_FUNCTION
#define g_thread_pool_unprocessed_REQUIRED_ARGC 1
#define g_thread_pool_unprocessed_OPTIONAL_ARGC 0
/* g_thread_pool_unprocessed
 *
 * Parameters:
 * - pool: struct _GThreadPool *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_thread_pool_unprocessed(mrb_state* mrb, mrb_value self) {
  mrb_value pool;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &pool);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, pool, GThreadPool_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThreadPool expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GThreadPool * native_pool = (mrb_nil_p(pool) ? NULL : mruby_unbox__GThreadPool(pool));

  /* Invocation */
  guint native_return_value = g_thread_pool_unprocessed(native_pool);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_thread_ref_FUNCTION
#define g_thread_ref_REQUIRED_ARGC 1
#define g_thread_ref_OPTIONAL_ARGC 0
/* g_thread_ref
 *
 * Parameters:
 * - thread: struct _GThread *
 * Return Type: GThread *
 */
mrb_value
mrb_GLib_g_thread_ref(mrb_state* mrb, mrb_value self) {
  mrb_value thread;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &thread);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, thread, GThread_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThread expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GThread * native_thread = (mrb_nil_p(thread) ? NULL : mruby_unbox__GThread(thread));

  /* Invocation */
  GThread * native_return_value = g_thread_ref(native_thread);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GThread(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_thread_self_FUNCTION
#define g_thread_self_REQUIRED_ARGC 0
#define g_thread_self_OPTIONAL_ARGC 0
/* g_thread_self
 *
 * Parameters: None
 * Return Type: GThread *
 */
mrb_value
mrb_GLib_g_thread_self(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GThread * native_return_value = g_thread_self();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GThread(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_thread_try_new_FUNCTION
#define g_thread_try_new_REQUIRED_ARGC 3
#define g_thread_try_new_OPTIONAL_ARGC 0
/* g_thread_try_new
 *
 * Parameters:
 * - name: const char *
 * - func: void *(*)(void *)
 * - data: void *
 * Return Type: GThread *
 */
mrb_value
mrb_GLib_g_thread_try_new(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_name = NULL;
  mrb_value func;
  mrb_value data;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!oo", &native_name, &func, &data);

  /* Type checking */
  TODO_type_check_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  void *(*native_func)(void *) = TODO_mruby_unbox_void_PTR_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(func);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  GThread * native_return_value = g_thread_try_new(native_name, native_func, native_data, &native_error);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GThread(mrb, native_return_value));
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_thread_unref_FUNCTION
#define g_thread_unref_REQUIRED_ARGC 1
#define g_thread_unref_OPTIONAL_ARGC 0
/* g_thread_unref
 *
 * Parameters:
 * - thread: struct _GThread *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_thread_unref(mrb_state* mrb, mrb_value self) {
  mrb_value thread;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &thread);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, thread, GThread_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GThread expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GThread * native_thread = (mrb_nil_p(thread) ? NULL : mruby_unbox__GThread(thread));

  /* Invocation */
  g_thread_unref(native_thread);

  return mrb_nil_value();
}
#endif

#if BIND_g_thread_yield_FUNCTION
#define g_thread_yield_REQUIRED_ARGC 0
#define g_thread_yield_OPTIONAL_ARGC 0
/* g_thread_yield
 *
 * Parameters: None
 * Return Type: void
 */
mrb_value
mrb_GLib_g_thread_yield(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  g_thread_yield();

  return mrb_nil_value();
}
#endif

#if BIND_g_time_val_add_FUNCTION
#define g_time_val_add_REQUIRED_ARGC 2
#define g_time_val_add_OPTIONAL_ARGC 0
/* g_time_val_add
 *
 * Parameters:
 * - time_: struct _GTimeVal *
 * - microseconds: long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_time_val_add(mrb_state* mrb, mrb_value self) {
  mrb_value time_;
  mrb_int native_microseconds;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &time_, &native_microseconds);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, time_, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeVal * native_time_ = (mrb_nil_p(time_) ? NULL : mruby_unbox__GTimeVal(time_));

  /* Invocation */
  g_time_val_add(native_time_, native_microseconds);

  return mrb_nil_value();
}
#endif

#if BIND_g_time_val_from_iso8601_FUNCTION
#define g_time_val_from_iso8601_REQUIRED_ARGC 2
#define g_time_val_from_iso8601_OPTIONAL_ARGC 0
/* g_time_val_from_iso8601
 *
 * Parameters:
 * - iso_date: const char *
 * - time_: struct _GTimeVal *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_time_val_from_iso8601(mrb_state* mrb, mrb_value self) {
  char * native_iso_date = NULL;
  mrb_value time_;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_iso_date, &time_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, time_, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeVal * native_time_ = (mrb_nil_p(time_) ? NULL : mruby_unbox__GTimeVal(time_));

  /* Invocation */
  gboolean native_return_value = g_time_val_from_iso8601(native_iso_date, native_time_);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_time_val_to_iso8601_FUNCTION
#define g_time_val_to_iso8601_REQUIRED_ARGC 1
#define g_time_val_to_iso8601_OPTIONAL_ARGC 0
/* g_time_val_to_iso8601
 *
 * Parameters:
 * - time_: struct _GTimeVal *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_time_val_to_iso8601(mrb_state* mrb, mrb_value self) {
  mrb_value time_;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &time_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, time_, GTimeVal_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeVal expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeVal * native_time_ = (mrb_nil_p(time_) ? NULL : mruby_unbox__GTimeVal(time_));

  /* Invocation */
  gchar * native_return_value = g_time_val_to_iso8601(native_time_);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_time_zone_adjust_time_FUNCTION
#define g_time_zone_adjust_time_REQUIRED_ARGC 3
#define g_time_zone_adjust_time_OPTIONAL_ARGC 0
/* g_time_zone_adjust_time
 *
 * Parameters:
 * - tz: struct _GTimeZone *
 * - type: GTimeType
 * - time_: long *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_time_zone_adjust_time(mrb_state* mrb, mrb_value self) {
  mrb_value tz;
  mrb_int native_type;
  mrb_value time_;

  /* Fetch the args */
  mrb_get_args(mrb, "oio", &tz, &native_type, &time_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tz, GTimeZone_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeZone expected");
    return mrb_nil_value();
  }
  TODO_type_check_long_PTR(time_);

  /* Unbox parameters */
  struct _GTimeZone * native_tz = (mrb_nil_p(tz) ? NULL : mruby_unbox__GTimeZone(tz));

  long * native_time_ = TODO_mruby_unbox_long_PTR(time_);

  /* Invocation */
  gint native_return_value = g_time_zone_adjust_time(native_tz, native_type, native_time_);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_time_zone_find_interval_FUNCTION
#define g_time_zone_find_interval_REQUIRED_ARGC 3
#define g_time_zone_find_interval_OPTIONAL_ARGC 0
/* g_time_zone_find_interval
 *
 * Parameters:
 * - tz: struct _GTimeZone *
 * - type: GTimeType
 * - time_: long
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_time_zone_find_interval(mrb_state* mrb, mrb_value self) {
  mrb_value tz;
  mrb_int native_type;
  mrb_int native_time_;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &tz, &native_type, &native_time_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tz, GTimeZone_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeZone expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeZone * native_tz = (mrb_nil_p(tz) ? NULL : mruby_unbox__GTimeZone(tz));

  /* Invocation */
  gint native_return_value = g_time_zone_find_interval(native_tz, native_type, native_time_);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_time_zone_get_abbreviation_FUNCTION
#define g_time_zone_get_abbreviation_REQUIRED_ARGC 2
#define g_time_zone_get_abbreviation_OPTIONAL_ARGC 0
/* g_time_zone_get_abbreviation
 *
 * Parameters:
 * - tz: struct _GTimeZone *
 * - interval: int
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_time_zone_get_abbreviation(mrb_state* mrb, mrb_value self) {
  mrb_value tz;
  mrb_int native_interval;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &tz, &native_interval);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tz, GTimeZone_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeZone expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeZone * native_tz = (mrb_nil_p(tz) ? NULL : mruby_unbox__GTimeZone(tz));

  /* Invocation */
  const gchar * native_return_value = g_time_zone_get_abbreviation(native_tz, native_interval);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_time_zone_get_offset_FUNCTION
#define g_time_zone_get_offset_REQUIRED_ARGC 2
#define g_time_zone_get_offset_OPTIONAL_ARGC 0
/* g_time_zone_get_offset
 *
 * Parameters:
 * - tz: struct _GTimeZone *
 * - interval: int
 * Return Type: gint32
 */
mrb_value
mrb_GLib_g_time_zone_get_offset(mrb_state* mrb, mrb_value self) {
  mrb_value tz;
  mrb_int native_interval;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &tz, &native_interval);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tz, GTimeZone_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeZone expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeZone * native_tz = (mrb_nil_p(tz) ? NULL : mruby_unbox__GTimeZone(tz));

  /* Invocation */
  gint32 native_return_value = g_time_zone_get_offset(native_tz, native_interval);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_time_zone_is_dst_FUNCTION
#define g_time_zone_is_dst_REQUIRED_ARGC 2
#define g_time_zone_is_dst_OPTIONAL_ARGC 0
/* g_time_zone_is_dst
 *
 * Parameters:
 * - tz: struct _GTimeZone *
 * - interval: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_time_zone_is_dst(mrb_state* mrb, mrb_value self) {
  mrb_value tz;
  mrb_int native_interval;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &tz, &native_interval);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tz, GTimeZone_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeZone expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeZone * native_tz = (mrb_nil_p(tz) ? NULL : mruby_unbox__GTimeZone(tz));

  /* Invocation */
  gboolean native_return_value = g_time_zone_is_dst(native_tz, native_interval);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_time_zone_new_FUNCTION
#define g_time_zone_new_REQUIRED_ARGC 1
#define g_time_zone_new_OPTIONAL_ARGC 0
/* g_time_zone_new
 *
 * Parameters:
 * - identifier: const char *
 * Return Type: GTimeZone *
 */
mrb_value
mrb_GLib_g_time_zone_new(mrb_state* mrb, mrb_value self) {
  char * native_identifier = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_identifier);

  /* Invocation */
  GTimeZone * native_return_value = g_time_zone_new(native_identifier);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GTimeZone(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_time_zone_new_local_FUNCTION
#define g_time_zone_new_local_REQUIRED_ARGC 0
#define g_time_zone_new_local_OPTIONAL_ARGC 0
/* g_time_zone_new_local
 *
 * Parameters: None
 * Return Type: GTimeZone *
 */
mrb_value
mrb_GLib_g_time_zone_new_local(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GTimeZone * native_return_value = g_time_zone_new_local();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GTimeZone(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_time_zone_new_utc_FUNCTION
#define g_time_zone_new_utc_REQUIRED_ARGC 0
#define g_time_zone_new_utc_OPTIONAL_ARGC 0
/* g_time_zone_new_utc
 *
 * Parameters: None
 * Return Type: GTimeZone *
 */
mrb_value
mrb_GLib_g_time_zone_new_utc(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GTimeZone * native_return_value = g_time_zone_new_utc();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GTimeZone(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_time_zone_ref_FUNCTION
#define g_time_zone_ref_REQUIRED_ARGC 1
#define g_time_zone_ref_OPTIONAL_ARGC 0
/* g_time_zone_ref
 *
 * Parameters:
 * - tz: struct _GTimeZone *
 * Return Type: GTimeZone *
 */
mrb_value
mrb_GLib_g_time_zone_ref(mrb_state* mrb, mrb_value self) {
  mrb_value tz;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tz);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tz, GTimeZone_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeZone expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeZone * native_tz = (mrb_nil_p(tz) ? NULL : mruby_unbox__GTimeZone(tz));

  /* Invocation */
  GTimeZone * native_return_value = g_time_zone_ref(native_tz);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GTimeZone(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_time_zone_unref_FUNCTION
#define g_time_zone_unref_REQUIRED_ARGC 1
#define g_time_zone_unref_OPTIONAL_ARGC 0
/* g_time_zone_unref
 *
 * Parameters:
 * - tz: struct _GTimeZone *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_time_zone_unref(mrb_state* mrb, mrb_value self) {
  mrb_value tz;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tz);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tz, GTimeZone_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimeZone expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimeZone * native_tz = (mrb_nil_p(tz) ? NULL : mruby_unbox__GTimeZone(tz));

  /* Invocation */
  g_time_zone_unref(native_tz);

  return mrb_nil_value();
}
#endif

#if BIND_g_timeout_add_FUNCTION
#define g_timeout_add_REQUIRED_ARGC 3
#define g_timeout_add_OPTIONAL_ARGC 0
/* g_timeout_add
 *
 * Parameters:
 * - interval: unsigned int
 * - function: int (*)(void *)
 * - data: void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_timeout_add(mrb_state* mrb, mrb_value self) {
  mrb_int native_interval;
  mrb_value function;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "ioo", &native_interval, &function, &data);

  /* Type checking */
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  int (*native_function)(void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  guint native_return_value = g_timeout_add(native_interval, native_function, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_timeout_add_full_FUNCTION
#define g_timeout_add_full_REQUIRED_ARGC 5
#define g_timeout_add_full_OPTIONAL_ARGC 0
/* g_timeout_add_full
 *
 * Parameters:
 * - priority: int
 * - interval: unsigned int
 * - function: int (*)(void *)
 * - data: void *
 * - notify: void (*)(void *)
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_timeout_add_full(mrb_state* mrb, mrb_value self) {
  mrb_int native_priority;
  mrb_int native_interval;
  mrb_value function;
  mrb_value data;
  mrb_value notify;

  /* Fetch the args */
  mrb_get_args(mrb, "iiooo", &native_priority, &native_interval, &function, &data, &notify);

  /* Type checking */
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Unbox parameters */
  int (*native_function)(void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_notify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Invocation */
  guint native_return_value = g_timeout_add_full(native_priority, native_interval, native_function, native_data, native_notify);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_timeout_add_seconds_FUNCTION
#define g_timeout_add_seconds_REQUIRED_ARGC 3
#define g_timeout_add_seconds_OPTIONAL_ARGC 0
/* g_timeout_add_seconds
 *
 * Parameters:
 * - interval: unsigned int
 * - function: int (*)(void *)
 * - data: void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_timeout_add_seconds(mrb_state* mrb, mrb_value self) {
  mrb_int native_interval;
  mrb_value function;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "ioo", &native_interval, &function, &data);

  /* Type checking */
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  int (*native_function)(void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  guint native_return_value = g_timeout_add_seconds(native_interval, native_function, native_data);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_timeout_add_seconds_full_FUNCTION
#define g_timeout_add_seconds_full_REQUIRED_ARGC 5
#define g_timeout_add_seconds_full_OPTIONAL_ARGC 0
/* g_timeout_add_seconds_full
 *
 * Parameters:
 * - priority: int
 * - interval: unsigned int
 * - function: int (*)(void *)
 * - data: void *
 * - notify: void (*)(void *)
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_timeout_add_seconds_full(mrb_state* mrb, mrb_value self) {
  mrb_int native_priority;
  mrb_int native_interval;
  mrb_value function;
  mrb_value data;
  mrb_value notify;

  /* Fetch the args */
  mrb_get_args(mrb, "iiooo", &native_priority, &native_interval, &function, &data, &notify);

  /* Type checking */
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Unbox parameters */
  int (*native_function)(void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(function);

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_notify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  /* Invocation */
  guint native_return_value = g_timeout_add_seconds_full(native_priority, native_interval, native_function, native_data, native_notify);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_timeout_source_new_FUNCTION
#define g_timeout_source_new_REQUIRED_ARGC 1
#define g_timeout_source_new_OPTIONAL_ARGC 0
/* g_timeout_source_new
 *
 * Parameters:
 * - interval: unsigned int
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_timeout_source_new(mrb_state* mrb, mrb_value self) {
  mrb_int native_interval;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_interval);

  /* Invocation */
  GSource * native_return_value = g_timeout_source_new(native_interval);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_timeout_source_new_seconds_FUNCTION
#define g_timeout_source_new_seconds_REQUIRED_ARGC 1
#define g_timeout_source_new_seconds_OPTIONAL_ARGC 0
/* g_timeout_source_new_seconds
 *
 * Parameters:
 * - interval: unsigned int
 * Return Type: GSource *
 */
mrb_value
mrb_GLib_g_timeout_source_new_seconds(mrb_state* mrb, mrb_value self) {
  mrb_int native_interval;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_interval);

  /* Invocation */
  GSource * native_return_value = g_timeout_source_new_seconds(native_interval);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GSource(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_timer_continue_FUNCTION
#define g_timer_continue_REQUIRED_ARGC 1
#define g_timer_continue_OPTIONAL_ARGC 0
/* g_timer_continue
 *
 * Parameters:
 * - timer: struct _GTimer *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_timer_continue(mrb_state* mrb, mrb_value self) {
  mrb_value timer;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &timer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, timer, GTimer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimer expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimer * native_timer = (mrb_nil_p(timer) ? NULL : mruby_unbox__GTimer(timer));

  /* Invocation */
  g_timer_continue(native_timer);

  return mrb_nil_value();
}
#endif

#if BIND_g_timer_destroy_FUNCTION
#define g_timer_destroy_REQUIRED_ARGC 1
#define g_timer_destroy_OPTIONAL_ARGC 0
/* g_timer_destroy
 *
 * Parameters:
 * - timer: struct _GTimer *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_timer_destroy(mrb_state* mrb, mrb_value self) {
  mrb_value timer;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &timer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, timer, GTimer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimer expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimer * native_timer = (mrb_nil_p(timer) ? NULL : mruby_unbox__GTimer(timer));

  /* Invocation */
  g_timer_destroy(native_timer);

  return mrb_nil_value();
}
#endif

#if BIND_g_timer_elapsed_FUNCTION
#define g_timer_elapsed_REQUIRED_ARGC 2
#define g_timer_elapsed_OPTIONAL_ARGC 0
/* g_timer_elapsed
 *
 * Parameters:
 * - timer: struct _GTimer *
 * - microseconds: unsigned long *
 * Return Type: gdouble
 */
mrb_value
mrb_GLib_g_timer_elapsed(mrb_state* mrb, mrb_value self) {
  mrb_value timer;
  mrb_value microseconds;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &timer, &microseconds);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, timer, GTimer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimer expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(microseconds);

  /* Unbox parameters */
  struct _GTimer * native_timer = (mrb_nil_p(timer) ? NULL : mruby_unbox__GTimer(timer));

  unsigned long * native_microseconds = TODO_mruby_unbox_unsigned_long_PTR(microseconds);

  /* Invocation */
  gdouble native_return_value = g_timer_elapsed(native_timer, native_microseconds);

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_timer_new_FUNCTION
#define g_timer_new_REQUIRED_ARGC 0
#define g_timer_new_OPTIONAL_ARGC 0
/* g_timer_new
 *
 * Parameters: None
 * Return Type: GTimer *
 */
mrb_value
mrb_GLib_g_timer_new(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GTimer * native_return_value = g_timer_new();

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GTimer(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_timer_reset_FUNCTION
#define g_timer_reset_REQUIRED_ARGC 1
#define g_timer_reset_OPTIONAL_ARGC 0
/* g_timer_reset
 *
 * Parameters:
 * - timer: struct _GTimer *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_timer_reset(mrb_state* mrb, mrb_value self) {
  mrb_value timer;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &timer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, timer, GTimer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimer expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimer * native_timer = (mrb_nil_p(timer) ? NULL : mruby_unbox__GTimer(timer));

  /* Invocation */
  g_timer_reset(native_timer);

  return mrb_nil_value();
}
#endif

#if BIND_g_timer_start_FUNCTION
#define g_timer_start_REQUIRED_ARGC 1
#define g_timer_start_OPTIONAL_ARGC 0
/* g_timer_start
 *
 * Parameters:
 * - timer: struct _GTimer *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_timer_start(mrb_state* mrb, mrb_value self) {
  mrb_value timer;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &timer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, timer, GTimer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimer expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimer * native_timer = (mrb_nil_p(timer) ? NULL : mruby_unbox__GTimer(timer));

  /* Invocation */
  g_timer_start(native_timer);

  return mrb_nil_value();
}
#endif

#if BIND_g_timer_stop_FUNCTION
#define g_timer_stop_REQUIRED_ARGC 1
#define g_timer_stop_OPTIONAL_ARGC 0
/* g_timer_stop
 *
 * Parameters:
 * - timer: struct _GTimer *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_timer_stop(mrb_state* mrb, mrb_value self) {
  mrb_value timer;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &timer);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, timer, GTimer_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTimer expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTimer * native_timer = (mrb_nil_p(timer) ? NULL : mruby_unbox__GTimer(timer));

  /* Invocation */
  g_timer_stop(native_timer);

  return mrb_nil_value();
}
#endif

#if BIND_g_trash_stack_height_FUNCTION
#define g_trash_stack_height_REQUIRED_ARGC 1
#define g_trash_stack_height_OPTIONAL_ARGC 0
/* g_trash_stack_height
 *
 * Parameters:
 * - stack_p: struct _GTrashStack **
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_trash_stack_height(mrb_state* mrb, mrb_value self) {
  mrb_value stack_p;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stack_p);

  /* Type checking */
  TODO_type_check__GTrashStack_PTR_PTR(stack_p);

  /* Unbox parameters */
  struct _GTrashStack ** native_stack_p = TODO_mruby_unbox__GTrashStack_PTR_PTR(stack_p);

  /* Invocation */
  guint native_return_value = g_trash_stack_height(native_stack_p);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_trash_stack_peek_FUNCTION
#define g_trash_stack_peek_REQUIRED_ARGC 1
#define g_trash_stack_peek_OPTIONAL_ARGC 0
/* g_trash_stack_peek
 *
 * Parameters:
 * - stack_p: struct _GTrashStack **
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_trash_stack_peek(mrb_state* mrb, mrb_value self) {
  mrb_value stack_p;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stack_p);

  /* Type checking */
  TODO_type_check__GTrashStack_PTR_PTR(stack_p);

  /* Unbox parameters */
  struct _GTrashStack ** native_stack_p = TODO_mruby_unbox__GTrashStack_PTR_PTR(stack_p);

  /* Invocation */
  gpointer native_return_value = g_trash_stack_peek(native_stack_p);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_trash_stack_pop_FUNCTION
#define g_trash_stack_pop_REQUIRED_ARGC 1
#define g_trash_stack_pop_OPTIONAL_ARGC 0
/* g_trash_stack_pop
 *
 * Parameters:
 * - stack_p: struct _GTrashStack **
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_trash_stack_pop(mrb_state* mrb, mrb_value self) {
  mrb_value stack_p;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &stack_p);

  /* Type checking */
  TODO_type_check__GTrashStack_PTR_PTR(stack_p);

  /* Unbox parameters */
  struct _GTrashStack ** native_stack_p = TODO_mruby_unbox__GTrashStack_PTR_PTR(stack_p);

  /* Invocation */
  gpointer native_return_value = g_trash_stack_pop(native_stack_p);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_trash_stack_push_FUNCTION
#define g_trash_stack_push_REQUIRED_ARGC 2
#define g_trash_stack_push_OPTIONAL_ARGC 0
/* g_trash_stack_push
 *
 * Parameters:
 * - stack_p: struct _GTrashStack **
 * - data_p: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_trash_stack_push(mrb_state* mrb, mrb_value self) {
  mrb_value stack_p;
  mrb_value data_p;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &stack_p, &data_p);

  /* Type checking */
  TODO_type_check__GTrashStack_PTR_PTR(stack_p);
  TODO_type_check_void_PTR(data_p);

  /* Unbox parameters */
  struct _GTrashStack ** native_stack_p = TODO_mruby_unbox__GTrashStack_PTR_PTR(stack_p);

  void * native_data_p = TODO_mruby_unbox_void_PTR(data_p);

  /* Invocation */
  g_trash_stack_push(native_stack_p, native_data_p);

  return mrb_nil_value();
}
#endif

#if BIND_g_tree_destroy_FUNCTION
#define g_tree_destroy_REQUIRED_ARGC 1
#define g_tree_destroy_OPTIONAL_ARGC 0
/* g_tree_destroy
 *
 * Parameters:
 * - tree: struct _GTree *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_tree_destroy(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  /* Invocation */
  g_tree_destroy(native_tree);

  return mrb_nil_value();
}
#endif

#if BIND_g_tree_foreach_FUNCTION
#define g_tree_foreach_REQUIRED_ARGC 3
#define g_tree_foreach_OPTIONAL_ARGC 0
/* g_tree_foreach
 *
 * Parameters:
 * - tree: struct _GTree *
 * - func: int (*)(void *, void *, void *)
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_tree_foreach(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &tree, &func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  int (*native_func)(void *, void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_tree_foreach(native_tree, native_func, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_tree_height_FUNCTION
#define g_tree_height_REQUIRED_ARGC 1
#define g_tree_height_OPTIONAL_ARGC 0
/* g_tree_height
 *
 * Parameters:
 * - tree: struct _GTree *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_tree_height(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  /* Invocation */
  gint native_return_value = g_tree_height(native_tree);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_tree_insert_FUNCTION
#define g_tree_insert_REQUIRED_ARGC 3
#define g_tree_insert_OPTIONAL_ARGC 0
/* g_tree_insert
 *
 * Parameters:
 * - tree: struct _GTree *
 * - key: void *
 * - value: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_tree_insert(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &tree, &key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);
  TODO_type_check_void_PTR(value);

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  void * native_key = TODO_mruby_unbox_void_PTR(key);

  void * native_value = TODO_mruby_unbox_void_PTR(value);

  /* Invocation */
  g_tree_insert(native_tree, native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_tree_lookup_FUNCTION
#define g_tree_lookup_REQUIRED_ARGC 2
#define g_tree_lookup_OPTIONAL_ARGC 0
/* g_tree_lookup
 *
 * Parameters:
 * - tree: struct _GTree *
 * - key: const void *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_tree_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value key;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &tree, &key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  const void * native_key = TODO_mruby_unbox_void_PTR(key);

  /* Invocation */
  gpointer native_return_value = g_tree_lookup(native_tree, native_key);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_tree_lookup_extended_FUNCTION
#define g_tree_lookup_extended_REQUIRED_ARGC 4
#define g_tree_lookup_extended_OPTIONAL_ARGC 0
/* g_tree_lookup_extended
 *
 * Parameters:
 * - tree: struct _GTree *
 * - lookup_key: const void *
 * - orig_key: void **
 * - value: void **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_tree_lookup_extended(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value lookup_key;
  mrb_value orig_key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &tree, &lookup_key, &orig_key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(lookup_key);
  TODO_type_check_void_PTR_PTR(orig_key);
  TODO_type_check_void_PTR_PTR(value);

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  const void * native_lookup_key = TODO_mruby_unbox_void_PTR(lookup_key);

  void ** native_orig_key = TODO_mruby_unbox_void_PTR_PTR(orig_key);

  void ** native_value = TODO_mruby_unbox_void_PTR_PTR(value);

  /* Invocation */
  gboolean native_return_value = g_tree_lookup_extended(native_tree, native_lookup_key, native_orig_key, native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_tree_new_FUNCTION
#define g_tree_new_REQUIRED_ARGC 1
#define g_tree_new_OPTIONAL_ARGC 0
/* g_tree_new
 *
 * Parameters:
 * - key_compare_func: int (*)(const void *, const void *)
 * Return Type: GTree *
 */
mrb_value
mrb_GLib_g_tree_new(mrb_state* mrb, mrb_value self) {
  mrb_value key_compare_func;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &key_compare_func);

  /* Type checking */
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(key_compare_func);

  /* Unbox parameters */
  int (*native_key_compare_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(key_compare_func);

  /* Invocation */
  GTree * native_return_value = g_tree_new(native_key_compare_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GTree(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_tree_new_full_FUNCTION
#define g_tree_new_full_REQUIRED_ARGC 4
#define g_tree_new_full_OPTIONAL_ARGC 0
/* g_tree_new_full
 *
 * Parameters:
 * - key_compare_func: int (*)(const void *, const void *, void *)
 * - key_compare_data: void *
 * - key_destroy_func: void (*)(void *)
 * - value_destroy_func: void (*)(void *)
 * Return Type: GTree *
 */
mrb_value
mrb_GLib_g_tree_new_full(mrb_state* mrb, mrb_value self) {
  mrb_value key_compare_func;
  mrb_value key_compare_data;
  mrb_value key_destroy_func;
  mrb_value value_destroy_func;

  /* Fetch the args */
  mrb_get_args(mrb, "oooo", &key_compare_func, &key_compare_data, &key_destroy_func, &value_destroy_func);

  /* Type checking */
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(key_compare_func);
  TODO_type_check_void_PTR(key_compare_data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(key_destroy_func);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(value_destroy_func);

  /* Unbox parameters */
  int (*native_key_compare_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(key_compare_func);

  void * native_key_compare_data = TODO_mruby_unbox_void_PTR(key_compare_data);

  void (*native_key_destroy_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(key_destroy_func);

  void (*native_value_destroy_func)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(value_destroy_func);

  /* Invocation */
  GTree * native_return_value = g_tree_new_full(native_key_compare_func, native_key_compare_data, native_key_destroy_func, native_value_destroy_func);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GTree(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_tree_new_with_data_FUNCTION
#define g_tree_new_with_data_REQUIRED_ARGC 2
#define g_tree_new_with_data_OPTIONAL_ARGC 0
/* g_tree_new_with_data
 *
 * Parameters:
 * - key_compare_func: int (*)(const void *, const void *, void *)
 * - key_compare_data: void *
 * Return Type: GTree *
 */
mrb_value
mrb_GLib_g_tree_new_with_data(mrb_state* mrb, mrb_value self) {
  mrb_value key_compare_func;
  mrb_value key_compare_data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &key_compare_func, &key_compare_data);

  /* Type checking */
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(key_compare_func);
  TODO_type_check_void_PTR(key_compare_data);

  /* Unbox parameters */
  int (*native_key_compare_func)(const void *, const void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_COMMA_void_PTR_RPAREN(key_compare_func);

  void * native_key_compare_data = TODO_mruby_unbox_void_PTR(key_compare_data);

  /* Invocation */
  GTree * native_return_value = g_tree_new_with_data(native_key_compare_func, native_key_compare_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GTree(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_tree_nnodes_FUNCTION
#define g_tree_nnodes_REQUIRED_ARGC 1
#define g_tree_nnodes_OPTIONAL_ARGC 0
/* g_tree_nnodes
 *
 * Parameters:
 * - tree: struct _GTree *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_tree_nnodes(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  /* Invocation */
  gint native_return_value = g_tree_nnodes(native_tree);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_tree_ref_FUNCTION
#define g_tree_ref_REQUIRED_ARGC 1
#define g_tree_ref_OPTIONAL_ARGC 0
/* g_tree_ref
 *
 * Parameters:
 * - tree: struct _GTree *
 * Return Type: GTree *
 */
mrb_value
mrb_GLib_g_tree_ref(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  /* Invocation */
  GTree * native_return_value = g_tree_ref(native_tree);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GTree(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_tree_remove_FUNCTION
#define g_tree_remove_REQUIRED_ARGC 2
#define g_tree_remove_OPTIONAL_ARGC 0
/* g_tree_remove
 *
 * Parameters:
 * - tree: struct _GTree *
 * - key: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_tree_remove(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value key;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &tree, &key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  const void * native_key = TODO_mruby_unbox_void_PTR(key);

  /* Invocation */
  gboolean native_return_value = g_tree_remove(native_tree, native_key);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_tree_replace_FUNCTION
#define g_tree_replace_REQUIRED_ARGC 3
#define g_tree_replace_OPTIONAL_ARGC 0
/* g_tree_replace
 *
 * Parameters:
 * - tree: struct _GTree *
 * - key: void *
 * - value: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_tree_replace(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &tree, &key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);
  TODO_type_check_void_PTR(value);

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  void * native_key = TODO_mruby_unbox_void_PTR(key);

  void * native_value = TODO_mruby_unbox_void_PTR(value);

  /* Invocation */
  g_tree_replace(native_tree, native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_tree_search_FUNCTION
#define g_tree_search_REQUIRED_ARGC 3
#define g_tree_search_OPTIONAL_ARGC 0
/* g_tree_search
 *
 * Parameters:
 * - tree: struct _GTree *
 * - search_func: int (*)(const void *, const void *)
 * - user_data: const void *
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_tree_search(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value search_func;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooo", &tree, &search_func, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(search_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  int (*native_search_func)(const void *, const void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_const_void_PTR_RPAREN(search_func);

  const void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  gpointer native_return_value = g_tree_search(native_tree, native_search_func, native_user_data);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_tree_steal_FUNCTION
#define g_tree_steal_REQUIRED_ARGC 2
#define g_tree_steal_OPTIONAL_ARGC 0
/* g_tree_steal
 *
 * Parameters:
 * - tree: struct _GTree *
 * - key: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_tree_steal(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value key;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &tree, &key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(key);

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  const void * native_key = TODO_mruby_unbox_void_PTR(key);

  /* Invocation */
  gboolean native_return_value = g_tree_steal(native_tree, native_key);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_tree_traverse_FUNCTION
#define g_tree_traverse_REQUIRED_ARGC 4
#define g_tree_traverse_OPTIONAL_ARGC 0
/* g_tree_traverse
 *
 * Parameters:
 * - tree: struct _GTree *
 * - traverse_func: int (*)(void *, void *, void *)
 * - traverse_type: GTraverseType
 * - user_data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_tree_traverse(mrb_state* mrb, mrb_value self) {
  mrb_value tree;
  mrb_value traverse_func;
  mrb_int native_traverse_type;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooio", &tree, &traverse_func, &native_traverse_type, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }
  TODO_type_check_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(traverse_func);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  int (*native_traverse_func)(void *, void *, void *) = TODO_mruby_unbox_int_LPAREN_PTR_RPAREN_LPAREN_void_PTR_COMMA_void_PTR_COMMA_void_PTR_RPAREN(traverse_func);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  g_tree_traverse(native_tree, native_traverse_func, native_traverse_type, native_user_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_tree_unref_FUNCTION
#define g_tree_unref_REQUIRED_ARGC 1
#define g_tree_unref_OPTIONAL_ARGC 0
/* g_tree_unref
 *
 * Parameters:
 * - tree: struct _GTree *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_tree_unref(mrb_state* mrb, mrb_value self) {
  mrb_value tree;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &tree);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, tree, GTree_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GTree expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GTree * native_tree = (mrb_nil_p(tree) ? NULL : mruby_unbox__GTree(tree));

  /* Invocation */
  g_tree_unref(native_tree);

  return mrb_nil_value();
}
#endif

#if BIND_g_try_malloc_FUNCTION
#define g_try_malloc_REQUIRED_ARGC 1
#define g_try_malloc_OPTIONAL_ARGC 0
/* g_try_malloc
 *
 * Parameters:
 * - n_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_try_malloc(mrb_state* mrb, mrb_value self) {
  mrb_int native_n_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_n_bytes);

  /* Invocation */
  gpointer native_return_value = g_try_malloc(native_n_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_try_malloc0_FUNCTION
#define g_try_malloc0_REQUIRED_ARGC 1
#define g_try_malloc0_OPTIONAL_ARGC 0
/* g_try_malloc0
 *
 * Parameters:
 * - n_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_try_malloc0(mrb_state* mrb, mrb_value self) {
  mrb_int native_n_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_n_bytes);

  /* Invocation */
  gpointer native_return_value = g_try_malloc0(native_n_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_try_malloc0_n_FUNCTION
#define g_try_malloc0_n_REQUIRED_ARGC 2
#define g_try_malloc0_n_OPTIONAL_ARGC 0
/* g_try_malloc0_n
 *
 * Parameters:
 * - n_blocks: unsigned long
 * - n_block_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_try_malloc0_n(mrb_state* mrb, mrb_value self) {
  mrb_int native_n_blocks;
  mrb_int native_n_block_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_n_blocks, &native_n_block_bytes);

  /* Invocation */
  gpointer native_return_value = g_try_malloc0_n(native_n_blocks, native_n_block_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_try_malloc_n_FUNCTION
#define g_try_malloc_n_REQUIRED_ARGC 2
#define g_try_malloc_n_OPTIONAL_ARGC 0
/* g_try_malloc_n
 *
 * Parameters:
 * - n_blocks: unsigned long
 * - n_block_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_try_malloc_n(mrb_state* mrb, mrb_value self) {
  mrb_int native_n_blocks;
  mrb_int native_n_block_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "ii", &native_n_blocks, &native_n_block_bytes);

  /* Invocation */
  gpointer native_return_value = g_try_malloc_n(native_n_blocks, native_n_block_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_try_realloc_FUNCTION
#define g_try_realloc_REQUIRED_ARGC 2
#define g_try_realloc_OPTIONAL_ARGC 0
/* g_try_realloc
 *
 * Parameters:
 * - mem: void *
 * - n_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_try_realloc(mrb_state* mrb, mrb_value self) {
  mrb_value mem;
  mrb_int native_n_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &mem, &native_n_bytes);

  /* Type checking */
  TODO_type_check_void_PTR(mem);

  /* Unbox parameters */
  void * native_mem = TODO_mruby_unbox_void_PTR(mem);

  /* Invocation */
  gpointer native_return_value = g_try_realloc(native_mem, native_n_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_try_realloc_n_FUNCTION
#define g_try_realloc_n_REQUIRED_ARGC 3
#define g_try_realloc_n_OPTIONAL_ARGC 0
/* g_try_realloc_n
 *
 * Parameters:
 * - mem: void *
 * - n_blocks: unsigned long
 * - n_block_bytes: unsigned long
 * Return Type: gpointer
 */
mrb_value
mrb_GLib_g_try_realloc_n(mrb_state* mrb, mrb_value self) {
  mrb_value mem;
  mrb_int native_n_blocks;
  mrb_int native_n_block_bytes;

  /* Fetch the args */
  mrb_get_args(mrb, "oii", &mem, &native_n_blocks, &native_n_block_bytes);

  /* Type checking */
  TODO_type_check_void_PTR(mem);

  /* Unbox parameters */
  void * native_mem = TODO_mruby_unbox_void_PTR(mem);

  /* Invocation */
  gpointer native_return_value = g_try_realloc_n(native_mem, native_n_blocks, native_n_block_bytes);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gpointer(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_ucs4_to_utf16_FUNCTION
#define g_ucs4_to_utf16_REQUIRED_ARGC 4
#define g_ucs4_to_utf16_OPTIONAL_ARGC 0
/* g_ucs4_to_utf16
 *
 * Parameters:
 * - str: const unsigned int *
 * - len: long
 * - items_read: long *
 * - items_written: long *
 * Return Type: gunichar2 *
 */
mrb_value
mrb_GLib_g_ucs4_to_utf16(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value str;
  mrb_int native_len;
  mrb_value items_read;
  mrb_value items_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &str, &native_len, &items_read, &items_written);

  /* Type checking */
  TODO_type_check_unsigned_int_PTR(str);
  TODO_type_check_long_PTR(items_read);
  TODO_type_check_long_PTR(items_written);

  /* Unbox parameters */
  const unsigned int * native_str = TODO_mruby_unbox_unsigned_int_PTR(str);

  long * native_items_read = TODO_mruby_unbox_long_PTR(items_read);

  long * native_items_written = TODO_mruby_unbox_long_PTR(items_written);

  /* Invocation */
  gunichar2 * native_return_value = g_ucs4_to_utf16(native_str, native_len, native_items_read, native_items_written, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gunichar2_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_ucs4_to_utf8_FUNCTION
#define g_ucs4_to_utf8_REQUIRED_ARGC 4
#define g_ucs4_to_utf8_OPTIONAL_ARGC 0
/* g_ucs4_to_utf8
 *
 * Parameters:
 * - str: const unsigned int *
 * - len: long
 * - items_read: long *
 * - items_written: long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_ucs4_to_utf8(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value str;
  mrb_int native_len;
  mrb_value items_read;
  mrb_value items_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &str, &native_len, &items_read, &items_written);

  /* Type checking */
  TODO_type_check_unsigned_int_PTR(str);
  TODO_type_check_long_PTR(items_read);
  TODO_type_check_long_PTR(items_written);

  /* Unbox parameters */
  const unsigned int * native_str = TODO_mruby_unbox_unsigned_int_PTR(str);

  long * native_items_read = TODO_mruby_unbox_long_PTR(items_read);

  long * native_items_written = TODO_mruby_unbox_long_PTR(items_written);

  /* Invocation */
  gchar * native_return_value = g_ucs4_to_utf8(native_str, native_len, native_items_read, native_items_written, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_unichar_break_type_FUNCTION
#define g_unichar_break_type_REQUIRED_ARGC 1
#define g_unichar_break_type_OPTIONAL_ARGC 0
/* g_unichar_break_type
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: GUnicodeBreakType
 */
mrb_value
mrb_GLib_g_unichar_break_type(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  GUnicodeBreakType native_return_value = g_unichar_break_type(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_combining_class_FUNCTION
#define g_unichar_combining_class_REQUIRED_ARGC 1
#define g_unichar_combining_class_OPTIONAL_ARGC 0
/* g_unichar_combining_class
 *
 * Parameters:
 * - uc: unsigned int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_unichar_combining_class(mrb_state* mrb, mrb_value self) {
  mrb_int native_uc;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_uc);

  /* Invocation */
  gint native_return_value = g_unichar_combining_class(native_uc);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_compose_FUNCTION
#define g_unichar_compose_REQUIRED_ARGC 3
#define g_unichar_compose_OPTIONAL_ARGC 0
/* g_unichar_compose
 *
 * Parameters:
 * - a: unsigned int
 * - b: unsigned int
 * - ch: unsigned int *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_compose(mrb_state* mrb, mrb_value self) {
  mrb_int native_a;
  mrb_int native_b;
  mrb_value ch;

  /* Fetch the args */
  mrb_get_args(mrb, "iio", &native_a, &native_b, &ch);

  /* Type checking */
  TODO_type_check_unsigned_int_PTR(ch);

  /* Unbox parameters */
  unsigned int * native_ch = TODO_mruby_unbox_unsigned_int_PTR(ch);

  /* Invocation */
  gboolean native_return_value = g_unichar_compose(native_a, native_b, native_ch);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_decompose_FUNCTION
#define g_unichar_decompose_REQUIRED_ARGC 3
#define g_unichar_decompose_OPTIONAL_ARGC 0
/* g_unichar_decompose
 *
 * Parameters:
 * - ch: unsigned int
 * - a: unsigned int *
 * - b: unsigned int *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_decompose(mrb_state* mrb, mrb_value self) {
  mrb_int native_ch;
  mrb_value a;
  mrb_value b;

  /* Fetch the args */
  mrb_get_args(mrb, "ioo", &native_ch, &a, &b);

  /* Type checking */
  TODO_type_check_unsigned_int_PTR(a);
  TODO_type_check_unsigned_int_PTR(b);

  /* Unbox parameters */
  unsigned int * native_a = TODO_mruby_unbox_unsigned_int_PTR(a);

  unsigned int * native_b = TODO_mruby_unbox_unsigned_int_PTR(b);

  /* Invocation */
  gboolean native_return_value = g_unichar_decompose(native_ch, native_a, native_b);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_digit_value_FUNCTION
#define g_unichar_digit_value_REQUIRED_ARGC 1
#define g_unichar_digit_value_OPTIONAL_ARGC 0
/* g_unichar_digit_value
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_unichar_digit_value(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gint native_return_value = g_unichar_digit_value(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_fully_decompose_FUNCTION
#define g_unichar_fully_decompose_REQUIRED_ARGC 4
#define g_unichar_fully_decompose_OPTIONAL_ARGC 0
/* g_unichar_fully_decompose
 *
 * Parameters:
 * - ch: unsigned int
 * - compat: int
 * - result: unsigned int *
 * - result_len: unsigned long
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_unichar_fully_decompose(mrb_state* mrb, mrb_value self) {
  mrb_int native_ch;
  mrb_int native_compat;
  mrb_value result;
  mrb_int native_result_len;

  /* Fetch the args */
  mrb_get_args(mrb, "iioi", &native_ch, &native_compat, &result, &native_result_len);

  /* Type checking */
  TODO_type_check_unsigned_int_PTR(result);

  /* Unbox parameters */
  unsigned int * native_result = TODO_mruby_unbox_unsigned_int_PTR(result);

  /* Invocation */
  gsize native_return_value = g_unichar_fully_decompose(native_ch, native_compat, native_result, native_result_len);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_get_mirror_char_FUNCTION
#define g_unichar_get_mirror_char_REQUIRED_ARGC 2
#define g_unichar_get_mirror_char_OPTIONAL_ARGC 0
/* g_unichar_get_mirror_char
 *
 * Parameters:
 * - ch: unsigned int
 * - mirrored_ch: unsigned int *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_get_mirror_char(mrb_state* mrb, mrb_value self) {
  mrb_int native_ch;
  mrb_value mirrored_ch;

  /* Fetch the args */
  mrb_get_args(mrb, "io", &native_ch, &mirrored_ch);

  /* Type checking */
  TODO_type_check_unsigned_int_PTR(mirrored_ch);

  /* Unbox parameters */
  unsigned int * native_mirrored_ch = TODO_mruby_unbox_unsigned_int_PTR(mirrored_ch);

  /* Invocation */
  gboolean native_return_value = g_unichar_get_mirror_char(native_ch, native_mirrored_ch);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_get_script_FUNCTION
#define g_unichar_get_script_REQUIRED_ARGC 1
#define g_unichar_get_script_OPTIONAL_ARGC 0
/* g_unichar_get_script
 *
 * Parameters:
 * - ch: unsigned int
 * Return Type: GUnicodeScript
 */
mrb_value
mrb_GLib_g_unichar_get_script(mrb_state* mrb, mrb_value self) {
  mrb_int native_ch;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_ch);

  /* Invocation */
  GUnicodeScript native_return_value = g_unichar_get_script(native_ch);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_isalnum_FUNCTION
#define g_unichar_isalnum_REQUIRED_ARGC 1
#define g_unichar_isalnum_OPTIONAL_ARGC 0
/* g_unichar_isalnum
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_isalnum(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_isalnum(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_isalpha_FUNCTION
#define g_unichar_isalpha_REQUIRED_ARGC 1
#define g_unichar_isalpha_OPTIONAL_ARGC 0
/* g_unichar_isalpha
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_isalpha(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_isalpha(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_iscntrl_FUNCTION
#define g_unichar_iscntrl_REQUIRED_ARGC 1
#define g_unichar_iscntrl_OPTIONAL_ARGC 0
/* g_unichar_iscntrl
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_iscntrl(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_iscntrl(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_isdefined_FUNCTION
#define g_unichar_isdefined_REQUIRED_ARGC 1
#define g_unichar_isdefined_OPTIONAL_ARGC 0
/* g_unichar_isdefined
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_isdefined(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_isdefined(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_isdigit_FUNCTION
#define g_unichar_isdigit_REQUIRED_ARGC 1
#define g_unichar_isdigit_OPTIONAL_ARGC 0
/* g_unichar_isdigit
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_isdigit(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_isdigit(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_isgraph_FUNCTION
#define g_unichar_isgraph_REQUIRED_ARGC 1
#define g_unichar_isgraph_OPTIONAL_ARGC 0
/* g_unichar_isgraph
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_isgraph(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_isgraph(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_islower_FUNCTION
#define g_unichar_islower_REQUIRED_ARGC 1
#define g_unichar_islower_OPTIONAL_ARGC 0
/* g_unichar_islower
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_islower(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_islower(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_ismark_FUNCTION
#define g_unichar_ismark_REQUIRED_ARGC 1
#define g_unichar_ismark_OPTIONAL_ARGC 0
/* g_unichar_ismark
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_ismark(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_ismark(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_isprint_FUNCTION
#define g_unichar_isprint_REQUIRED_ARGC 1
#define g_unichar_isprint_OPTIONAL_ARGC 0
/* g_unichar_isprint
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_isprint(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_isprint(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_ispunct_FUNCTION
#define g_unichar_ispunct_REQUIRED_ARGC 1
#define g_unichar_ispunct_OPTIONAL_ARGC 0
/* g_unichar_ispunct
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_ispunct(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_ispunct(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_isspace_FUNCTION
#define g_unichar_isspace_REQUIRED_ARGC 1
#define g_unichar_isspace_OPTIONAL_ARGC 0
/* g_unichar_isspace
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_isspace(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_isspace(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_istitle_FUNCTION
#define g_unichar_istitle_REQUIRED_ARGC 1
#define g_unichar_istitle_OPTIONAL_ARGC 0
/* g_unichar_istitle
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_istitle(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_istitle(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_isupper_FUNCTION
#define g_unichar_isupper_REQUIRED_ARGC 1
#define g_unichar_isupper_OPTIONAL_ARGC 0
/* g_unichar_isupper
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_isupper(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_isupper(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_iswide_FUNCTION
#define g_unichar_iswide_REQUIRED_ARGC 1
#define g_unichar_iswide_OPTIONAL_ARGC 0
/* g_unichar_iswide
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_iswide(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_iswide(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_iswide_cjk_FUNCTION
#define g_unichar_iswide_cjk_REQUIRED_ARGC 1
#define g_unichar_iswide_cjk_OPTIONAL_ARGC 0
/* g_unichar_iswide_cjk
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_iswide_cjk(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_iswide_cjk(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_isxdigit_FUNCTION
#define g_unichar_isxdigit_REQUIRED_ARGC 1
#define g_unichar_isxdigit_OPTIONAL_ARGC 0
/* g_unichar_isxdigit
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_isxdigit(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_isxdigit(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_iszerowidth_FUNCTION
#define g_unichar_iszerowidth_REQUIRED_ARGC 1
#define g_unichar_iszerowidth_OPTIONAL_ARGC 0
/* g_unichar_iszerowidth
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_iszerowidth(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gboolean native_return_value = g_unichar_iszerowidth(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_to_utf8_FUNCTION
#define g_unichar_to_utf8_REQUIRED_ARGC 2
#define g_unichar_to_utf8_OPTIONAL_ARGC 0
/* g_unichar_to_utf8
 *
 * Parameters:
 * - c: unsigned int
 * - outbuf: char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_unichar_to_utf8(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;
  char * outbuf = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "iz!", &native_c, &outbuf);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_outbuf = strdup(outbuf);

  /* Invocation */
  gint native_return_value = g_unichar_to_utf8(native_c, native_outbuf);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_outbuf);
  native_outbuf = NULL;

  return return_value;
}
#endif

#if BIND_g_unichar_tolower_FUNCTION
#define g_unichar_tolower_REQUIRED_ARGC 1
#define g_unichar_tolower_OPTIONAL_ARGC 0
/* g_unichar_tolower
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gunichar
 */
mrb_value
mrb_GLib_g_unichar_tolower(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gunichar native_return_value = g_unichar_tolower(native_c);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_totitle_FUNCTION
#define g_unichar_totitle_REQUIRED_ARGC 1
#define g_unichar_totitle_OPTIONAL_ARGC 0
/* g_unichar_totitle
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gunichar
 */
mrb_value
mrb_GLib_g_unichar_totitle(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gunichar native_return_value = g_unichar_totitle(native_c);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_toupper_FUNCTION
#define g_unichar_toupper_REQUIRED_ARGC 1
#define g_unichar_toupper_OPTIONAL_ARGC 0
/* g_unichar_toupper
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gunichar
 */
mrb_value
mrb_GLib_g_unichar_toupper(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gunichar native_return_value = g_unichar_toupper(native_c);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_type_FUNCTION
#define g_unichar_type_REQUIRED_ARGC 1
#define g_unichar_type_OPTIONAL_ARGC 0
/* g_unichar_type
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: GUnicodeType
 */
mrb_value
mrb_GLib_g_unichar_type(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  GUnicodeType native_return_value = g_unichar_type(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_validate_FUNCTION
#define g_unichar_validate_REQUIRED_ARGC 1
#define g_unichar_validate_OPTIONAL_ARGC 0
/* g_unichar_validate
 *
 * Parameters:
 * - ch: unsigned int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_unichar_validate(mrb_state* mrb, mrb_value self) {
  mrb_int native_ch;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_ch);

  /* Invocation */
  gboolean native_return_value = g_unichar_validate(native_ch);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unichar_xdigit_value_FUNCTION
#define g_unichar_xdigit_value_REQUIRED_ARGC 1
#define g_unichar_xdigit_value_OPTIONAL_ARGC 0
/* g_unichar_xdigit_value
 *
 * Parameters:
 * - c: unsigned int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_unichar_xdigit_value(mrb_state* mrb, mrb_value self) {
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_c);

  /* Invocation */
  gint native_return_value = g_unichar_xdigit_value(native_c);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unicode_canonical_decomposition_FUNCTION
#define g_unicode_canonical_decomposition_REQUIRED_ARGC 2
#define g_unicode_canonical_decomposition_OPTIONAL_ARGC 0
/* g_unicode_canonical_decomposition
 *
 * Parameters:
 * - ch: unsigned int
 * - result_len: unsigned long *
 * Return Type: gunichar *
 */
mrb_value
mrb_GLib_g_unicode_canonical_decomposition(mrb_state* mrb, mrb_value self) {
  mrb_int native_ch;
  mrb_value result_len;

  /* Fetch the args */
  mrb_get_args(mrb, "io", &native_ch, &result_len);

  /* Type checking */
  TODO_type_check_unsigned_long_PTR(result_len);

  /* Unbox parameters */
  unsigned long * native_result_len = TODO_mruby_unbox_unsigned_long_PTR(result_len);

  /* Invocation */
  gunichar * native_return_value = g_unicode_canonical_decomposition(native_ch, native_result_len);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gunichar_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unicode_canonical_ordering_FUNCTION
#define g_unicode_canonical_ordering_REQUIRED_ARGC 2
#define g_unicode_canonical_ordering_OPTIONAL_ARGC 0
/* g_unicode_canonical_ordering
 *
 * Parameters:
 * - string: unsigned int *
 * - len: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_unicode_canonical_ordering(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &string, &native_len);

  /* Type checking */
  TODO_type_check_unsigned_int_PTR(string);

  /* Unbox parameters */
  unsigned int * native_string = TODO_mruby_unbox_unsigned_int_PTR(string);

  /* Invocation */
  g_unicode_canonical_ordering(native_string, native_len);

  return mrb_nil_value();
}
#endif

#if BIND_g_unicode_script_from_iso15924_FUNCTION
#define g_unicode_script_from_iso15924_REQUIRED_ARGC 1
#define g_unicode_script_from_iso15924_OPTIONAL_ARGC 0
/* g_unicode_script_from_iso15924
 *
 * Parameters:
 * - iso15924: unsigned int
 * Return Type: GUnicodeScript
 */
mrb_value
mrb_GLib_g_unicode_script_from_iso15924(mrb_state* mrb, mrb_value self) {
  mrb_int native_iso15924;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_iso15924);

  /* Invocation */
  GUnicodeScript native_return_value = g_unicode_script_from_iso15924(native_iso15924);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unicode_script_to_iso15924_FUNCTION
#define g_unicode_script_to_iso15924_REQUIRED_ARGC 1
#define g_unicode_script_to_iso15924_OPTIONAL_ARGC 0
/* g_unicode_script_to_iso15924
 *
 * Parameters:
 * - script: GUnicodeScript
 * Return Type: guint32
 */
mrb_value
mrb_GLib_g_unicode_script_to_iso15924(mrb_state* mrb, mrb_value self) {
  mrb_int native_script;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_script);

  /* Invocation */
  guint32 native_return_value = g_unicode_script_to_iso15924(native_script);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unlink_FUNCTION
#define g_unlink_REQUIRED_ARGC 1
#define g_unlink_OPTIONAL_ARGC 0
/* g_unlink
 *
 * Parameters:
 * - filename: const char *
 * Return Type: int
 */
mrb_value
mrb_GLib_g_unlink(mrb_state* mrb, mrb_value self) {
  char * native_filename = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_filename);

  /* Invocation */
  int native_return_value = g_unlink(native_filename);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_unsetenv_FUNCTION
#define g_unsetenv_REQUIRED_ARGC 1
#define g_unsetenv_OPTIONAL_ARGC 0
/* g_unsetenv
 *
 * Parameters:
 * - variable: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_unsetenv(mrb_state* mrb, mrb_value self) {
  char * native_variable = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_variable);

  /* Invocation */
  g_unsetenv(native_variable);

  return mrb_nil_value();
}
#endif

#if BIND_g_uri_escape_string_FUNCTION
#define g_uri_escape_string_REQUIRED_ARGC 3
#define g_uri_escape_string_OPTIONAL_ARGC 0
/* g_uri_escape_string
 *
 * Parameters:
 * - unescaped: const char *
 * - reserved_chars_allowed: const char *
 * - allow_utf8: int
 * Return Type: char *
 */
mrb_value
mrb_GLib_g_uri_escape_string(mrb_state* mrb, mrb_value self) {
  char * native_unescaped = NULL;
  char * native_reserved_chars_allowed = NULL;
  mrb_int native_allow_utf8;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &native_unescaped, &native_reserved_chars_allowed, &native_allow_utf8);

  /* Invocation */
  char * native_return_value = g_uri_escape_string(native_unescaped, native_reserved_chars_allowed, native_allow_utf8);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_uri_list_extract_uris_FUNCTION
#define g_uri_list_extract_uris_REQUIRED_ARGC 1
#define g_uri_list_extract_uris_OPTIONAL_ARGC 0
/* g_uri_list_extract_uris
 *
 * Parameters:
 * - uri_list: const char *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_uri_list_extract_uris(mrb_state* mrb, mrb_value self) {
  char * native_uri_list = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_uri_list);

  /* Invocation */
  gchar ** native_return_value = g_uri_list_extract_uris(native_uri_list);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_uri_parse_scheme_FUNCTION
#define g_uri_parse_scheme_REQUIRED_ARGC 1
#define g_uri_parse_scheme_OPTIONAL_ARGC 0
/* g_uri_parse_scheme
 *
 * Parameters:
 * - uri: const char *
 * Return Type: char *
 */
mrb_value
mrb_GLib_g_uri_parse_scheme(mrb_state* mrb, mrb_value self) {
  char * native_uri = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_uri);

  /* Invocation */
  char * native_return_value = g_uri_parse_scheme(native_uri);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_uri_unescape_segment_FUNCTION
#define g_uri_unescape_segment_REQUIRED_ARGC 3
#define g_uri_unescape_segment_OPTIONAL_ARGC 0
/* g_uri_unescape_segment
 *
 * Parameters:
 * - escaped_string: const char *
 * - escaped_string_end: const char *
 * - illegal_characters: const char *
 * Return Type: char *
 */
mrb_value
mrb_GLib_g_uri_unescape_segment(mrb_state* mrb, mrb_value self) {
  char * native_escaped_string = NULL;
  char * native_escaped_string_end = NULL;
  char * native_illegal_characters = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!z!", &native_escaped_string, &native_escaped_string_end, &native_illegal_characters);

  /* Invocation */
  char * native_return_value = g_uri_unescape_segment(native_escaped_string, native_escaped_string_end, native_illegal_characters);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_uri_unescape_string_FUNCTION
#define g_uri_unescape_string_REQUIRED_ARGC 2
#define g_uri_unescape_string_OPTIONAL_ARGC 0
/* g_uri_unescape_string
 *
 * Parameters:
 * - escaped_string: const char *
 * - illegal_characters: const char *
 * Return Type: char *
 */
mrb_value
mrb_GLib_g_uri_unescape_string(mrb_state* mrb, mrb_value self) {
  char * native_escaped_string = NULL;
  char * native_illegal_characters = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_escaped_string, &native_illegal_characters);

  /* Invocation */
  char * native_return_value = g_uri_unescape_string(native_escaped_string, native_illegal_characters);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_usleep_FUNCTION
#define g_usleep_REQUIRED_ARGC 1
#define g_usleep_OPTIONAL_ARGC 0
/* g_usleep
 *
 * Parameters:
 * - microseconds: unsigned long
 * Return Type: void
 */
mrb_value
mrb_GLib_g_usleep(mrb_state* mrb, mrb_value self) {
  mrb_int native_microseconds;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_microseconds);

  /* Invocation */
  g_usleep(native_microseconds);

  return mrb_nil_value();
}
#endif

#if BIND_g_utf16_to_ucs4_FUNCTION
#define g_utf16_to_ucs4_REQUIRED_ARGC 4
#define g_utf16_to_ucs4_OPTIONAL_ARGC 0
/* g_utf16_to_ucs4
 *
 * Parameters:
 * - str: const unsigned short *
 * - len: long
 * - items_read: long *
 * - items_written: long *
 * Return Type: gunichar *
 */
mrb_value
mrb_GLib_g_utf16_to_ucs4(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value str;
  mrb_int native_len;
  mrb_value items_read;
  mrb_value items_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &str, &native_len, &items_read, &items_written);

  /* Type checking */
  TODO_type_check_unsigned_short_PTR(str);
  TODO_type_check_long_PTR(items_read);
  TODO_type_check_long_PTR(items_written);

  /* Unbox parameters */
  const unsigned short * native_str = TODO_mruby_unbox_unsigned_short_PTR(str);

  long * native_items_read = TODO_mruby_unbox_long_PTR(items_read);

  long * native_items_written = TODO_mruby_unbox_long_PTR(items_written);

  /* Invocation */
  gunichar * native_return_value = g_utf16_to_ucs4(native_str, native_len, native_items_read, native_items_written, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gunichar_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_utf16_to_utf8_FUNCTION
#define g_utf16_to_utf8_REQUIRED_ARGC 4
#define g_utf16_to_utf8_OPTIONAL_ARGC 0
/* g_utf16_to_utf8
 *
 * Parameters:
 * - str: const unsigned short *
 * - len: long
 * - items_read: long *
 * - items_written: long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf16_to_utf8(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value str;
  mrb_int native_len;
  mrb_value items_read;
  mrb_value items_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oioo", &str, &native_len, &items_read, &items_written);

  /* Type checking */
  TODO_type_check_unsigned_short_PTR(str);
  TODO_type_check_long_PTR(items_read);
  TODO_type_check_long_PTR(items_written);

  /* Unbox parameters */
  const unsigned short * native_str = TODO_mruby_unbox_unsigned_short_PTR(str);

  long * native_items_read = TODO_mruby_unbox_long_PTR(items_read);

  long * native_items_written = TODO_mruby_unbox_long_PTR(items_written);

  /* Invocation */
  gchar * native_return_value = g_utf16_to_utf8(native_str, native_len, native_items_read, native_items_written, &native_error);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_utf8_casefold_FUNCTION
#define g_utf8_casefold_REQUIRED_ARGC 2
#define g_utf8_casefold_OPTIONAL_ARGC 0
/* g_utf8_casefold
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_casefold(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_str, &native_len);

  /* Invocation */
  gchar * native_return_value = g_utf8_casefold(native_str, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_collate_FUNCTION
#define g_utf8_collate_REQUIRED_ARGC 2
#define g_utf8_collate_OPTIONAL_ARGC 0
/* g_utf8_collate
 *
 * Parameters:
 * - str1: const char *
 * - str2: const char *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_utf8_collate(mrb_state* mrb, mrb_value self) {
  char * native_str1 = NULL;
  char * native_str2 = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_str1, &native_str2);

  /* Invocation */
  gint native_return_value = g_utf8_collate(native_str1, native_str2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_collate_key_FUNCTION
#define g_utf8_collate_key_REQUIRED_ARGC 2
#define g_utf8_collate_key_OPTIONAL_ARGC 0
/* g_utf8_collate_key
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_collate_key(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_str, &native_len);

  /* Invocation */
  gchar * native_return_value = g_utf8_collate_key(native_str, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_collate_key_for_filename_FUNCTION
#define g_utf8_collate_key_for_filename_REQUIRED_ARGC 2
#define g_utf8_collate_key_for_filename_OPTIONAL_ARGC 0
/* g_utf8_collate_key_for_filename
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_collate_key_for_filename(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_str, &native_len);

  /* Invocation */
  gchar * native_return_value = g_utf8_collate_key_for_filename(native_str, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_find_next_char_FUNCTION
#define g_utf8_find_next_char_REQUIRED_ARGC 2
#define g_utf8_find_next_char_OPTIONAL_ARGC 0
/* g_utf8_find_next_char
 *
 * Parameters:
 * - p: const char *
 * - end: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_find_next_char(mrb_state* mrb, mrb_value self) {
  char * native_p = NULL;
  char * native_end = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_p, &native_end);

  /* Invocation */
  gchar * native_return_value = g_utf8_find_next_char(native_p, native_end);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_find_prev_char_FUNCTION
#define g_utf8_find_prev_char_REQUIRED_ARGC 2
#define g_utf8_find_prev_char_OPTIONAL_ARGC 0
/* g_utf8_find_prev_char
 *
 * Parameters:
 * - str: const char *
 * - p: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_find_prev_char(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  char * native_p = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_str, &native_p);

  /* Invocation */
  gchar * native_return_value = g_utf8_find_prev_char(native_str, native_p);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_get_char_FUNCTION
#define g_utf8_get_char_REQUIRED_ARGC 1
#define g_utf8_get_char_OPTIONAL_ARGC 0
/* g_utf8_get_char
 *
 * Parameters:
 * - p: const char *
 * Return Type: gunichar
 */
mrb_value
mrb_GLib_g_utf8_get_char(mrb_state* mrb, mrb_value self) {
  char * native_p = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_p);

  /* Invocation */
  gunichar native_return_value = g_utf8_get_char(native_p);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_get_char_validated_FUNCTION
#define g_utf8_get_char_validated_REQUIRED_ARGC 2
#define g_utf8_get_char_validated_OPTIONAL_ARGC 0
/* g_utf8_get_char_validated
 *
 * Parameters:
 * - p: const char *
 * - max_len: long
 * Return Type: gunichar
 */
mrb_value
mrb_GLib_g_utf8_get_char_validated(mrb_state* mrb, mrb_value self) {
  char * native_p = NULL;
  mrb_int native_max_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_p, &native_max_len);

  /* Invocation */
  gunichar native_return_value = g_utf8_get_char_validated(native_p, native_max_len);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_normalize_FUNCTION
#define g_utf8_normalize_REQUIRED_ARGC 3
#define g_utf8_normalize_OPTIONAL_ARGC 0
/* g_utf8_normalize
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * - mode: GNormalizeMode
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_normalize(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_len;
  mrb_int native_mode;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ii", &native_str, &native_len, &native_mode);

  /* Invocation */
  gchar * native_return_value = g_utf8_normalize(native_str, native_len, native_mode);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_offset_to_pointer_FUNCTION
#define g_utf8_offset_to_pointer_REQUIRED_ARGC 2
#define g_utf8_offset_to_pointer_OPTIONAL_ARGC 0
/* g_utf8_offset_to_pointer
 *
 * Parameters:
 * - str: const char *
 * - offset: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_offset_to_pointer(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_offset;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_str, &native_offset);

  /* Invocation */
  gchar * native_return_value = g_utf8_offset_to_pointer(native_str, native_offset);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_pointer_to_offset_FUNCTION
#define g_utf8_pointer_to_offset_REQUIRED_ARGC 2
#define g_utf8_pointer_to_offset_OPTIONAL_ARGC 0
/* g_utf8_pointer_to_offset
 *
 * Parameters:
 * - str: const char *
 * - pos: const char *
 * Return Type: glong
 */
mrb_value
mrb_GLib_g_utf8_pointer_to_offset(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  char * native_pos = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!", &native_str, &native_pos);

  /* Invocation */
  glong native_return_value = g_utf8_pointer_to_offset(native_str, native_pos);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_prev_char_FUNCTION
#define g_utf8_prev_char_REQUIRED_ARGC 1
#define g_utf8_prev_char_OPTIONAL_ARGC 0
/* g_utf8_prev_char
 *
 * Parameters:
 * - p: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_prev_char(mrb_state* mrb, mrb_value self) {
  char * native_p = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_p);

  /* Invocation */
  gchar * native_return_value = g_utf8_prev_char(native_p);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_strchr_FUNCTION
#define g_utf8_strchr_REQUIRED_ARGC 3
#define g_utf8_strchr_OPTIONAL_ARGC 0
/* g_utf8_strchr
 *
 * Parameters:
 * - p: const char *
 * - len: long
 * - c: unsigned int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_strchr(mrb_state* mrb, mrb_value self) {
  char * native_p = NULL;
  mrb_int native_len;
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ii", &native_p, &native_len, &native_c);

  /* Invocation */
  gchar * native_return_value = g_utf8_strchr(native_p, native_len, native_c);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_strdown_FUNCTION
#define g_utf8_strdown_REQUIRED_ARGC 2
#define g_utf8_strdown_OPTIONAL_ARGC 0
/* g_utf8_strdown
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_strdown(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_str, &native_len);

  /* Invocation */
  gchar * native_return_value = g_utf8_strdown(native_str, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_strlen_FUNCTION
#define g_utf8_strlen_REQUIRED_ARGC 2
#define g_utf8_strlen_OPTIONAL_ARGC 0
/* g_utf8_strlen
 *
 * Parameters:
 * - p: const char *
 * - max: long
 * Return Type: glong
 */
mrb_value
mrb_GLib_g_utf8_strlen(mrb_state* mrb, mrb_value self) {
  char * native_p = NULL;
  mrb_int native_max;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_p, &native_max);

  /* Invocation */
  glong native_return_value = g_utf8_strlen(native_p, native_max);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_strncpy_FUNCTION
#define g_utf8_strncpy_REQUIRED_ARGC 3
#define g_utf8_strncpy_OPTIONAL_ARGC 0
/* g_utf8_strncpy
 *
 * Parameters:
 * - dest: char *
 * - src: const char *
 * - n: unsigned long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_strncpy(mrb_state* mrb, mrb_value self) {
  char * dest = NULL;
  char * native_src = NULL;
  mrb_int native_n;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!i", &dest, &native_src, &native_n);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_dest = strdup(dest);

  /* Invocation */
  gchar * native_return_value = g_utf8_strncpy(native_dest, native_src, native_n);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_dest);
  native_dest = NULL;

  return return_value;
}
#endif

#if BIND_g_utf8_strrchr_FUNCTION
#define g_utf8_strrchr_REQUIRED_ARGC 3
#define g_utf8_strrchr_OPTIONAL_ARGC 0
/* g_utf8_strrchr
 *
 * Parameters:
 * - p: const char *
 * - len: long
 * - c: unsigned int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_strrchr(mrb_state* mrb, mrb_value self) {
  char * native_p = NULL;
  mrb_int native_len;
  mrb_int native_c;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ii", &native_p, &native_len, &native_c);

  /* Invocation */
  gchar * native_return_value = g_utf8_strrchr(native_p, native_len, native_c);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_strreverse_FUNCTION
#define g_utf8_strreverse_REQUIRED_ARGC 2
#define g_utf8_strreverse_OPTIONAL_ARGC 0
/* g_utf8_strreverse
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_strreverse(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_str, &native_len);

  /* Invocation */
  gchar * native_return_value = g_utf8_strreverse(native_str, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_strup_FUNCTION
#define g_utf8_strup_REQUIRED_ARGC 2
#define g_utf8_strup_OPTIONAL_ARGC 0
/* g_utf8_strup
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_strup(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_len;

  /* Fetch the args */
  mrb_get_args(mrb, "z!i", &native_str, &native_len);

  /* Invocation */
  gchar * native_return_value = g_utf8_strup(native_str, native_len);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_substring_FUNCTION
#define g_utf8_substring_REQUIRED_ARGC 3
#define g_utf8_substring_OPTIONAL_ARGC 0
/* g_utf8_substring
 *
 * Parameters:
 * - str: const char *
 * - start_pos: long
 * - end_pos: long
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_utf8_substring(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_start_pos;
  mrb_int native_end_pos;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ii", &native_str, &native_start_pos, &native_end_pos);

  /* Invocation */
  gchar * native_return_value = g_utf8_substring(native_str, native_start_pos, native_end_pos);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_to_ucs4_FUNCTION
#define g_utf8_to_ucs4_REQUIRED_ARGC 4
#define g_utf8_to_ucs4_OPTIONAL_ARGC 0
/* g_utf8_to_ucs4
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * - items_read: long *
 * - items_written: long *
 * Return Type: gunichar *
 */
mrb_value
mrb_GLib_g_utf8_to_ucs4(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_str = NULL;
  mrb_int native_len;
  mrb_value items_read;
  mrb_value items_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ioo", &native_str, &native_len, &items_read, &items_written);

  /* Type checking */
  TODO_type_check_long_PTR(items_read);
  TODO_type_check_long_PTR(items_written);

  /* Unbox parameters */
  long * native_items_read = TODO_mruby_unbox_long_PTR(items_read);

  long * native_items_written = TODO_mruby_unbox_long_PTR(items_written);

  /* Invocation */
  gunichar * native_return_value = g_utf8_to_ucs4(native_str, native_len, native_items_read, native_items_written, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gunichar_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_utf8_to_ucs4_fast_FUNCTION
#define g_utf8_to_ucs4_fast_REQUIRED_ARGC 3
#define g_utf8_to_ucs4_fast_OPTIONAL_ARGC 0
/* g_utf8_to_ucs4_fast
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * - items_written: long *
 * Return Type: gunichar *
 */
mrb_value
mrb_GLib_g_utf8_to_ucs4_fast(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_len;
  mrb_value items_written;

  /* Fetch the args */
  mrb_get_args(mrb, "z!io", &native_str, &native_len, &items_written);

  /* Type checking */
  TODO_type_check_long_PTR(items_written);

  /* Unbox parameters */
  long * native_items_written = TODO_mruby_unbox_long_PTR(items_written);

  /* Invocation */
  gunichar * native_return_value = g_utf8_to_ucs4_fast(native_str, native_len, native_items_written);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gunichar_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_utf8_to_utf16_FUNCTION
#define g_utf8_to_utf16_REQUIRED_ARGC 4
#define g_utf8_to_utf16_OPTIONAL_ARGC 0
/* g_utf8_to_utf16
 *
 * Parameters:
 * - str: const char *
 * - len: long
 * - items_read: long *
 * - items_written: long *
 * Return Type: gunichar2 *
 */
mrb_value
mrb_GLib_g_utf8_to_utf16(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  char * native_str = NULL;
  mrb_int native_len;
  mrb_value items_read;
  mrb_value items_written;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!ioo", &native_str, &native_len, &items_read, &items_written);

  /* Type checking */
  TODO_type_check_long_PTR(items_read);
  TODO_type_check_long_PTR(items_written);

  /* Unbox parameters */
  long * native_items_read = TODO_mruby_unbox_long_PTR(items_read);

  long * native_items_written = TODO_mruby_unbox_long_PTR(items_written);

  /* Invocation */
  gunichar2 * native_return_value = g_utf8_to_utf16(native_str, native_len, native_items_read, native_items_written, &native_error);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gunichar2_PTR(mrb, native_return_value);
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_utf8_validate_FUNCTION
#define g_utf8_validate_REQUIRED_ARGC 3
#define g_utf8_validate_OPTIONAL_ARGC 0
/* g_utf8_validate
 *
 * Parameters:
 * - str: const char *
 * - max_len: long
 * - end: const char **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_utf8_validate(mrb_state* mrb, mrb_value self) {
  char * native_str = NULL;
  mrb_int native_max_len;
  mrb_value end;

  /* Fetch the args */
  mrb_get_args(mrb, "z!io", &native_str, &native_max_len, &end);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(end);

  /* Unbox parameters */
  const char ** native_end = TODO_mruby_unbox_char_PTR_PTR(end);

  /* Invocation */
  gboolean native_return_value = g_utf8_validate(native_str, native_max_len, native_end);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_builder_add_FUNCTION
#define g_variant_builder_add_REQUIRED_ARGC 2
#define g_variant_builder_add_OPTIONAL_ARGC 0
/* g_variant_builder_add
 *
 * Parameters:
 * - builder: struct _GVariantBuilder *
 * - format_string: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_builder_add(mrb_state* mrb, mrb_value self) {
  mrb_value builder;
  char * native_format_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &builder, &native_format_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, builder, GVariantBuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantBuilder expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantBuilder * native_builder = (mrb_nil_p(builder) ? NULL : mruby_unbox__GVariantBuilder(builder));

  /* Invocation */
  g_variant_builder_add(native_builder, native_format_string);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_builder_add_parsed_FUNCTION
#define g_variant_builder_add_parsed_REQUIRED_ARGC 2
#define g_variant_builder_add_parsed_OPTIONAL_ARGC 0
/* g_variant_builder_add_parsed
 *
 * Parameters:
 * - builder: struct _GVariantBuilder *
 * - format: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_builder_add_parsed(mrb_state* mrb, mrb_value self) {
  mrb_value builder;
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &builder, &native_format);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, builder, GVariantBuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantBuilder expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantBuilder * native_builder = (mrb_nil_p(builder) ? NULL : mruby_unbox__GVariantBuilder(builder));

  /* Invocation */
  g_variant_builder_add_parsed(native_builder, native_format);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_builder_add_value_FUNCTION
#define g_variant_builder_add_value_REQUIRED_ARGC 2
#define g_variant_builder_add_value_OPTIONAL_ARGC 0
/* g_variant_builder_add_value
 *
 * Parameters:
 * - builder: struct _GVariantBuilder *
 * - value: struct _GVariant *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_builder_add_value(mrb_state* mrb, mrb_value self) {
  mrb_value builder;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &builder, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, builder, GVariantBuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantBuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantBuilder * native_builder = (mrb_nil_p(builder) ? NULL : mruby_unbox__GVariantBuilder(builder));

  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  g_variant_builder_add_value(native_builder, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_builder_clear_FUNCTION
#define g_variant_builder_clear_REQUIRED_ARGC 1
#define g_variant_builder_clear_OPTIONAL_ARGC 0
/* g_variant_builder_clear
 *
 * Parameters:
 * - builder: struct _GVariantBuilder *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_builder_clear(mrb_state* mrb, mrb_value self) {
  mrb_value builder;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &builder);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, builder, GVariantBuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantBuilder expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantBuilder * native_builder = (mrb_nil_p(builder) ? NULL : mruby_unbox__GVariantBuilder(builder));

  /* Invocation */
  g_variant_builder_clear(native_builder);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_builder_close_FUNCTION
#define g_variant_builder_close_REQUIRED_ARGC 1
#define g_variant_builder_close_OPTIONAL_ARGC 0
/* g_variant_builder_close
 *
 * Parameters:
 * - builder: struct _GVariantBuilder *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_builder_close(mrb_state* mrb, mrb_value self) {
  mrb_value builder;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &builder);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, builder, GVariantBuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantBuilder expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantBuilder * native_builder = (mrb_nil_p(builder) ? NULL : mruby_unbox__GVariantBuilder(builder));

  /* Invocation */
  g_variant_builder_close(native_builder);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_builder_end_FUNCTION
#define g_variant_builder_end_REQUIRED_ARGC 1
#define g_variant_builder_end_OPTIONAL_ARGC 0
/* g_variant_builder_end
 *
 * Parameters:
 * - builder: struct _GVariantBuilder *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_builder_end(mrb_state* mrb, mrb_value self) {
  mrb_value builder;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &builder);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, builder, GVariantBuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantBuilder expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantBuilder * native_builder = (mrb_nil_p(builder) ? NULL : mruby_unbox__GVariantBuilder(builder));

  /* Invocation */
  GVariant * native_return_value = g_variant_builder_end(native_builder);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_builder_init_FUNCTION
#define g_variant_builder_init_REQUIRED_ARGC 2
#define g_variant_builder_init_OPTIONAL_ARGC 0
/* g_variant_builder_init
 *
 * Parameters:
 * - builder: struct _GVariantBuilder *
 * - type: const struct _GVariantType *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_builder_init(mrb_state* mrb, mrb_value self) {
  mrb_value builder;
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &builder, &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, builder, GVariantBuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantBuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantBuilder * native_builder = (mrb_nil_p(builder) ? NULL : mruby_unbox__GVariantBuilder(builder));

  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  g_variant_builder_init(native_builder, native_type);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_builder_new_FUNCTION
#define g_variant_builder_new_REQUIRED_ARGC 1
#define g_variant_builder_new_OPTIONAL_ARGC 0
/* g_variant_builder_new
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: GVariantBuilder *
 */
mrb_value
mrb_GLib_g_variant_builder_new(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  GVariantBuilder * native_return_value = g_variant_builder_new(native_type);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantBuilder(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_builder_open_FUNCTION
#define g_variant_builder_open_REQUIRED_ARGC 2
#define g_variant_builder_open_OPTIONAL_ARGC 0
/* g_variant_builder_open
 *
 * Parameters:
 * - builder: struct _GVariantBuilder *
 * - type: const struct _GVariantType *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_builder_open(mrb_state* mrb, mrb_value self) {
  mrb_value builder;
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &builder, &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, builder, GVariantBuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantBuilder expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantBuilder * native_builder = (mrb_nil_p(builder) ? NULL : mruby_unbox__GVariantBuilder(builder));

  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  g_variant_builder_open(native_builder, native_type);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_builder_ref_FUNCTION
#define g_variant_builder_ref_REQUIRED_ARGC 1
#define g_variant_builder_ref_OPTIONAL_ARGC 0
/* g_variant_builder_ref
 *
 * Parameters:
 * - builder: struct _GVariantBuilder *
 * Return Type: GVariantBuilder *
 */
mrb_value
mrb_GLib_g_variant_builder_ref(mrb_state* mrb, mrb_value self) {
  mrb_value builder;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &builder);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, builder, GVariantBuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantBuilder expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantBuilder * native_builder = (mrb_nil_p(builder) ? NULL : mruby_unbox__GVariantBuilder(builder));

  /* Invocation */
  GVariantBuilder * native_return_value = g_variant_builder_ref(native_builder);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantBuilder(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_builder_unref_FUNCTION
#define g_variant_builder_unref_REQUIRED_ARGC 1
#define g_variant_builder_unref_OPTIONAL_ARGC 0
/* g_variant_builder_unref
 *
 * Parameters:
 * - builder: struct _GVariantBuilder *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_builder_unref(mrb_state* mrb, mrb_value self) {
  mrb_value builder;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &builder);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, builder, GVariantBuilder_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantBuilder expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantBuilder * native_builder = (mrb_nil_p(builder) ? NULL : mruby_unbox__GVariantBuilder(builder));

  /* Invocation */
  g_variant_builder_unref(native_builder);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_byteswap_FUNCTION
#define g_variant_byteswap_REQUIRED_ARGC 1
#define g_variant_byteswap_OPTIONAL_ARGC 0
/* g_variant_byteswap
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_byteswap(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariant * native_return_value = g_variant_byteswap(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_check_format_string_FUNCTION
#define g_variant_check_format_string_REQUIRED_ARGC 3
#define g_variant_check_format_string_OPTIONAL_ARGC 0
/* g_variant_check_format_string
 *
 * Parameters:
 * - value: struct _GVariant *
 * - format_string: const char *
 * - copy_only: int
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_check_format_string(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  char * native_format_string = NULL;
  mrb_int native_copy_only;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!i", &value, &native_format_string, &native_copy_only);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gboolean native_return_value = g_variant_check_format_string(native_value, native_format_string, native_copy_only);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_classify_FUNCTION
#define g_variant_classify_REQUIRED_ARGC 1
#define g_variant_classify_OPTIONAL_ARGC 0
/* g_variant_classify
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GVariantClass
 */
mrb_value
mrb_GLib_g_variant_classify(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariantClass native_return_value = g_variant_classify(native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_compare_FUNCTION
#define g_variant_compare_REQUIRED_ARGC 2
#define g_variant_compare_OPTIONAL_ARGC 0
/* g_variant_compare
 *
 * Parameters:
 * - one: const void *
 * - two: const void *
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_variant_compare(mrb_state* mrb, mrb_value self) {
  mrb_value one;
  mrb_value two;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &one, &two);

  /* Type checking */
  TODO_type_check_void_PTR(one);
  TODO_type_check_void_PTR(two);

  /* Unbox parameters */
  const void * native_one = TODO_mruby_unbox_void_PTR(one);

  const void * native_two = TODO_mruby_unbox_void_PTR(two);

  /* Invocation */
  gint native_return_value = g_variant_compare(native_one, native_two);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_dict_clear_FUNCTION
#define g_variant_dict_clear_REQUIRED_ARGC 1
#define g_variant_dict_clear_OPTIONAL_ARGC 0
/* g_variant_dict_clear
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_dict_clear(mrb_state* mrb, mrb_value self) {
  mrb_value dict;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &dict);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  /* Invocation */
  g_variant_dict_clear(native_dict);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_dict_contains_FUNCTION
#define g_variant_dict_contains_REQUIRED_ARGC 2
#define g_variant_dict_contains_OPTIONAL_ARGC 0
/* g_variant_dict_contains
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * - key: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_dict_contains(mrb_state* mrb, mrb_value self) {
  mrb_value dict;
  char * native_key = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &dict, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  /* Invocation */
  gboolean native_return_value = g_variant_dict_contains(native_dict, native_key);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_dict_end_FUNCTION
#define g_variant_dict_end_REQUIRED_ARGC 1
#define g_variant_dict_end_OPTIONAL_ARGC 0
/* g_variant_dict_end
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_dict_end(mrb_state* mrb, mrb_value self) {
  mrb_value dict;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &dict);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  /* Invocation */
  GVariant * native_return_value = g_variant_dict_end(native_dict);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_dict_init_FUNCTION
#define g_variant_dict_init_REQUIRED_ARGC 2
#define g_variant_dict_init_OPTIONAL_ARGC 0
/* g_variant_dict_init
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * - from_asv: struct _GVariant *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_dict_init(mrb_state* mrb, mrb_value self) {
  mrb_value dict;
  mrb_value from_asv;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &dict, &from_asv);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, from_asv, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  struct _GVariant * native_from_asv = (mrb_nil_p(from_asv) ? NULL : mruby_unbox__GVariant(from_asv));

  /* Invocation */
  g_variant_dict_init(native_dict, native_from_asv);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_dict_insert_FUNCTION
#define g_variant_dict_insert_REQUIRED_ARGC 3
#define g_variant_dict_insert_OPTIONAL_ARGC 0
/* g_variant_dict_insert
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * - key: const char *
 * - format_string: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_dict_insert(mrb_state* mrb, mrb_value self) {
  mrb_value dict;
  char * native_key = NULL;
  char * native_format_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &dict, &native_key, &native_format_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  /* Invocation */
  g_variant_dict_insert(native_dict, native_key, native_format_string);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_dict_insert_value_FUNCTION
#define g_variant_dict_insert_value_REQUIRED_ARGC 3
#define g_variant_dict_insert_value_OPTIONAL_ARGC 0
/* g_variant_dict_insert_value
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * - key: const char *
 * - value: struct _GVariant *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_dict_insert_value(mrb_state* mrb, mrb_value self) {
  mrb_value dict;
  char * native_key = NULL;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!o", &dict, &native_key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  g_variant_dict_insert_value(native_dict, native_key, native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_dict_lookup_FUNCTION
#define g_variant_dict_lookup_REQUIRED_ARGC 3
#define g_variant_dict_lookup_OPTIONAL_ARGC 0
/* g_variant_dict_lookup
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * - key: const char *
 * - format_string: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_dict_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value dict;
  char * native_key = NULL;
  char * native_format_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &dict, &native_key, &native_format_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  /* Invocation */
  gboolean native_return_value = g_variant_dict_lookup(native_dict, native_key, native_format_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_dict_lookup_value_FUNCTION
#define g_variant_dict_lookup_value_REQUIRED_ARGC 3
#define g_variant_dict_lookup_value_OPTIONAL_ARGC 0
/* g_variant_dict_lookup_value
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * - key: const char *
 * - expected_type: const struct _GVariantType *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_dict_lookup_value(mrb_state* mrb, mrb_value self) {
  mrb_value dict;
  char * native_key = NULL;
  mrb_value expected_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!o", &dict, &native_key, &expected_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, expected_type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  const struct _GVariantType * native_expected_type = (mrb_nil_p(expected_type) ? NULL : mruby_unbox__GVariantType(expected_type));

  /* Invocation */
  GVariant * native_return_value = g_variant_dict_lookup_value(native_dict, native_key, native_expected_type);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_dict_new_FUNCTION
#define g_variant_dict_new_REQUIRED_ARGC 1
#define g_variant_dict_new_OPTIONAL_ARGC 0
/* g_variant_dict_new
 *
 * Parameters:
 * - from_asv: struct _GVariant *
 * Return Type: GVariantDict *
 */
mrb_value
mrb_GLib_g_variant_dict_new(mrb_state* mrb, mrb_value self) {
  mrb_value from_asv;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &from_asv);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, from_asv, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_from_asv = (mrb_nil_p(from_asv) ? NULL : mruby_unbox__GVariant(from_asv));

  /* Invocation */
  GVariantDict * native_return_value = g_variant_dict_new(native_from_asv);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantDict(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_dict_ref_FUNCTION
#define g_variant_dict_ref_REQUIRED_ARGC 1
#define g_variant_dict_ref_OPTIONAL_ARGC 0
/* g_variant_dict_ref
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * Return Type: GVariantDict *
 */
mrb_value
mrb_GLib_g_variant_dict_ref(mrb_state* mrb, mrb_value self) {
  mrb_value dict;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &dict);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  /* Invocation */
  GVariantDict * native_return_value = g_variant_dict_ref(native_dict);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantDict(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_dict_remove_FUNCTION
#define g_variant_dict_remove_REQUIRED_ARGC 2
#define g_variant_dict_remove_OPTIONAL_ARGC 0
/* g_variant_dict_remove
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * - key: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_dict_remove(mrb_state* mrb, mrb_value self) {
  mrb_value dict;
  char * native_key = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &dict, &native_key);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  /* Invocation */
  gboolean native_return_value = g_variant_dict_remove(native_dict, native_key);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_dict_unref_FUNCTION
#define g_variant_dict_unref_REQUIRED_ARGC 1
#define g_variant_dict_unref_OPTIONAL_ARGC 0
/* g_variant_dict_unref
 *
 * Parameters:
 * - dict: struct _GVariantDict *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_dict_unref(mrb_state* mrb, mrb_value self) {
  mrb_value dict;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &dict);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dict, GVariantDict_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantDict expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantDict * native_dict = (mrb_nil_p(dict) ? NULL : mruby_unbox__GVariantDict(dict));

  /* Invocation */
  g_variant_dict_unref(native_dict);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_dup_bytestring_FUNCTION
#define g_variant_dup_bytestring_REQUIRED_ARGC 2
#define g_variant_dup_bytestring_OPTIONAL_ARGC 0
/* g_variant_dup_bytestring
 *
 * Parameters:
 * - value: struct _GVariant *
 * - length: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_variant_dup_bytestring(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar * native_return_value = g_variant_dup_bytestring(native_value, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_dup_bytestring_array_FUNCTION
#define g_variant_dup_bytestring_array_REQUIRED_ARGC 2
#define g_variant_dup_bytestring_array_OPTIONAL_ARGC 0
/* g_variant_dup_bytestring_array
 *
 * Parameters:
 * - value: struct _GVariant *
 * - length: unsigned long *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_variant_dup_bytestring_array(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar ** native_return_value = g_variant_dup_bytestring_array(native_value, native_length);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_dup_objv_FUNCTION
#define g_variant_dup_objv_REQUIRED_ARGC 2
#define g_variant_dup_objv_OPTIONAL_ARGC 0
/* g_variant_dup_objv
 *
 * Parameters:
 * - value: struct _GVariant *
 * - length: unsigned long *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_variant_dup_objv(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar ** native_return_value = g_variant_dup_objv(native_value, native_length);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_dup_string_FUNCTION
#define g_variant_dup_string_REQUIRED_ARGC 2
#define g_variant_dup_string_OPTIONAL_ARGC 0
/* g_variant_dup_string
 *
 * Parameters:
 * - value: struct _GVariant *
 * - length: unsigned long *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_variant_dup_string(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar * native_return_value = g_variant_dup_string(native_value, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_dup_strv_FUNCTION
#define g_variant_dup_strv_REQUIRED_ARGC 2
#define g_variant_dup_strv_OPTIONAL_ARGC 0
/* g_variant_dup_strv
 *
 * Parameters:
 * - value: struct _GVariant *
 * - length: unsigned long *
 * Return Type: gchar **
 */
mrb_value
mrb_GLib_g_variant_dup_strv(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  gchar ** native_return_value = g_variant_dup_strv(native_value, native_length);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_equal_FUNCTION
#define g_variant_equal_REQUIRED_ARGC 2
#define g_variant_equal_OPTIONAL_ARGC 0
/* g_variant_equal
 *
 * Parameters:
 * - one: const void *
 * - two: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_equal(mrb_state* mrb, mrb_value self) {
  mrb_value one;
  mrb_value two;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &one, &two);

  /* Type checking */
  TODO_type_check_void_PTR(one);
  TODO_type_check_void_PTR(two);

  /* Unbox parameters */
  const void * native_one = TODO_mruby_unbox_void_PTR(one);

  const void * native_two = TODO_mruby_unbox_void_PTR(two);

  /* Invocation */
  gboolean native_return_value = g_variant_equal(native_one, native_two);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_FUNCTION
#define g_variant_get_REQUIRED_ARGC 2
#define g_variant_get_OPTIONAL_ARGC 0
/* g_variant_get
 *
 * Parameters:
 * - value: struct _GVariant *
 * - format_string: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_get(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  char * native_format_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &value, &native_format_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  g_variant_get(native_value, native_format_string);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_get_boolean_FUNCTION
#define g_variant_get_boolean_REQUIRED_ARGC 1
#define g_variant_get_boolean_OPTIONAL_ARGC 0
/* g_variant_get_boolean
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_get_boolean(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gboolean native_return_value = g_variant_get_boolean(native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_byte_FUNCTION
#define g_variant_get_byte_REQUIRED_ARGC 1
#define g_variant_get_byte_OPTIONAL_ARGC 0
/* g_variant_get_byte
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: guchar
 */
mrb_value
mrb_GLib_g_variant_get_byte(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  guchar native_return_value = g_variant_get_byte(native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_bytestring_FUNCTION
#define g_variant_get_bytestring_REQUIRED_ARGC 1
#define g_variant_get_bytestring_OPTIONAL_ARGC 0
/* g_variant_get_bytestring
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_variant_get_bytestring(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  const gchar * native_return_value = g_variant_get_bytestring(native_value);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_bytestring_array_FUNCTION
#define g_variant_get_bytestring_array_REQUIRED_ARGC 2
#define g_variant_get_bytestring_array_OPTIONAL_ARGC 0
/* g_variant_get_bytestring_array
 *
 * Parameters:
 * - value: struct _GVariant *
 * - length: unsigned long *
 * Return Type: const gchar **
 */
mrb_value
mrb_GLib_g_variant_get_bytestring_array(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  const gchar ** native_return_value = g_variant_get_bytestring_array(native_value, native_length);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_child_FUNCTION
#define g_variant_get_child_REQUIRED_ARGC 3
#define g_variant_get_child_OPTIONAL_ARGC 0
/* g_variant_get_child
 *
 * Parameters:
 * - value: struct _GVariant *
 * - index_: unsigned long
 * - format_string: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_get_child(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_int native_index_;
  char * native_format_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oiz!", &value, &native_index_, &native_format_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  g_variant_get_child(native_value, native_index_, native_format_string);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_get_child_value_FUNCTION
#define g_variant_get_child_value_REQUIRED_ARGC 2
#define g_variant_get_child_value_OPTIONAL_ARGC 0
/* g_variant_get_child_value
 *
 * Parameters:
 * - value: struct _GVariant *
 * - index_: unsigned long
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_get_child_value(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_int native_index_;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &value, &native_index_);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariant * native_return_value = g_variant_get_child_value(native_value, native_index_);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_get_data_FUNCTION
#define g_variant_get_data_REQUIRED_ARGC 1
#define g_variant_get_data_OPTIONAL_ARGC 0
/* g_variant_get_data
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gconstpointer
 */
mrb_value
mrb_GLib_g_variant_get_data(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gconstpointer native_return_value = g_variant_get_data(native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_void_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_data_as_bytes_FUNCTION
#define g_variant_get_data_as_bytes_REQUIRED_ARGC 1
#define g_variant_get_data_as_bytes_OPTIONAL_ARGC 0
/* g_variant_get_data_as_bytes
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GBytes *
 */
mrb_value
mrb_GLib_g_variant_get_data_as_bytes(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GBytes * native_return_value = g_variant_get_data_as_bytes(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GBytes(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_get_double_FUNCTION
#define g_variant_get_double_REQUIRED_ARGC 1
#define g_variant_get_double_OPTIONAL_ARGC 0
/* g_variant_get_double
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gdouble
 */
mrb_value
mrb_GLib_g_variant_get_double(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gdouble native_return_value = g_variant_get_double(native_value);

  /* Box the return value */
  mrb_value return_value = mrb_float_value(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_fixed_array_FUNCTION
#define g_variant_get_fixed_array_REQUIRED_ARGC 3
#define g_variant_get_fixed_array_OPTIONAL_ARGC 0
/* g_variant_get_fixed_array
 *
 * Parameters:
 * - value: struct _GVariant *
 * - n_elements: unsigned long *
 * - element_size: unsigned long
 * Return Type: gconstpointer
 */
mrb_value
mrb_GLib_g_variant_get_fixed_array(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value n_elements;
  mrb_int native_element_size;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &value, &n_elements, &native_element_size);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(n_elements);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  unsigned long * native_n_elements = TODO_mruby_unbox_unsigned_long_PTR(n_elements);

  /* Invocation */
  gconstpointer native_return_value = g_variant_get_fixed_array(native_value, native_n_elements, native_element_size);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_void_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_handle_FUNCTION
#define g_variant_get_handle_REQUIRED_ARGC 1
#define g_variant_get_handle_OPTIONAL_ARGC 0
/* g_variant_get_handle
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gint32
 */
mrb_value
mrb_GLib_g_variant_get_handle(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gint32 native_return_value = g_variant_get_handle(native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_int16_FUNCTION
#define g_variant_get_int16_REQUIRED_ARGC 1
#define g_variant_get_int16_OPTIONAL_ARGC 0
/* g_variant_get_int16
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gint16
 */
mrb_value
mrb_GLib_g_variant_get_int16(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gint16 native_return_value = g_variant_get_int16(native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint16(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_int32_FUNCTION
#define g_variant_get_int32_REQUIRED_ARGC 1
#define g_variant_get_int32_OPTIONAL_ARGC 0
/* g_variant_get_int32
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gint32
 */
mrb_value
mrb_GLib_g_variant_get_int32(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gint32 native_return_value = g_variant_get_int32(native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_int64_FUNCTION
#define g_variant_get_int64_REQUIRED_ARGC 1
#define g_variant_get_int64_OPTIONAL_ARGC 0
/* g_variant_get_int64
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gint64
 */
mrb_value
mrb_GLib_g_variant_get_int64(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gint64 native_return_value = g_variant_get_int64(native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gint64(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_maybe_FUNCTION
#define g_variant_get_maybe_REQUIRED_ARGC 1
#define g_variant_get_maybe_OPTIONAL_ARGC 0
/* g_variant_get_maybe
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_get_maybe(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariant * native_return_value = g_variant_get_maybe(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_get_normal_form_FUNCTION
#define g_variant_get_normal_form_REQUIRED_ARGC 1
#define g_variant_get_normal_form_OPTIONAL_ARGC 0
/* g_variant_get_normal_form
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_get_normal_form(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariant * native_return_value = g_variant_get_normal_form(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_get_objv_FUNCTION
#define g_variant_get_objv_REQUIRED_ARGC 2
#define g_variant_get_objv_OPTIONAL_ARGC 0
/* g_variant_get_objv
 *
 * Parameters:
 * - value: struct _GVariant *
 * - length: unsigned long *
 * Return Type: const gchar **
 */
mrb_value
mrb_GLib_g_variant_get_objv(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  const gchar ** native_return_value = g_variant_get_objv(native_value, native_length);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_size_FUNCTION
#define g_variant_get_size_REQUIRED_ARGC 1
#define g_variant_get_size_OPTIONAL_ARGC 0
/* g_variant_get_size
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_variant_get_size(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gsize native_return_value = g_variant_get_size(native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_string_FUNCTION
#define g_variant_get_string_REQUIRED_ARGC 2
#define g_variant_get_string_OPTIONAL_ARGC 0
/* g_variant_get_string
 *
 * Parameters:
 * - value: struct _GVariant *
 * - length: unsigned long *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_variant_get_string(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  const gchar * native_return_value = g_variant_get_string(native_value, native_length);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_strv_FUNCTION
#define g_variant_get_strv_REQUIRED_ARGC 2
#define g_variant_get_strv_OPTIONAL_ARGC 0
/* g_variant_get_strv
 *
 * Parameters:
 * - value: struct _GVariant *
 * - length: unsigned long *
 * Return Type: const gchar **
 */
mrb_value
mrb_GLib_g_variant_get_strv(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value length;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &length);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_unsigned_long_PTR(length);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  unsigned long * native_length = TODO_mruby_unbox_unsigned_long_PTR(length);

  /* Invocation */
  const gchar ** native_return_value = g_variant_get_strv(native_value, native_length);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gchar_PTR_PTR(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_type_FUNCTION
#define g_variant_get_type_REQUIRED_ARGC 1
#define g_variant_get_type_OPTIONAL_ARGC 0
/* g_variant_get_type
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: const GVariantType *
 */
mrb_value
mrb_GLib_g_variant_get_type(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  const GVariantType * native_return_value = g_variant_get_type(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_get_type_string_FUNCTION
#define g_variant_get_type_string_REQUIRED_ARGC 1
#define g_variant_get_type_string_OPTIONAL_ARGC 0
/* g_variant_get_type_string
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_variant_get_type_string(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  const gchar * native_return_value = g_variant_get_type_string(native_value);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_uint16_FUNCTION
#define g_variant_get_uint16_REQUIRED_ARGC 1
#define g_variant_get_uint16_OPTIONAL_ARGC 0
/* g_variant_get_uint16
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: guint16
 */
mrb_value
mrb_GLib_g_variant_get_uint16(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  guint16 native_return_value = g_variant_get_uint16(native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint16(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_uint32_FUNCTION
#define g_variant_get_uint32_REQUIRED_ARGC 1
#define g_variant_get_uint32_OPTIONAL_ARGC 0
/* g_variant_get_uint32
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: guint32
 */
mrb_value
mrb_GLib_g_variant_get_uint32(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  guint32 native_return_value = g_variant_get_uint32(native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint32(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_uint64_FUNCTION
#define g_variant_get_uint64_REQUIRED_ARGC 1
#define g_variant_get_uint64_OPTIONAL_ARGC 0
/* g_variant_get_uint64
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: guint64
 */
mrb_value
mrb_GLib_g_variant_get_uint64(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  guint64 native_return_value = g_variant_get_uint64(native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_guint64(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_get_va_FUNCTION
#define g_variant_get_va_REQUIRED_ARGC 4
#define g_variant_get_va_OPTIONAL_ARGC 0
/* g_variant_get_va
 *
 * Parameters:
 * - value: struct _GVariant *
 * - format_string: const char *
 * - endptr: const char **
 * - app: int *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_get_va(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  char * native_format_string = NULL;
  mrb_value endptr;
  mrb_value app;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!oo", &value, &native_format_string, &endptr, &app);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(endptr);
  TODO_type_check_int_PTR(app);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  const char ** native_endptr = TODO_mruby_unbox_char_PTR_PTR(endptr);

  int * native_app = TODO_mruby_unbox_int_PTR(app);

  /* Invocation */
  g_variant_get_va(native_value, native_format_string, native_endptr, native_app);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_get_variant_FUNCTION
#define g_variant_get_variant_REQUIRED_ARGC 1
#define g_variant_get_variant_OPTIONAL_ARGC 0
/* g_variant_get_variant
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_get_variant(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariant * native_return_value = g_variant_get_variant(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_hash_FUNCTION
#define g_variant_hash_REQUIRED_ARGC 1
#define g_variant_hash_OPTIONAL_ARGC 0
/* g_variant_hash
 *
 * Parameters:
 * - value: const void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_variant_hash(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  TODO_type_check_void_PTR(value);

  /* Unbox parameters */
  const void * native_value = TODO_mruby_unbox_void_PTR(value);

  /* Invocation */
  guint native_return_value = g_variant_hash(native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_is_container_FUNCTION
#define g_variant_is_container_REQUIRED_ARGC 1
#define g_variant_is_container_OPTIONAL_ARGC 0
/* g_variant_is_container
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_is_container(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gboolean native_return_value = g_variant_is_container(native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_is_floating_FUNCTION
#define g_variant_is_floating_REQUIRED_ARGC 1
#define g_variant_is_floating_OPTIONAL_ARGC 0
/* g_variant_is_floating
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_is_floating(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gboolean native_return_value = g_variant_is_floating(native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_is_normal_form_FUNCTION
#define g_variant_is_normal_form_REQUIRED_ARGC 1
#define g_variant_is_normal_form_OPTIONAL_ARGC 0
/* g_variant_is_normal_form
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_is_normal_form(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gboolean native_return_value = g_variant_is_normal_form(native_value);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_is_object_path_FUNCTION
#define g_variant_is_object_path_REQUIRED_ARGC 1
#define g_variant_is_object_path_OPTIONAL_ARGC 0
/* g_variant_is_object_path
 *
 * Parameters:
 * - string: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_is_object_path(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_string);

  /* Invocation */
  gboolean native_return_value = g_variant_is_object_path(native_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_is_of_type_FUNCTION
#define g_variant_is_of_type_REQUIRED_ARGC 2
#define g_variant_is_of_type_OPTIONAL_ARGC 0
/* g_variant_is_of_type
 *
 * Parameters:
 * - value: struct _GVariant *
 * - type: const struct _GVariantType *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_is_of_type(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gboolean native_return_value = g_variant_is_of_type(native_value, native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_is_signature_FUNCTION
#define g_variant_is_signature_REQUIRED_ARGC 1
#define g_variant_is_signature_OPTIONAL_ARGC 0
/* g_variant_is_signature
 *
 * Parameters:
 * - string: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_is_signature(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_string);

  /* Invocation */
  gboolean native_return_value = g_variant_is_signature(native_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_iter_copy_FUNCTION
#define g_variant_iter_copy_REQUIRED_ARGC 1
#define g_variant_iter_copy_OPTIONAL_ARGC 0
/* g_variant_iter_copy
 *
 * Parameters:
 * - iter: struct _GVariantIter *
 * Return Type: GVariantIter *
 */
mrb_value
mrb_GLib_g_variant_iter_copy(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GVariantIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantIter expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GVariantIter(iter));

  /* Invocation */
  GVariantIter * native_return_value = g_variant_iter_copy(native_iter);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantIter(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_iter_free_FUNCTION
#define g_variant_iter_free_REQUIRED_ARGC 1
#define g_variant_iter_free_OPTIONAL_ARGC 0
/* g_variant_iter_free
 *
 * Parameters:
 * - iter: struct _GVariantIter *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_iter_free(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GVariantIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantIter expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GVariantIter(iter));

  /* Invocation */
  g_variant_iter_free(native_iter);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_iter_init_FUNCTION
#define g_variant_iter_init_REQUIRED_ARGC 2
#define g_variant_iter_init_OPTIONAL_ARGC 0
/* g_variant_iter_init
 *
 * Parameters:
 * - iter: struct _GVariantIter *
 * - value: struct _GVariant *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_variant_iter_init(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &iter, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GVariantIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantIter expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GVariantIter(iter));

  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gsize native_return_value = g_variant_iter_init(native_iter, native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_iter_loop_FUNCTION
#define g_variant_iter_loop_REQUIRED_ARGC 2
#define g_variant_iter_loop_OPTIONAL_ARGC 0
/* g_variant_iter_loop
 *
 * Parameters:
 * - iter: struct _GVariantIter *
 * - format_string: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_iter_loop(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  char * native_format_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &iter, &native_format_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GVariantIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantIter expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GVariantIter(iter));

  /* Invocation */
  gboolean native_return_value = g_variant_iter_loop(native_iter, native_format_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_iter_n_children_FUNCTION
#define g_variant_iter_n_children_REQUIRED_ARGC 1
#define g_variant_iter_n_children_OPTIONAL_ARGC 0
/* g_variant_iter_n_children
 *
 * Parameters:
 * - iter: struct _GVariantIter *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_variant_iter_n_children(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GVariantIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantIter expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GVariantIter(iter));

  /* Invocation */
  gsize native_return_value = g_variant_iter_n_children(native_iter);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_iter_new_FUNCTION
#define g_variant_iter_new_REQUIRED_ARGC 1
#define g_variant_iter_new_OPTIONAL_ARGC 0
/* g_variant_iter_new
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GVariantIter *
 */
mrb_value
mrb_GLib_g_variant_iter_new(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariantIter * native_return_value = g_variant_iter_new(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantIter(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_iter_next_FUNCTION
#define g_variant_iter_next_REQUIRED_ARGC 2
#define g_variant_iter_next_OPTIONAL_ARGC 0
/* g_variant_iter_next
 *
 * Parameters:
 * - iter: struct _GVariantIter *
 * - format_string: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_iter_next(mrb_state* mrb, mrb_value self) {
  mrb_value iter;
  char * native_format_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &iter, &native_format_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GVariantIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantIter expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GVariantIter(iter));

  /* Invocation */
  gboolean native_return_value = g_variant_iter_next(native_iter, native_format_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_iter_next_value_FUNCTION
#define g_variant_iter_next_value_REQUIRED_ARGC 1
#define g_variant_iter_next_value_OPTIONAL_ARGC 0
/* g_variant_iter_next_value
 *
 * Parameters:
 * - iter: struct _GVariantIter *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_iter_next_value(mrb_state* mrb, mrb_value self) {
  mrb_value iter;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &iter);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, iter, GVariantIter_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantIter expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantIter * native_iter = (mrb_nil_p(iter) ? NULL : mruby_unbox__GVariantIter(iter));

  /* Invocation */
  GVariant * native_return_value = g_variant_iter_next_value(native_iter);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_lookup_FUNCTION
#define g_variant_lookup_REQUIRED_ARGC 3
#define g_variant_lookup_OPTIONAL_ARGC 0
/* g_variant_lookup
 *
 * Parameters:
 * - dictionary: struct _GVariant *
 * - key: const char *
 * - format_string: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_lookup(mrb_state* mrb, mrb_value self) {
  mrb_value dictionary;
  char * native_key = NULL;
  char * native_format_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!", &dictionary, &native_key, &native_format_string);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dictionary, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_dictionary = (mrb_nil_p(dictionary) ? NULL : mruby_unbox__GVariant(dictionary));

  /* Invocation */
  gboolean native_return_value = g_variant_lookup(native_dictionary, native_key, native_format_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_lookup_value_FUNCTION
#define g_variant_lookup_value_REQUIRED_ARGC 3
#define g_variant_lookup_value_OPTIONAL_ARGC 0
/* g_variant_lookup_value
 *
 * Parameters:
 * - dictionary: struct _GVariant *
 * - key: const char *
 * - expected_type: const struct _GVariantType *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_lookup_value(mrb_state* mrb, mrb_value self) {
  mrb_value dictionary;
  char * native_key = NULL;
  mrb_value expected_type;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!o", &dictionary, &native_key, &expected_type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, dictionary, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, expected_type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_dictionary = (mrb_nil_p(dictionary) ? NULL : mruby_unbox__GVariant(dictionary));

  const struct _GVariantType * native_expected_type = (mrb_nil_p(expected_type) ? NULL : mruby_unbox__GVariantType(expected_type));

  /* Invocation */
  GVariant * native_return_value = g_variant_lookup_value(native_dictionary, native_key, native_expected_type);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_n_children_FUNCTION
#define g_variant_n_children_REQUIRED_ARGC 1
#define g_variant_n_children_OPTIONAL_ARGC 0
/* g_variant_n_children
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_variant_n_children(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gsize native_return_value = g_variant_n_children(native_value);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_new_FUNCTION
#define g_variant_new_REQUIRED_ARGC 1
#define g_variant_new_OPTIONAL_ARGC 0
/* g_variant_new
 *
 * Parameters:
 * - format_string: const char *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new(mrb_state* mrb, mrb_value self) {
  char * native_format_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_format_string);

  /* Invocation */
  GVariant * native_return_value = g_variant_new(native_format_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_array_FUNCTION
#define g_variant_new_array_REQUIRED_ARGC 3
#define g_variant_new_array_OPTIONAL_ARGC 0
/* g_variant_new_array
 *
 * Parameters:
 * - child_type: const struct _GVariantType *
 * - children: struct _GVariant *const *
 * - n_children: unsigned long
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_array(mrb_state* mrb, mrb_value self) {
  mrb_value child_type;
  mrb_value children;
  mrb_int native_n_children;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &child_type, &children, &native_n_children);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, child_type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }
  TODO_type_check__GVariant_PTR_PTR(children);

  /* Unbox parameters */
  const struct _GVariantType * native_child_type = (mrb_nil_p(child_type) ? NULL : mruby_unbox__GVariantType(child_type));

  struct _GVariant *const * native_children = TODO_mruby_unbox__GVariant_PTR_PTR(children);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_array(native_child_type, native_children, native_n_children);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_boolean_FUNCTION
#define g_variant_new_boolean_REQUIRED_ARGC 1
#define g_variant_new_boolean_OPTIONAL_ARGC 0
/* g_variant_new_boolean
 *
 * Parameters:
 * - value: int
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_boolean(mrb_state* mrb, mrb_value self) {
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_value);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_boolean(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_byte_FUNCTION
#define g_variant_new_byte_REQUIRED_ARGC 1
#define g_variant_new_byte_OPTIONAL_ARGC 0
/* g_variant_new_byte
 *
 * Parameters:
 * - value: unsigned char
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_byte(mrb_state* mrb, mrb_value self) {
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_value);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_byte(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_bytestring_FUNCTION
#define g_variant_new_bytestring_REQUIRED_ARGC 1
#define g_variant_new_bytestring_OPTIONAL_ARGC 0
/* g_variant_new_bytestring
 *
 * Parameters:
 * - string: const char *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_bytestring(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_string);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_bytestring(native_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_bytestring_array_FUNCTION
#define g_variant_new_bytestring_array_REQUIRED_ARGC 2
#define g_variant_new_bytestring_array_OPTIONAL_ARGC 0
/* g_variant_new_bytestring_array
 *
 * Parameters:
 * - strv: const char *const *
 * - length: long
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_bytestring_array(mrb_state* mrb, mrb_value self) {
  mrb_value strv;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &strv, &native_length);

  /* Type checking */
  TODO_type_check_char_PTR_const_PTR(strv);

  /* Unbox parameters */
  const char *const * native_strv = TODO_mruby_unbox_char_PTR_const_PTR(strv);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_bytestring_array(native_strv, native_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_dict_entry_FUNCTION
#define g_variant_new_dict_entry_REQUIRED_ARGC 2
#define g_variant_new_dict_entry_OPTIONAL_ARGC 0
/* g_variant_new_dict_entry
 *
 * Parameters:
 * - key: struct _GVariant *
 * - value: struct _GVariant *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_dict_entry(mrb_state* mrb, mrb_value self) {
  mrb_value key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_key = (mrb_nil_p(key) ? NULL : mruby_unbox__GVariant(key));

  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariant * native_return_value = g_variant_new_dict_entry(native_key, native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_double_FUNCTION
#define g_variant_new_double_REQUIRED_ARGC 1
#define g_variant_new_double_OPTIONAL_ARGC 0
/* g_variant_new_double
 *
 * Parameters:
 * - value: double
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_double(mrb_state* mrb, mrb_value self) {
  double native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "f", &native_value);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_double(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_fixed_array_FUNCTION
#define g_variant_new_fixed_array_REQUIRED_ARGC 4
#define g_variant_new_fixed_array_OPTIONAL_ARGC 0
/* g_variant_new_fixed_array
 *
 * Parameters:
 * - element_type: const struct _GVariantType *
 * - elements: const void *
 * - n_elements: unsigned long
 * - element_size: unsigned long
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_fixed_array(mrb_state* mrb, mrb_value self) {
  mrb_value element_type;
  mrb_value elements;
  mrb_int native_n_elements;
  mrb_int native_element_size;

  /* Fetch the args */
  mrb_get_args(mrb, "ooii", &element_type, &elements, &native_n_elements, &native_element_size);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, element_type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(elements);

  /* Unbox parameters */
  const struct _GVariantType * native_element_type = (mrb_nil_p(element_type) ? NULL : mruby_unbox__GVariantType(element_type));

  const void * native_elements = TODO_mruby_unbox_void_PTR(elements);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_fixed_array(native_element_type, native_elements, native_n_elements, native_element_size);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_from_bytes_FUNCTION
#define g_variant_new_from_bytes_REQUIRED_ARGC 3
#define g_variant_new_from_bytes_OPTIONAL_ARGC 0
/* g_variant_new_from_bytes
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * - bytes: struct _GBytes *
 * - trusted: int
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_from_bytes(mrb_state* mrb, mrb_value self) {
  mrb_value type;
  mrb_value bytes;
  mrb_int native_trusted;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &type, &bytes, &native_trusted);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, bytes, GBytes_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GBytes expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  struct _GBytes * native_bytes = (mrb_nil_p(bytes) ? NULL : mruby_unbox__GBytes(bytes));

  /* Invocation */
  GVariant * native_return_value = g_variant_new_from_bytes(native_type, native_bytes, native_trusted);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_from_data_FUNCTION
#define g_variant_new_from_data_REQUIRED_ARGC 6
#define g_variant_new_from_data_OPTIONAL_ARGC 0
/* g_variant_new_from_data
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * - data: const void *
 * - size: unsigned long
 * - trusted: int
 * - notify: void (*)(void *)
 * - user_data: void *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_from_data(mrb_state* mrb, mrb_value self) {
  mrb_value type;
  mrb_value data;
  mrb_int native_size;
  mrb_int native_trusted;
  mrb_value notify;
  mrb_value user_data;

  /* Fetch the args */
  mrb_get_args(mrb, "ooiioo", &type, &data, &native_size, &native_trusted, &notify, &user_data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);
  TODO_type_check_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);
  TODO_type_check_void_PTR(user_data);

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  const void * native_data = TODO_mruby_unbox_void_PTR(data);

  void (*native_notify)(void *) = TODO_mruby_unbox_void_LPAREN_PTR_RPAREN_LPAREN_void_PTR_RPAREN(notify);

  void * native_user_data = TODO_mruby_unbox_void_PTR(user_data);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_from_data(native_type, native_data, native_size, native_trusted, native_notify, native_user_data);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_handle_FUNCTION
#define g_variant_new_handle_REQUIRED_ARGC 1
#define g_variant_new_handle_OPTIONAL_ARGC 0
/* g_variant_new_handle
 *
 * Parameters:
 * - value: int
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_handle(mrb_state* mrb, mrb_value self) {
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_value);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_handle(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_int16_FUNCTION
#define g_variant_new_int16_REQUIRED_ARGC 1
#define g_variant_new_int16_OPTIONAL_ARGC 0
/* g_variant_new_int16
 *
 * Parameters:
 * - value: short
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_int16(mrb_state* mrb, mrb_value self) {
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_value);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_int16(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_int32_FUNCTION
#define g_variant_new_int32_REQUIRED_ARGC 1
#define g_variant_new_int32_OPTIONAL_ARGC 0
/* g_variant_new_int32
 *
 * Parameters:
 * - value: int
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_int32(mrb_state* mrb, mrb_value self) {
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_value);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_int32(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_int64_FUNCTION
#define g_variant_new_int64_REQUIRED_ARGC 1
#define g_variant_new_int64_OPTIONAL_ARGC 0
/* g_variant_new_int64
 *
 * Parameters:
 * - value: long
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_int64(mrb_state* mrb, mrb_value self) {
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_value);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_int64(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_maybe_FUNCTION
#define g_variant_new_maybe_REQUIRED_ARGC 2
#define g_variant_new_maybe_OPTIONAL_ARGC 0
/* g_variant_new_maybe
 *
 * Parameters:
 * - child_type: const struct _GVariantType *
 * - child: struct _GVariant *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_maybe(mrb_state* mrb, mrb_value self) {
  mrb_value child_type;
  mrb_value child;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &child_type, &child);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, child_type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, child, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_child_type = (mrb_nil_p(child_type) ? NULL : mruby_unbox__GVariantType(child_type));

  struct _GVariant * native_child = (mrb_nil_p(child) ? NULL : mruby_unbox__GVariant(child));

  /* Invocation */
  GVariant * native_return_value = g_variant_new_maybe(native_child_type, native_child);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_object_path_FUNCTION
#define g_variant_new_object_path_REQUIRED_ARGC 1
#define g_variant_new_object_path_OPTIONAL_ARGC 0
/* g_variant_new_object_path
 *
 * Parameters:
 * - object_path: const char *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_object_path(mrb_state* mrb, mrb_value self) {
  char * native_object_path = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_object_path);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_object_path(native_object_path);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_objv_FUNCTION
#define g_variant_new_objv_REQUIRED_ARGC 2
#define g_variant_new_objv_OPTIONAL_ARGC 0
/* g_variant_new_objv
 *
 * Parameters:
 * - strv: const char *const *
 * - length: long
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_objv(mrb_state* mrb, mrb_value self) {
  mrb_value strv;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &strv, &native_length);

  /* Type checking */
  TODO_type_check_char_PTR_const_PTR(strv);

  /* Unbox parameters */
  const char *const * native_strv = TODO_mruby_unbox_char_PTR_const_PTR(strv);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_objv(native_strv, native_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_parsed_FUNCTION
#define g_variant_new_parsed_REQUIRED_ARGC 1
#define g_variant_new_parsed_OPTIONAL_ARGC 0
/* g_variant_new_parsed
 *
 * Parameters:
 * - format: const char *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_parsed(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_format);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_parsed(native_format);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_parsed_va_FUNCTION
#define g_variant_new_parsed_va_REQUIRED_ARGC 2
#define g_variant_new_parsed_va_OPTIONAL_ARGC 0
/* g_variant_new_parsed_va
 *
 * Parameters:
 * - format: const char *
 * - app: int *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_parsed_va(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;
  mrb_value app;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_format, &app);

  /* Type checking */
  TODO_type_check_int_PTR(app);

  /* Unbox parameters */
  int * native_app = TODO_mruby_unbox_int_PTR(app);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_parsed_va(native_format, native_app);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_printf_FUNCTION
#define g_variant_new_printf_REQUIRED_ARGC 1
#define g_variant_new_printf_OPTIONAL_ARGC 0
/* g_variant_new_printf
 *
 * Parameters:
 * - format_string: const char *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_printf(mrb_state* mrb, mrb_value self) {
  char * native_format_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_format_string);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_printf(native_format_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_signature_FUNCTION
#define g_variant_new_signature_REQUIRED_ARGC 1
#define g_variant_new_signature_OPTIONAL_ARGC 0
/* g_variant_new_signature
 *
 * Parameters:
 * - signature: const char *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_signature(mrb_state* mrb, mrb_value self) {
  char * native_signature = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_signature);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_signature(native_signature);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_string_FUNCTION
#define g_variant_new_string_REQUIRED_ARGC 1
#define g_variant_new_string_OPTIONAL_ARGC 0
/* g_variant_new_string
 *
 * Parameters:
 * - string: const char *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_string(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_string);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_string(native_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_strv_FUNCTION
#define g_variant_new_strv_REQUIRED_ARGC 2
#define g_variant_new_strv_OPTIONAL_ARGC 0
/* g_variant_new_strv
 *
 * Parameters:
 * - strv: const char *const *
 * - length: long
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_strv(mrb_state* mrb, mrb_value self) {
  mrb_value strv;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &strv, &native_length);

  /* Type checking */
  TODO_type_check_char_PTR_const_PTR(strv);

  /* Unbox parameters */
  const char *const * native_strv = TODO_mruby_unbox_char_PTR_const_PTR(strv);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_strv(native_strv, native_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_take_string_FUNCTION
#define g_variant_new_take_string_REQUIRED_ARGC 1
#define g_variant_new_take_string_OPTIONAL_ARGC 0
/* g_variant_new_take_string
 *
 * Parameters:
 * - string: char *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_take_string(mrb_state* mrb, mrb_value self) {
  char * string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &string);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_take_string(native_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_variant_new_tuple_FUNCTION
#define g_variant_new_tuple_REQUIRED_ARGC 2
#define g_variant_new_tuple_OPTIONAL_ARGC 0
/* g_variant_new_tuple
 *
 * Parameters:
 * - children: struct _GVariant *const *
 * - n_children: unsigned long
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_tuple(mrb_state* mrb, mrb_value self) {
  mrb_value children;
  mrb_int native_n_children;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &children, &native_n_children);

  /* Type checking */
  TODO_type_check__GVariant_PTR_PTR(children);

  /* Unbox parameters */
  struct _GVariant *const * native_children = TODO_mruby_unbox__GVariant_PTR_PTR(children);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_tuple(native_children, native_n_children);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_uint16_FUNCTION
#define g_variant_new_uint16_REQUIRED_ARGC 1
#define g_variant_new_uint16_OPTIONAL_ARGC 0
/* g_variant_new_uint16
 *
 * Parameters:
 * - value: unsigned short
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_uint16(mrb_state* mrb, mrb_value self) {
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_value);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_uint16(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_uint32_FUNCTION
#define g_variant_new_uint32_REQUIRED_ARGC 1
#define g_variant_new_uint32_OPTIONAL_ARGC 0
/* g_variant_new_uint32
 *
 * Parameters:
 * - value: unsigned int
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_uint32(mrb_state* mrb, mrb_value self) {
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_value);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_uint32(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_uint64_FUNCTION
#define g_variant_new_uint64_REQUIRED_ARGC 1
#define g_variant_new_uint64_OPTIONAL_ARGC 0
/* g_variant_new_uint64
 *
 * Parameters:
 * - value: unsigned long
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_uint64(mrb_state* mrb, mrb_value self) {
  mrb_int native_value;

  /* Fetch the args */
  mrb_get_args(mrb, "i", &native_value);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_uint64(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_va_FUNCTION
#define g_variant_new_va_REQUIRED_ARGC 3
#define g_variant_new_va_OPTIONAL_ARGC 0
/* g_variant_new_va
 *
 * Parameters:
 * - format_string: const char *
 * - endptr: const char **
 * - app: int *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_va(mrb_state* mrb, mrb_value self) {
  char * native_format_string = NULL;
  mrb_value endptr;
  mrb_value app;

  /* Fetch the args */
  mrb_get_args(mrb, "z!oo", &native_format_string, &endptr, &app);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(endptr);
  TODO_type_check_int_PTR(app);

  /* Unbox parameters */
  const char ** native_endptr = TODO_mruby_unbox_char_PTR_PTR(endptr);

  int * native_app = TODO_mruby_unbox_int_PTR(app);

  /* Invocation */
  GVariant * native_return_value = g_variant_new_va(native_format_string, native_endptr, native_app);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_new_variant_FUNCTION
#define g_variant_new_variant_REQUIRED_ARGC 1
#define g_variant_new_variant_OPTIONAL_ARGC 0
/* g_variant_new_variant
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_new_variant(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariant * native_return_value = g_variant_new_variant(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_parse_FUNCTION
#define g_variant_parse_REQUIRED_ARGC 4
#define g_variant_parse_OPTIONAL_ARGC 0
/* g_variant_parse
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * - text: const char *
 * - limit: const char *
 * - endptr: const char **
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_parse(mrb_state* mrb, mrb_value self) {
  mrb_value results = mrb_ary_new(mrb);
  mrb_value type;
  char * native_text = NULL;
  char * native_limit = NULL;
  mrb_value endptr;
  struct GError * native_error = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!z!o", &type, &native_text, &native_limit, &endptr);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }
  TODO_type_check_char_PTR_PTR(endptr);

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  const char ** native_endptr = TODO_mruby_unbox_char_PTR_PTR(endptr);

  /* Invocation */
  GVariant * native_return_value = g_variant_parse(native_type, native_text, native_limit, native_endptr, &native_error);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  mrb_ary_push(mrb, results, return_value);
  
  /* Box the out parameters */
  mrb_value error = (native_error == NULL ? mrb_nil_value() : mruby_box__GError(mrb, native_error));
  mrb_ary_push(mrb, results, error);

  return results;
}
#endif

#if BIND_g_variant_parse_error_print_context_FUNCTION
#define g_variant_parse_error_print_context_REQUIRED_ARGC 2
#define g_variant_parse_error_print_context_OPTIONAL_ARGC 0
/* g_variant_parse_error_print_context
 *
 * Parameters:
 * - error: struct _GError *
 * - source_str: const char *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_variant_parse_error_print_context(mrb_state* mrb, mrb_value self) {
  mrb_value error;
  char * native_source_str = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!", &error, &native_source_str);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, error, GError_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GError expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GError * native_error = (mrb_nil_p(error) ? NULL : mruby_unbox__GError(error));

  /* Invocation */
  gchar * native_return_value = g_variant_parse_error_print_context(native_error, native_source_str);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_parse_error_quark_FUNCTION
#define g_variant_parse_error_quark_REQUIRED_ARGC 0
#define g_variant_parse_error_quark_OPTIONAL_ARGC 0
/* g_variant_parse_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_variant_parse_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_variant_parse_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_parser_get_error_quark_FUNCTION
#define g_variant_parser_get_error_quark_REQUIRED_ARGC 0
#define g_variant_parser_get_error_quark_OPTIONAL_ARGC 0
/* g_variant_parser_get_error_quark
 *
 * Parameters: None
 * Return Type: GQuark
 */
mrb_value
mrb_GLib_g_variant_parser_get_error_quark(mrb_state* mrb, mrb_value self) {
  /* Invocation */
  GQuark native_return_value = g_variant_parser_get_error_quark();

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_print_FUNCTION
#define g_variant_print_REQUIRED_ARGC 2
#define g_variant_print_OPTIONAL_ARGC 0
/* g_variant_print
 *
 * Parameters:
 * - value: struct _GVariant *
 * - type_annotate: int
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_variant_print(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_int native_type_annotate;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &value, &native_type_annotate);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  gchar * native_return_value = g_variant_print(native_value, native_type_annotate);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_print_string_FUNCTION
#define g_variant_print_string_REQUIRED_ARGC 3
#define g_variant_print_string_OPTIONAL_ARGC 0
/* g_variant_print_string
 *
 * Parameters:
 * - value: struct _GVariant *
 * - string: struct _GString *
 * - type_annotate: int
 * Return Type: GString *
 */
mrb_value
mrb_GLib_g_variant_print_string(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value string;
  mrb_int native_type_annotate;

  /* Fetch the args */
  mrb_get_args(mrb, "ooi", &value, &string, &native_type_annotate);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, string, GString_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GString expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  struct _GString * native_string = (mrb_nil_p(string) ? NULL : mruby_unbox__GString(string));

  /* Invocation */
  GString * native_return_value = g_variant_print_string(native_value, native_string, native_type_annotate);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GString(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_ref_FUNCTION
#define g_variant_ref_REQUIRED_ARGC 1
#define g_variant_ref_OPTIONAL_ARGC 0
/* g_variant_ref
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_ref(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariant * native_return_value = g_variant_ref(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_ref_sink_FUNCTION
#define g_variant_ref_sink_REQUIRED_ARGC 1
#define g_variant_ref_sink_OPTIONAL_ARGC 0
/* g_variant_ref_sink
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_ref_sink(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariant * native_return_value = g_variant_ref_sink(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_store_FUNCTION
#define g_variant_store_REQUIRED_ARGC 2
#define g_variant_store_OPTIONAL_ARGC 0
/* g_variant_store
 *
 * Parameters:
 * - value: struct _GVariant *
 * - data: void *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_store(mrb_state* mrb, mrb_value self) {
  mrb_value value;
  mrb_value data;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &value, &data);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }
  TODO_type_check_void_PTR(data);

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  void * native_data = TODO_mruby_unbox_void_PTR(data);

  /* Invocation */
  g_variant_store(native_value, native_data);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_take_ref_FUNCTION
#define g_variant_take_ref_REQUIRED_ARGC 1
#define g_variant_take_ref_OPTIONAL_ARGC 0
/* g_variant_take_ref
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: GVariant *
 */
mrb_value
mrb_GLib_g_variant_take_ref(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  GVariant * native_return_value = g_variant_take_ref(native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariant(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_checked__FUNCTION
#define g_variant_type_checked__REQUIRED_ARGC 1
#define g_variant_type_checked__OPTIONAL_ARGC 0
/* g_variant_type_checked_
 *
 * Parameters:
 * - arg1: const char *
 * Return Type: const GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_checked_(mrb_state* mrb, mrb_value self) {
  char * native_arg1 = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_arg1);

  /* Invocation */
  const GVariantType * native_return_value = g_variant_type_checked_(native_arg1);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_copy_FUNCTION
#define g_variant_type_copy_REQUIRED_ARGC 1
#define g_variant_type_copy_OPTIONAL_ARGC 0
/* g_variant_type_copy
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_copy(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  GVariantType * native_return_value = g_variant_type_copy(native_type);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_dup_string_FUNCTION
#define g_variant_type_dup_string_REQUIRED_ARGC 1
#define g_variant_type_dup_string_OPTIONAL_ARGC 0
/* g_variant_type_dup_string
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gchar *
 */
mrb_value
mrb_GLib_g_variant_type_dup_string(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gchar * native_return_value = g_variant_type_dup_string(native_type);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  g_free(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_element_FUNCTION
#define g_variant_type_element_REQUIRED_ARGC 1
#define g_variant_type_element_OPTIONAL_ARGC 0
/* g_variant_type_element
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: const GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_element(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  const GVariantType * native_return_value = g_variant_type_element(native_type);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_equal_FUNCTION
#define g_variant_type_equal_REQUIRED_ARGC 2
#define g_variant_type_equal_OPTIONAL_ARGC 0
/* g_variant_type_equal
 *
 * Parameters:
 * - type1: const void *
 * - type2: const void *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_equal(mrb_state* mrb, mrb_value self) {
  mrb_value type1;
  mrb_value type2;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &type1, &type2);

  /* Type checking */
  TODO_type_check_void_PTR(type1);
  TODO_type_check_void_PTR(type2);

  /* Unbox parameters */
  const void * native_type1 = TODO_mruby_unbox_void_PTR(type1);

  const void * native_type2 = TODO_mruby_unbox_void_PTR(type2);

  /* Invocation */
  gboolean native_return_value = g_variant_type_equal(native_type1, native_type2);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_first_FUNCTION
#define g_variant_type_first_REQUIRED_ARGC 1
#define g_variant_type_first_OPTIONAL_ARGC 0
/* g_variant_type_first
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: const GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_first(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  const GVariantType * native_return_value = g_variant_type_first(native_type);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_free_FUNCTION
#define g_variant_type_free_REQUIRED_ARGC 1
#define g_variant_type_free_OPTIONAL_ARGC 0
/* g_variant_type_free
 *
 * Parameters:
 * - type: struct _GVariantType *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_type_free(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  g_variant_type_free(native_type);

  return mrb_nil_value();
}
#endif

#if BIND_g_variant_type_get_string_length_FUNCTION
#define g_variant_type_get_string_length_REQUIRED_ARGC 1
#define g_variant_type_get_string_length_OPTIONAL_ARGC 0
/* g_variant_type_get_string_length
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_variant_type_get_string_length(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gsize native_return_value = g_variant_type_get_string_length(native_type);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_hash_FUNCTION
#define g_variant_type_hash_REQUIRED_ARGC 1
#define g_variant_type_hash_OPTIONAL_ARGC 0
/* g_variant_type_hash
 *
 * Parameters:
 * - type: const void *
 * Return Type: guint
 */
mrb_value
mrb_GLib_g_variant_type_hash(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  TODO_type_check_void_PTR(type);

  /* Unbox parameters */
  const void * native_type = TODO_mruby_unbox_void_PTR(type);

  /* Invocation */
  guint native_return_value = g_variant_type_hash(native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_is_array_FUNCTION
#define g_variant_type_is_array_REQUIRED_ARGC 1
#define g_variant_type_is_array_OPTIONAL_ARGC 0
/* g_variant_type_is_array
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_is_array(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gboolean native_return_value = g_variant_type_is_array(native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_is_basic_FUNCTION
#define g_variant_type_is_basic_REQUIRED_ARGC 1
#define g_variant_type_is_basic_OPTIONAL_ARGC 0
/* g_variant_type_is_basic
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_is_basic(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gboolean native_return_value = g_variant_type_is_basic(native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_is_container_FUNCTION
#define g_variant_type_is_container_REQUIRED_ARGC 1
#define g_variant_type_is_container_OPTIONAL_ARGC 0
/* g_variant_type_is_container
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_is_container(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gboolean native_return_value = g_variant_type_is_container(native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_is_definite_FUNCTION
#define g_variant_type_is_definite_REQUIRED_ARGC 1
#define g_variant_type_is_definite_OPTIONAL_ARGC 0
/* g_variant_type_is_definite
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_is_definite(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gboolean native_return_value = g_variant_type_is_definite(native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_is_dict_entry_FUNCTION
#define g_variant_type_is_dict_entry_REQUIRED_ARGC 1
#define g_variant_type_is_dict_entry_OPTIONAL_ARGC 0
/* g_variant_type_is_dict_entry
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_is_dict_entry(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gboolean native_return_value = g_variant_type_is_dict_entry(native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_is_maybe_FUNCTION
#define g_variant_type_is_maybe_REQUIRED_ARGC 1
#define g_variant_type_is_maybe_OPTIONAL_ARGC 0
/* g_variant_type_is_maybe
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_is_maybe(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gboolean native_return_value = g_variant_type_is_maybe(native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_is_subtype_of_FUNCTION
#define g_variant_type_is_subtype_of_REQUIRED_ARGC 2
#define g_variant_type_is_subtype_of_OPTIONAL_ARGC 0
/* g_variant_type_is_subtype_of
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * - supertype: const struct _GVariantType *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_is_subtype_of(mrb_state* mrb, mrb_value self) {
  mrb_value type;
  mrb_value supertype;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &type, &supertype);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, supertype, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  const struct _GVariantType * native_supertype = (mrb_nil_p(supertype) ? NULL : mruby_unbox__GVariantType(supertype));

  /* Invocation */
  gboolean native_return_value = g_variant_type_is_subtype_of(native_type, native_supertype);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_is_tuple_FUNCTION
#define g_variant_type_is_tuple_REQUIRED_ARGC 1
#define g_variant_type_is_tuple_OPTIONAL_ARGC 0
/* g_variant_type_is_tuple
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_is_tuple(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gboolean native_return_value = g_variant_type_is_tuple(native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_is_variant_FUNCTION
#define g_variant_type_is_variant_REQUIRED_ARGC 1
#define g_variant_type_is_variant_OPTIONAL_ARGC 0
/* g_variant_type_is_variant
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_is_variant(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gboolean native_return_value = g_variant_type_is_variant(native_type);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_key_FUNCTION
#define g_variant_type_key_REQUIRED_ARGC 1
#define g_variant_type_key_OPTIONAL_ARGC 0
/* g_variant_type_key
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: const GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_key(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  const GVariantType * native_return_value = g_variant_type_key(native_type);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_n_items_FUNCTION
#define g_variant_type_n_items_REQUIRED_ARGC 1
#define g_variant_type_n_items_OPTIONAL_ARGC 0
/* g_variant_type_n_items
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: gsize
 */
mrb_value
mrb_GLib_g_variant_type_n_items(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  gsize native_return_value = g_variant_type_n_items(native_type);

  /* Box the return value */
  mrb_value return_value = TODO_mruby_box_gsize(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_new_FUNCTION
#define g_variant_type_new_REQUIRED_ARGC 1
#define g_variant_type_new_OPTIONAL_ARGC 0
/* g_variant_type_new
 *
 * Parameters:
 * - type_string: const char *
 * Return Type: GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_new(mrb_state* mrb, mrb_value self) {
  char * native_type_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_type_string);

  /* Invocation */
  GVariantType * native_return_value = g_variant_type_new(native_type_string);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_new_array_FUNCTION
#define g_variant_type_new_array_REQUIRED_ARGC 1
#define g_variant_type_new_array_OPTIONAL_ARGC 0
/* g_variant_type_new_array
 *
 * Parameters:
 * - element: const struct _GVariantType *
 * Return Type: GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_new_array(mrb_state* mrb, mrb_value self) {
  mrb_value element;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &element);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, element, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_element = (mrb_nil_p(element) ? NULL : mruby_unbox__GVariantType(element));

  /* Invocation */
  GVariantType * native_return_value = g_variant_type_new_array(native_element);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_new_dict_entry_FUNCTION
#define g_variant_type_new_dict_entry_REQUIRED_ARGC 2
#define g_variant_type_new_dict_entry_OPTIONAL_ARGC 0
/* g_variant_type_new_dict_entry
 *
 * Parameters:
 * - key: const struct _GVariantType *
 * - value: const struct _GVariantType *
 * Return Type: GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_new_dict_entry(mrb_state* mrb, mrb_value self) {
  mrb_value key;
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "oo", &key, &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, key, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }
  if (!mrb_obj_is_kind_of(mrb, value, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_key = (mrb_nil_p(key) ? NULL : mruby_unbox__GVariantType(key));

  const struct _GVariantType * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariantType(value));

  /* Invocation */
  GVariantType * native_return_value = g_variant_type_new_dict_entry(native_key, native_value);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_new_maybe_FUNCTION
#define g_variant_type_new_maybe_REQUIRED_ARGC 1
#define g_variant_type_new_maybe_OPTIONAL_ARGC 0
/* g_variant_type_new_maybe
 *
 * Parameters:
 * - element: const struct _GVariantType *
 * Return Type: GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_new_maybe(mrb_state* mrb, mrb_value self) {
  mrb_value element;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &element);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, element, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_element = (mrb_nil_p(element) ? NULL : mruby_unbox__GVariantType(element));

  /* Invocation */
  GVariantType * native_return_value = g_variant_type_new_maybe(native_element);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_new_tuple_FUNCTION
#define g_variant_type_new_tuple_REQUIRED_ARGC 2
#define g_variant_type_new_tuple_OPTIONAL_ARGC 0
/* g_variant_type_new_tuple
 *
 * Parameters:
 * - items: const struct _GVariantType *const *
 * - length: int
 * Return Type: GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_new_tuple(mrb_state* mrb, mrb_value self) {
  mrb_value items;
  mrb_int native_length;

  /* Fetch the args */
  mrb_get_args(mrb, "oi", &items, &native_length);

  /* Type checking */
  TODO_type_check__GVariantType_PTR_const_PTR(items);

  /* Unbox parameters */
  const struct _GVariantType *const * native_items = TODO_mruby_unbox__GVariantType_PTR_const_PTR(items);

  /* Invocation */
  GVariantType * native_return_value = g_variant_type_new_tuple(native_items, native_length);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_next_FUNCTION
#define g_variant_type_next_REQUIRED_ARGC 1
#define g_variant_type_next_OPTIONAL_ARGC 0
/* g_variant_type_next
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: const GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_next(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  const GVariantType * native_return_value = g_variant_type_next(native_type);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_type_peek_string_FUNCTION
#define g_variant_type_peek_string_REQUIRED_ARGC 1
#define g_variant_type_peek_string_OPTIONAL_ARGC 0
/* g_variant_type_peek_string
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_g_variant_type_peek_string(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  const gchar * native_return_value = g_variant_type_peek_string(native_type);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_string_is_valid_FUNCTION
#define g_variant_type_string_is_valid_REQUIRED_ARGC 1
#define g_variant_type_string_is_valid_OPTIONAL_ARGC 0
/* g_variant_type_string_is_valid
 *
 * Parameters:
 * - type_string: const char *
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_string_is_valid(mrb_state* mrb, mrb_value self) {
  char * native_type_string = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!", &native_type_string);

  /* Invocation */
  gboolean native_return_value = g_variant_type_string_is_valid(native_type_string);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_string_scan_FUNCTION
#define g_variant_type_string_scan_REQUIRED_ARGC 3
#define g_variant_type_string_scan_OPTIONAL_ARGC 0
/* g_variant_type_string_scan
 *
 * Parameters:
 * - string: const char *
 * - limit: const char *
 * - endptr: const char **
 * Return Type: gboolean
 */
mrb_value
mrb_GLib_g_variant_type_string_scan(mrb_state* mrb, mrb_value self) {
  char * native_string = NULL;
  char * native_limit = NULL;
  mrb_value endptr;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!o", &native_string, &native_limit, &endptr);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(endptr);

  /* Unbox parameters */
  const char ** native_endptr = TODO_mruby_unbox_char_PTR_PTR(endptr);

  /* Invocation */
  gboolean native_return_value = g_variant_type_string_scan(native_string, native_limit, native_endptr);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_variant_type_value_FUNCTION
#define g_variant_type_value_REQUIRED_ARGC 1
#define g_variant_type_value_OPTIONAL_ARGC 0
/* g_variant_type_value
 *
 * Parameters:
 * - type: const struct _GVariantType *
 * Return Type: const GVariantType *
 */
mrb_value
mrb_GLib_g_variant_type_value(mrb_state* mrb, mrb_value self) {
  mrb_value type;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &type);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, type, GVariantType_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariantType expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  const struct _GVariantType * native_type = (mrb_nil_p(type) ? NULL : mruby_unbox__GVariantType(type));

  /* Invocation */
  const GVariantType * native_return_value = g_variant_type_value(native_type);

  /* Box the return value */
  mrb_value return_value = (native_return_value == NULL ? mrb_nil_value() : mruby_box__GVariantType(mrb, native_return_value));
  
  return return_value;
}
#endif

#if BIND_g_variant_unref_FUNCTION
#define g_variant_unref_REQUIRED_ARGC 1
#define g_variant_unref_OPTIONAL_ARGC 0
/* g_variant_unref
 *
 * Parameters:
 * - value: struct _GVariant *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_variant_unref(mrb_state* mrb, mrb_value self) {
  mrb_value value;

  /* Fetch the args */
  mrb_get_args(mrb, "o", &value);

  /* Type checking */
  if (!mrb_obj_is_kind_of(mrb, value, GVariant_class(mrb))) {
    mrb_raise(mrb, E_TYPE_ERROR, "GVariant expected");
    return mrb_nil_value();
  }

  /* Unbox parameters */
  struct _GVariant * native_value = (mrb_nil_p(value) ? NULL : mruby_unbox__GVariant(value));

  /* Invocation */
  g_variant_unref(native_value);

  return mrb_nil_value();
}
#endif

#if BIND_g_vasprintf_FUNCTION
#define g_vasprintf_REQUIRED_ARGC 3
#define g_vasprintf_OPTIONAL_ARGC 0
/* g_vasprintf
 *
 * Parameters:
 * - string: char **
 * - format: const char *
 * - args: struct __va_list_tag [1]
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_vasprintf(mrb_state* mrb, mrb_value self) {
  mrb_value string;
  char * native_format = NULL;
  mrb_value args;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!o", &string, &native_format, &args);

  /* Type checking */
  TODO_type_check_char_PTR_PTR(string);
  TODO_type_check___va_list_tag_[1](args);

  /* Unbox parameters */
  char ** native_string = TODO_mruby_unbox_char_PTR_PTR(string);

  struct __va_list_tag [1] native_args = TODO_mruby_unbox___va_list_tag_[1](args);

  /* Invocation */
  gint native_return_value = g_vasprintf(native_string, native_format, native_args);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_vfprintf_FUNCTION
#define g_vfprintf_REQUIRED_ARGC 3
#define g_vfprintf_OPTIONAL_ARGC 0
/* g_vfprintf
 *
 * Parameters:
 * - file: struct __sFILE *
 * - format: const char *
 * - args: struct __va_list_tag [1]
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_vfprintf(mrb_state* mrb, mrb_value self) {
  mrb_value file;
  char * native_format = NULL;
  mrb_value args;

  /* Fetch the args */
  mrb_get_args(mrb, "oz!o", &file, &native_format, &args);

  /* Type checking */
  TODO_type_check___sFILE_PTR(file);
  TODO_type_check___va_list_tag_[1](args);

  /* Unbox parameters */
  struct __sFILE * native_file = TODO_mruby_unbox___sFILE_PTR(file);

  struct __va_list_tag [1] native_args = TODO_mruby_unbox___va_list_tag_[1](args);

  /* Invocation */
  gint native_return_value = g_vfprintf(native_file, native_format, native_args);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_vprintf_FUNCTION
#define g_vprintf_REQUIRED_ARGC 2
#define g_vprintf_OPTIONAL_ARGC 0
/* g_vprintf
 *
 * Parameters:
 * - format: const char *
 * - args: struct __va_list_tag [1]
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_vprintf(mrb_state* mrb, mrb_value self) {
  char * native_format = NULL;
  mrb_value args;

  /* Fetch the args */
  mrb_get_args(mrb, "z!o", &native_format, &args);

  /* Type checking */
  TODO_type_check___va_list_tag_[1](args);

  /* Unbox parameters */
  struct __va_list_tag [1] native_args = TODO_mruby_unbox___va_list_tag_[1](args);

  /* Invocation */
  gint native_return_value = g_vprintf(native_format, native_args);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  return return_value;
}
#endif

#if BIND_g_vsnprintf_FUNCTION
#define g_vsnprintf_REQUIRED_ARGC 4
#define g_vsnprintf_OPTIONAL_ARGC 0
/* g_vsnprintf
 *
 * Parameters:
 * - string: char *
 * - n: unsigned long
 * - format: const char *
 * - args: int
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_vsnprintf(mrb_state* mrb, mrb_value self) {
  char * string = NULL;
  mrb_int native_n;
  char * native_format = NULL;
  mrb_int native_args;

  /* Fetch the args */
  mrb_get_args(mrb, "z!iz!i", &string, &native_n, &native_format, &native_args);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  /* Invocation */
  gint native_return_value = g_vsnprintf(native_string, native_n, native_format, native_args);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_vsprintf_FUNCTION
#define g_vsprintf_REQUIRED_ARGC 3
#define g_vsprintf_OPTIONAL_ARGC 0
/* g_vsprintf
 *
 * Parameters:
 * - string: char *
 * - format: const char *
 * - args: struct __va_list_tag [1]
 * Return Type: gint
 */
mrb_value
mrb_GLib_g_vsprintf(mrb_state* mrb, mrb_value self) {
  char * string = NULL;
  char * native_format = NULL;
  mrb_value args;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!o", &string, &native_format, &args);

  /* Type checking */
  TODO_type_check___va_list_tag_[1](args);

  /* Unbox parameters */
  /* WARNING: Allocating new memory to create 'char *' from 'const char *'.
   *          Please verify that this memory is cleaned up correctly.
   *
   *          Has this been verified? [No]
   */
  char * native_string = strdup(string);

  struct __va_list_tag [1] native_args = TODO_mruby_unbox___va_list_tag_[1](args);

  /* Invocation */
  gint native_return_value = g_vsprintf(native_string, native_format, native_args);

  /* Box the return value */
  if (native_return_value > MRB_INT_MAX) {
    mrb_raise(mrb, mrb->eStandardError_class, "MRuby cannot represent integers greater than MRB_INT_MAX");
    return mrb_nil_value();
  }
  mrb_value return_value = mrb_fixnum_value(native_return_value);
  
  /* Clean up temporary values from unboxing */
  /* WARNING: Assuming that the new string can be deallocated after the function call.
   *          Please verify that this is correct (the function does not save this parameter).
   *
   *          Has this been verified? [No]
   */
  free(native_string);
  native_string = NULL;

  return return_value;
}
#endif

#if BIND_g_warn_message_FUNCTION
#define g_warn_message_REQUIRED_ARGC 5
#define g_warn_message_OPTIONAL_ARGC 0
/* g_warn_message
 *
 * Parameters:
 * - domain: const char *
 * - file: const char *
 * - line: int
 * - func: const char *
 * - warnexpr: const char *
 * Return Type: void
 */
mrb_value
mrb_GLib_g_warn_message(mrb_state* mrb, mrb_value self) {
  char * native_domain = NULL;
  char * native_file = NULL;
  mrb_int native_line;
  char * native_func = NULL;
  char * native_warnexpr = NULL;

  /* Fetch the args */
  mrb_get_args(mrb, "z!z!iz!z!", &native_domain, &native_file, &native_line, &native_func, &native_warnexpr);

  /* Invocation */
  g_warn_message(native_domain, native_file, native_line, native_func, native_warnexpr);

  return mrb_nil_value();
}
#endif

#if BIND_glib_check_version_FUNCTION
#define glib_check_version_REQUIRED_ARGC 3
#define glib_check_version_OPTIONAL_ARGC 0
/* glib_check_version
 *
 * Parameters:
 * - required_major: unsigned int
 * - required_minor: unsigned int
 * - required_micro: unsigned int
 * Return Type: const gchar *
 */
mrb_value
mrb_GLib_glib_check_version(mrb_state* mrb, mrb_value self) {
  mrb_int native_required_major;
  mrb_int native_required_minor;
  mrb_int native_required_micro;

  /* Fetch the args */
  mrb_get_args(mrb, "iii", &native_required_major, &native_required_minor, &native_required_micro);

  /* Invocation */
  const gchar * native_return_value = glib_check_version(native_required_major, native_required_minor, native_required_micro);

  /* Box the return value */
  mrb_value return_value = mrb_str_new_cstr(mrb, native_return_value);
  
  return return_value;
}
#endif


void mrb_mruby_glib_gem_init(mrb_state* mrb) {
  struct RClass* GLib_module = mrb_define_module(mrb, "GLib");
  mruby_GLib_define_macro_constants(mrb);

  /*
   * Initialize class bindings
   */
#if BIND_GTestConfig_TYPE
  mrb_GLib_GTestConfig_init(mrb);
#endif
#if BIND_GTestLogBuffer_TYPE
  mrb_GLib_GTestLogBuffer_init(mrb);
#endif
#if BIND_GTestLogMsg_TYPE
  mrb_GLib_GTestLogMsg_init(mrb);
#endif
#if BIND_GArray_TYPE
  mrb_GLib_GArray_init(mrb);
#endif
#if BIND_GAsyncQueue_TYPE
  mrb_GLib_GAsyncQueue_init(mrb);
#endif
#if BIND_GBookmarkFile_TYPE
  mrb_GLib_GBookmarkFile_init(mrb);
#endif
#if BIND_GByteArray_TYPE
  mrb_GLib_GByteArray_init(mrb);
#endif
#if BIND_GBytes_TYPE
  mrb_GLib_GBytes_init(mrb);
#endif
#if BIND_GChecksum_TYPE
  mrb_GLib_GChecksum_init(mrb);
#endif
#if BIND_GCond_TYPE
  mrb_GLib_GCond_init(mrb);
#endif
#if BIND_GData_TYPE
  mrb_GLib_GData_init(mrb);
#endif
#if BIND_GDate_TYPE
  mrb_GLib_GDate_init(mrb);
#endif
#if BIND_GDateTime_TYPE
  mrb_GLib_GDateTime_init(mrb);
#endif
#if BIND_GDebugKey_TYPE
  mrb_GLib_GDebugKey_init(mrb);
#endif
#if BIND_GDir_TYPE
  mrb_GLib_GDir_init(mrb);
#endif
#if BIND_GError_TYPE
  mrb_GLib_GError_init(mrb);
#endif
#if BIND_GHashTable_TYPE
  mrb_GLib_GHashTable_init(mrb);
#endif
#if BIND_GHashTableIter_TYPE
  mrb_GLib_GHashTableIter_init(mrb);
#endif
#if BIND_GHmac_TYPE
  mrb_GLib_GHmac_init(mrb);
#endif
#if BIND_GHook_TYPE
  mrb_GLib_GHook_init(mrb);
#endif
#if BIND_GHookList_TYPE
  mrb_GLib_GHookList_init(mrb);
#endif
#if BIND_GIConv_TYPE
  mrb_GLib_GIConv_init(mrb);
#endif
#if BIND_GIOChannel_TYPE
  mrb_GLib_GIOChannel_init(mrb);
#endif
#if BIND_GIOFuncs_TYPE
  mrb_GLib_GIOFuncs_init(mrb);
#endif
#if BIND_GKeyFile_TYPE
  mrb_GLib_GKeyFile_init(mrb);
#endif
#if BIND_GList_TYPE
  mrb_GLib_GList_init(mrb);
#endif
#if BIND_GMainContext_TYPE
  mrb_GLib_GMainContext_init(mrb);
#endif
#if BIND_GMainLoop_TYPE
  mrb_GLib_GMainLoop_init(mrb);
#endif
#if BIND_GMappedFile_TYPE
  mrb_GLib_GMappedFile_init(mrb);
#endif
#if BIND_GMarkupParseContext_TYPE
  mrb_GLib_GMarkupParseContext_init(mrb);
#endif
#if BIND_GMarkupParser_TYPE
  mrb_GLib_GMarkupParser_init(mrb);
#endif
#if BIND_GMatchInfo_TYPE
  mrb_GLib_GMatchInfo_init(mrb);
#endif
#if BIND_GMemVTable_TYPE
  mrb_GLib_GMemVTable_init(mrb);
#endif
#if BIND_GNode_TYPE
  mrb_GLib_GNode_init(mrb);
#endif
#if BIND_GOnce_TYPE
  mrb_GLib_GOnce_init(mrb);
#endif
#if BIND_GOptionContext_TYPE
  mrb_GLib_GOptionContext_init(mrb);
#endif
#if BIND_GOptionEntry_TYPE
  mrb_GLib_GOptionEntry_init(mrb);
#endif
#if BIND_GOptionGroup_TYPE
  mrb_GLib_GOptionGroup_init(mrb);
#endif
#if BIND_GPatternSpec_TYPE
  mrb_GLib_GPatternSpec_init(mrb);
#endif
#if BIND_GPollFD_TYPE
  mrb_GLib_GPollFD_init(mrb);
#endif
#if BIND_GPrivate_TYPE
  mrb_GLib_GPrivate_init(mrb);
#endif
#if BIND_GPtrArray_TYPE
  mrb_GLib_GPtrArray_init(mrb);
#endif
#if BIND_GQueue_TYPE
  mrb_GLib_GQueue_init(mrb);
#endif
#if BIND_GRand_TYPE
  mrb_GLib_GRand_init(mrb);
#endif
#if BIND_GRecMutex_TYPE
  mrb_GLib_GRecMutex_init(mrb);
#endif
#if BIND_GRegex_TYPE
  mrb_GLib_GRegex_init(mrb);
#endif
#if BIND_GRWLock_TYPE
  mrb_GLib_GRWLock_init(mrb);
#endif
#if BIND_GScanner_TYPE
  mrb_GLib_GScanner_init(mrb);
#endif
#if BIND_GScannerConfig_TYPE
  mrb_GLib_GScannerConfig_init(mrb);
#endif
#if BIND_GSequence_TYPE
  mrb_GLib_GSequence_init(mrb);
#endif
#if BIND_GSequenceNode_TYPE
  mrb_GLib_GSequenceNode_init(mrb);
#endif
#if BIND_GSList_TYPE
  mrb_GLib_GSList_init(mrb);
#endif
#if BIND_GSource_TYPE
  mrb_GLib_GSource_init(mrb);
#endif
#if BIND_GSourceCallbackFuncs_TYPE
  mrb_GLib_GSourceCallbackFuncs_init(mrb);
#endif
#if BIND_GSourceFuncs_TYPE
  mrb_GLib_GSourceFuncs_init(mrb);
#endif
#if BIND_GSourcePrivate_TYPE
  mrb_GLib_GSourcePrivate_init(mrb);
#endif
#if BIND_GString_TYPE
  mrb_GLib_GString_init(mrb);
#endif
#if BIND_GStringChunk_TYPE
  mrb_GLib_GStringChunk_init(mrb);
#endif
#if BIND_GThread_TYPE
  mrb_GLib_GThread_init(mrb);
#endif
#if BIND_GThreadPool_TYPE
  mrb_GLib_GThreadPool_init(mrb);
#endif
#if BIND_GTimer_TYPE
  mrb_GLib_GTimer_init(mrb);
#endif
#if BIND_GTimeVal_TYPE
  mrb_GLib_GTimeVal_init(mrb);
#endif
#if BIND_GTimeZone_TYPE
  mrb_GLib_GTimeZone_init(mrb);
#endif
#if BIND_GTrashStack_TYPE
  mrb_GLib_GTrashStack_init(mrb);
#endif
#if BIND_GTree_TYPE
  mrb_GLib_GTree_init(mrb);
#endif
#if BIND_GVariant_TYPE
  mrb_GLib_GVariant_init(mrb);
#endif
#if BIND_GVariantBuilder_TYPE
  mrb_GLib_GVariantBuilder_init(mrb);
#endif
#if BIND_GVariantDict_TYPE
  mrb_GLib_GVariantDict_init(mrb);
#endif
#if BIND_GVariantIter_TYPE
  mrb_GLib_GVariantIter_init(mrb);
#endif
#if BIND_GVariantType_TYPE
  mrb_GLib_GVariantType_init(mrb);
#endif
#if BIND_GTestCase_TYPE
  mrb_GLib_GTestCase_init(mrb);
#endif
#if BIND_GTestSuite_TYPE
  mrb_GLib_GTestSuite_init(mrb);
#endif

  /*
   * Global Functions
   */
#if BIND__g_log_fallback_handler_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "_g_log_fallback_handler", mrb_GLib__g_log_fallback_handler, MRB_ARGS_ARG(_g_log_fallback_handler_REQUIRED_ARGC, _g_log_fallback_handler_OPTIONAL_ARGC));
#endif
#if BIND_g_access_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_access", mrb_GLib_g_access, MRB_ARGS_ARG(g_access_REQUIRED_ARGC, g_access_OPTIONAL_ARGC));
#endif
#if BIND_g_array_append_vals_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_append_vals", mrb_GLib_g_array_append_vals, MRB_ARGS_ARG(g_array_append_vals_REQUIRED_ARGC, g_array_append_vals_OPTIONAL_ARGC));
#endif
#if BIND_g_array_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_free", mrb_GLib_g_array_free, MRB_ARGS_ARG(g_array_free_REQUIRED_ARGC, g_array_free_OPTIONAL_ARGC));
#endif
#if BIND_g_array_get_element_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_get_element_size", mrb_GLib_g_array_get_element_size, MRB_ARGS_ARG(g_array_get_element_size_REQUIRED_ARGC, g_array_get_element_size_OPTIONAL_ARGC));
#endif
#if BIND_g_array_insert_vals_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_insert_vals", mrb_GLib_g_array_insert_vals, MRB_ARGS_ARG(g_array_insert_vals_REQUIRED_ARGC, g_array_insert_vals_OPTIONAL_ARGC));
#endif
#if BIND_g_array_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_new", mrb_GLib_g_array_new, MRB_ARGS_ARG(g_array_new_REQUIRED_ARGC, g_array_new_OPTIONAL_ARGC));
#endif
#if BIND_g_array_prepend_vals_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_prepend_vals", mrb_GLib_g_array_prepend_vals, MRB_ARGS_ARG(g_array_prepend_vals_REQUIRED_ARGC, g_array_prepend_vals_OPTIONAL_ARGC));
#endif
#if BIND_g_array_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_ref", mrb_GLib_g_array_ref, MRB_ARGS_ARG(g_array_ref_REQUIRED_ARGC, g_array_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_array_remove_index_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_remove_index", mrb_GLib_g_array_remove_index, MRB_ARGS_ARG(g_array_remove_index_REQUIRED_ARGC, g_array_remove_index_OPTIONAL_ARGC));
#endif
#if BIND_g_array_remove_index_fast_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_remove_index_fast", mrb_GLib_g_array_remove_index_fast, MRB_ARGS_ARG(g_array_remove_index_fast_REQUIRED_ARGC, g_array_remove_index_fast_OPTIONAL_ARGC));
#endif
#if BIND_g_array_remove_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_remove_range", mrb_GLib_g_array_remove_range, MRB_ARGS_ARG(g_array_remove_range_REQUIRED_ARGC, g_array_remove_range_OPTIONAL_ARGC));
#endif
#if BIND_g_array_set_clear_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_set_clear_func", mrb_GLib_g_array_set_clear_func, MRB_ARGS_ARG(g_array_set_clear_func_REQUIRED_ARGC, g_array_set_clear_func_OPTIONAL_ARGC));
#endif
#if BIND_g_array_set_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_set_size", mrb_GLib_g_array_set_size, MRB_ARGS_ARG(g_array_set_size_REQUIRED_ARGC, g_array_set_size_OPTIONAL_ARGC));
#endif
#if BIND_g_array_sized_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_sized_new", mrb_GLib_g_array_sized_new, MRB_ARGS_ARG(g_array_sized_new_REQUIRED_ARGC, g_array_sized_new_OPTIONAL_ARGC));
#endif
#if BIND_g_array_sort_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_sort", mrb_GLib_g_array_sort, MRB_ARGS_ARG(g_array_sort_REQUIRED_ARGC, g_array_sort_OPTIONAL_ARGC));
#endif
#if BIND_g_array_sort_with_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_sort_with_data", mrb_GLib_g_array_sort_with_data, MRB_ARGS_ARG(g_array_sort_with_data_REQUIRED_ARGC, g_array_sort_with_data_OPTIONAL_ARGC));
#endif
#if BIND_g_array_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_array_unref", mrb_GLib_g_array_unref, MRB_ARGS_ARG(g_array_unref_REQUIRED_ARGC, g_array_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_digit_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_digit_value", mrb_GLib_g_ascii_digit_value, MRB_ARGS_ARG(g_ascii_digit_value_REQUIRED_ARGC, g_ascii_digit_value_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_dtostr_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_dtostr", mrb_GLib_g_ascii_dtostr, MRB_ARGS_ARG(g_ascii_dtostr_REQUIRED_ARGC, g_ascii_dtostr_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_formatd_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_formatd", mrb_GLib_g_ascii_formatd, MRB_ARGS_ARG(g_ascii_formatd_REQUIRED_ARGC, g_ascii_formatd_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_strcasecmp_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_strcasecmp", mrb_GLib_g_ascii_strcasecmp, MRB_ARGS_ARG(g_ascii_strcasecmp_REQUIRED_ARGC, g_ascii_strcasecmp_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_strdown_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_strdown", mrb_GLib_g_ascii_strdown, MRB_ARGS_ARG(g_ascii_strdown_REQUIRED_ARGC, g_ascii_strdown_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_strncasecmp_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_strncasecmp", mrb_GLib_g_ascii_strncasecmp, MRB_ARGS_ARG(g_ascii_strncasecmp_REQUIRED_ARGC, g_ascii_strncasecmp_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_strtod_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_strtod", mrb_GLib_g_ascii_strtod, MRB_ARGS_ARG(g_ascii_strtod_REQUIRED_ARGC, g_ascii_strtod_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_strtoll_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_strtoll", mrb_GLib_g_ascii_strtoll, MRB_ARGS_ARG(g_ascii_strtoll_REQUIRED_ARGC, g_ascii_strtoll_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_strtoull_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_strtoull", mrb_GLib_g_ascii_strtoull, MRB_ARGS_ARG(g_ascii_strtoull_REQUIRED_ARGC, g_ascii_strtoull_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_strup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_strup", mrb_GLib_g_ascii_strup, MRB_ARGS_ARG(g_ascii_strup_REQUIRED_ARGC, g_ascii_strup_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_tolower_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_tolower", mrb_GLib_g_ascii_tolower, MRB_ARGS_ARG(g_ascii_tolower_REQUIRED_ARGC, g_ascii_tolower_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_toupper_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_toupper", mrb_GLib_g_ascii_toupper, MRB_ARGS_ARG(g_ascii_toupper_REQUIRED_ARGC, g_ascii_toupper_OPTIONAL_ARGC));
#endif
#if BIND_g_ascii_xdigit_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ascii_xdigit_value", mrb_GLib_g_ascii_xdigit_value, MRB_ARGS_ARG(g_ascii_xdigit_value_REQUIRED_ARGC, g_ascii_xdigit_value_OPTIONAL_ARGC));
#endif
#if BIND_g_assert_warning_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_assert_warning", mrb_GLib_g_assert_warning, MRB_ARGS_ARG(g_assert_warning_REQUIRED_ARGC, g_assert_warning_OPTIONAL_ARGC));
#endif
#if BIND_g_assertion_message_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_assertion_message", mrb_GLib_g_assertion_message, MRB_ARGS_ARG(g_assertion_message_REQUIRED_ARGC, g_assertion_message_OPTIONAL_ARGC));
#endif
#if BIND_g_assertion_message_cmpnum_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_assertion_message_cmpnum", mrb_GLib_g_assertion_message_cmpnum, MRB_ARGS_ARG(g_assertion_message_cmpnum_REQUIRED_ARGC, g_assertion_message_cmpnum_OPTIONAL_ARGC));
#endif
#if BIND_g_assertion_message_cmpstr_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_assertion_message_cmpstr", mrb_GLib_g_assertion_message_cmpstr, MRB_ARGS_ARG(g_assertion_message_cmpstr_REQUIRED_ARGC, g_assertion_message_cmpstr_OPTIONAL_ARGC));
#endif
#if BIND_g_assertion_message_error_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_assertion_message_error", mrb_GLib_g_assertion_message_error, MRB_ARGS_ARG(g_assertion_message_error_REQUIRED_ARGC, g_assertion_message_error_OPTIONAL_ARGC));
#endif
#if BIND_g_assertion_message_expr_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_assertion_message_expr", mrb_GLib_g_assertion_message_expr, MRB_ARGS_ARG(g_assertion_message_expr_REQUIRED_ARGC, g_assertion_message_expr_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_length_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_length", mrb_GLib_g_async_queue_length, MRB_ARGS_ARG(g_async_queue_length_REQUIRED_ARGC, g_async_queue_length_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_length_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_length_unlocked", mrb_GLib_g_async_queue_length_unlocked, MRB_ARGS_ARG(g_async_queue_length_unlocked_REQUIRED_ARGC, g_async_queue_length_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_lock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_lock", mrb_GLib_g_async_queue_lock, MRB_ARGS_ARG(g_async_queue_lock_REQUIRED_ARGC, g_async_queue_lock_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_new", mrb_GLib_g_async_queue_new, MRB_ARGS_ARG(g_async_queue_new_REQUIRED_ARGC, g_async_queue_new_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_new_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_new_full", mrb_GLib_g_async_queue_new_full, MRB_ARGS_ARG(g_async_queue_new_full_REQUIRED_ARGC, g_async_queue_new_full_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_pop_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_pop", mrb_GLib_g_async_queue_pop, MRB_ARGS_ARG(g_async_queue_pop_REQUIRED_ARGC, g_async_queue_pop_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_pop_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_pop_unlocked", mrb_GLib_g_async_queue_pop_unlocked, MRB_ARGS_ARG(g_async_queue_pop_unlocked_REQUIRED_ARGC, g_async_queue_pop_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_push_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_push", mrb_GLib_g_async_queue_push, MRB_ARGS_ARG(g_async_queue_push_REQUIRED_ARGC, g_async_queue_push_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_push_front_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_push_front", mrb_GLib_g_async_queue_push_front, MRB_ARGS_ARG(g_async_queue_push_front_REQUIRED_ARGC, g_async_queue_push_front_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_push_front_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_push_front_unlocked", mrb_GLib_g_async_queue_push_front_unlocked, MRB_ARGS_ARG(g_async_queue_push_front_unlocked_REQUIRED_ARGC, g_async_queue_push_front_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_push_sorted_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_push_sorted", mrb_GLib_g_async_queue_push_sorted, MRB_ARGS_ARG(g_async_queue_push_sorted_REQUIRED_ARGC, g_async_queue_push_sorted_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_push_sorted_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_push_sorted_unlocked", mrb_GLib_g_async_queue_push_sorted_unlocked, MRB_ARGS_ARG(g_async_queue_push_sorted_unlocked_REQUIRED_ARGC, g_async_queue_push_sorted_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_push_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_push_unlocked", mrb_GLib_g_async_queue_push_unlocked, MRB_ARGS_ARG(g_async_queue_push_unlocked_REQUIRED_ARGC, g_async_queue_push_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_ref", mrb_GLib_g_async_queue_ref, MRB_ARGS_ARG(g_async_queue_ref_REQUIRED_ARGC, g_async_queue_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_ref_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_ref_unlocked", mrb_GLib_g_async_queue_ref_unlocked, MRB_ARGS_ARG(g_async_queue_ref_unlocked_REQUIRED_ARGC, g_async_queue_ref_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_remove", mrb_GLib_g_async_queue_remove, MRB_ARGS_ARG(g_async_queue_remove_REQUIRED_ARGC, g_async_queue_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_remove_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_remove_unlocked", mrb_GLib_g_async_queue_remove_unlocked, MRB_ARGS_ARG(g_async_queue_remove_unlocked_REQUIRED_ARGC, g_async_queue_remove_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_sort_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_sort", mrb_GLib_g_async_queue_sort, MRB_ARGS_ARG(g_async_queue_sort_REQUIRED_ARGC, g_async_queue_sort_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_sort_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_sort_unlocked", mrb_GLib_g_async_queue_sort_unlocked, MRB_ARGS_ARG(g_async_queue_sort_unlocked_REQUIRED_ARGC, g_async_queue_sort_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_timed_pop_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_timed_pop", mrb_GLib_g_async_queue_timed_pop, MRB_ARGS_ARG(g_async_queue_timed_pop_REQUIRED_ARGC, g_async_queue_timed_pop_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_timed_pop_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_timed_pop_unlocked", mrb_GLib_g_async_queue_timed_pop_unlocked, MRB_ARGS_ARG(g_async_queue_timed_pop_unlocked_REQUIRED_ARGC, g_async_queue_timed_pop_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_timeout_pop_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_timeout_pop", mrb_GLib_g_async_queue_timeout_pop, MRB_ARGS_ARG(g_async_queue_timeout_pop_REQUIRED_ARGC, g_async_queue_timeout_pop_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_timeout_pop_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_timeout_pop_unlocked", mrb_GLib_g_async_queue_timeout_pop_unlocked, MRB_ARGS_ARG(g_async_queue_timeout_pop_unlocked_REQUIRED_ARGC, g_async_queue_timeout_pop_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_try_pop_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_try_pop", mrb_GLib_g_async_queue_try_pop, MRB_ARGS_ARG(g_async_queue_try_pop_REQUIRED_ARGC, g_async_queue_try_pop_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_try_pop_unlocked_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_try_pop_unlocked", mrb_GLib_g_async_queue_try_pop_unlocked, MRB_ARGS_ARG(g_async_queue_try_pop_unlocked_REQUIRED_ARGC, g_async_queue_try_pop_unlocked_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_unlock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_unlock", mrb_GLib_g_async_queue_unlock, MRB_ARGS_ARG(g_async_queue_unlock_REQUIRED_ARGC, g_async_queue_unlock_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_unref", mrb_GLib_g_async_queue_unref, MRB_ARGS_ARG(g_async_queue_unref_REQUIRED_ARGC, g_async_queue_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_async_queue_unref_and_unlock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_async_queue_unref_and_unlock", mrb_GLib_g_async_queue_unref_and_unlock, MRB_ARGS_ARG(g_async_queue_unref_and_unlock_REQUIRED_ARGC, g_async_queue_unref_and_unlock_OPTIONAL_ARGC));
#endif
#if BIND_g_atexit_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atexit", mrb_GLib_g_atexit, MRB_ARGS_ARG(g_atexit_REQUIRED_ARGC, g_atexit_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_int_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_int_add", mrb_GLib_g_atomic_int_add, MRB_ARGS_ARG(g_atomic_int_add_REQUIRED_ARGC, g_atomic_int_add_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_int_and_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_int_and", mrb_GLib_g_atomic_int_and, MRB_ARGS_ARG(g_atomic_int_and_REQUIRED_ARGC, g_atomic_int_and_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_int_compare_and_exchange_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_int_compare_and_exchange", mrb_GLib_g_atomic_int_compare_and_exchange, MRB_ARGS_ARG(g_atomic_int_compare_and_exchange_REQUIRED_ARGC, g_atomic_int_compare_and_exchange_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_int_dec_and_test_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_int_dec_and_test", mrb_GLib_g_atomic_int_dec_and_test, MRB_ARGS_ARG(g_atomic_int_dec_and_test_REQUIRED_ARGC, g_atomic_int_dec_and_test_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_int_exchange_and_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_int_exchange_and_add", mrb_GLib_g_atomic_int_exchange_and_add, MRB_ARGS_ARG(g_atomic_int_exchange_and_add_REQUIRED_ARGC, g_atomic_int_exchange_and_add_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_int_get_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_int_get", mrb_GLib_g_atomic_int_get, MRB_ARGS_ARG(g_atomic_int_get_REQUIRED_ARGC, g_atomic_int_get_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_int_inc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_int_inc", mrb_GLib_g_atomic_int_inc, MRB_ARGS_ARG(g_atomic_int_inc_REQUIRED_ARGC, g_atomic_int_inc_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_int_or_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_int_or", mrb_GLib_g_atomic_int_or, MRB_ARGS_ARG(g_atomic_int_or_REQUIRED_ARGC, g_atomic_int_or_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_int_set_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_int_set", mrb_GLib_g_atomic_int_set, MRB_ARGS_ARG(g_atomic_int_set_REQUIRED_ARGC, g_atomic_int_set_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_int_xor_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_int_xor", mrb_GLib_g_atomic_int_xor, MRB_ARGS_ARG(g_atomic_int_xor_REQUIRED_ARGC, g_atomic_int_xor_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_pointer_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_pointer_add", mrb_GLib_g_atomic_pointer_add, MRB_ARGS_ARG(g_atomic_pointer_add_REQUIRED_ARGC, g_atomic_pointer_add_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_pointer_and_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_pointer_and", mrb_GLib_g_atomic_pointer_and, MRB_ARGS_ARG(g_atomic_pointer_and_REQUIRED_ARGC, g_atomic_pointer_and_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_pointer_compare_and_exchange_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_pointer_compare_and_exchange", mrb_GLib_g_atomic_pointer_compare_and_exchange, MRB_ARGS_ARG(g_atomic_pointer_compare_and_exchange_REQUIRED_ARGC, g_atomic_pointer_compare_and_exchange_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_pointer_get_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_pointer_get", mrb_GLib_g_atomic_pointer_get, MRB_ARGS_ARG(g_atomic_pointer_get_REQUIRED_ARGC, g_atomic_pointer_get_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_pointer_or_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_pointer_or", mrb_GLib_g_atomic_pointer_or, MRB_ARGS_ARG(g_atomic_pointer_or_REQUIRED_ARGC, g_atomic_pointer_or_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_pointer_set_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_pointer_set", mrb_GLib_g_atomic_pointer_set, MRB_ARGS_ARG(g_atomic_pointer_set_REQUIRED_ARGC, g_atomic_pointer_set_OPTIONAL_ARGC));
#endif
#if BIND_g_atomic_pointer_xor_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_atomic_pointer_xor", mrb_GLib_g_atomic_pointer_xor, MRB_ARGS_ARG(g_atomic_pointer_xor_REQUIRED_ARGC, g_atomic_pointer_xor_OPTIONAL_ARGC));
#endif
#if BIND_g_base64_decode_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_base64_decode", mrb_GLib_g_base64_decode, MRB_ARGS_ARG(g_base64_decode_REQUIRED_ARGC, g_base64_decode_OPTIONAL_ARGC));
#endif
#if BIND_g_base64_decode_inplace_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_base64_decode_inplace", mrb_GLib_g_base64_decode_inplace, MRB_ARGS_ARG(g_base64_decode_inplace_REQUIRED_ARGC, g_base64_decode_inplace_OPTIONAL_ARGC));
#endif
#if BIND_g_base64_decode_step_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_base64_decode_step", mrb_GLib_g_base64_decode_step, MRB_ARGS_ARG(g_base64_decode_step_REQUIRED_ARGC, g_base64_decode_step_OPTIONAL_ARGC));
#endif
#if BIND_g_base64_encode_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_base64_encode", mrb_GLib_g_base64_encode, MRB_ARGS_ARG(g_base64_encode_REQUIRED_ARGC, g_base64_encode_OPTIONAL_ARGC));
#endif
#if BIND_g_base64_encode_close_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_base64_encode_close", mrb_GLib_g_base64_encode_close, MRB_ARGS_ARG(g_base64_encode_close_REQUIRED_ARGC, g_base64_encode_close_OPTIONAL_ARGC));
#endif
#if BIND_g_base64_encode_step_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_base64_encode_step", mrb_GLib_g_base64_encode_step, MRB_ARGS_ARG(g_base64_encode_step_REQUIRED_ARGC, g_base64_encode_step_OPTIONAL_ARGC));
#endif
#if BIND_g_basename_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_basename", mrb_GLib_g_basename, MRB_ARGS_ARG(g_basename_REQUIRED_ARGC, g_basename_OPTIONAL_ARGC));
#endif
#if BIND_g_bit_lock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bit_lock", mrb_GLib_g_bit_lock, MRB_ARGS_ARG(g_bit_lock_REQUIRED_ARGC, g_bit_lock_OPTIONAL_ARGC));
#endif
#if BIND_g_bit_nth_lsf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bit_nth_lsf", mrb_GLib_g_bit_nth_lsf, MRB_ARGS_ARG(g_bit_nth_lsf_REQUIRED_ARGC, g_bit_nth_lsf_OPTIONAL_ARGC));
#endif
#if BIND_g_bit_nth_msf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bit_nth_msf", mrb_GLib_g_bit_nth_msf, MRB_ARGS_ARG(g_bit_nth_msf_REQUIRED_ARGC, g_bit_nth_msf_OPTIONAL_ARGC));
#endif
#if BIND_g_bit_storage_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bit_storage", mrb_GLib_g_bit_storage, MRB_ARGS_ARG(g_bit_storage_REQUIRED_ARGC, g_bit_storage_OPTIONAL_ARGC));
#endif
#if BIND_g_bit_trylock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bit_trylock", mrb_GLib_g_bit_trylock, MRB_ARGS_ARG(g_bit_trylock_REQUIRED_ARGC, g_bit_trylock_OPTIONAL_ARGC));
#endif
#if BIND_g_bit_unlock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bit_unlock", mrb_GLib_g_bit_unlock, MRB_ARGS_ARG(g_bit_unlock_REQUIRED_ARGC, g_bit_unlock_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_add_application_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_add_application", mrb_GLib_g_bookmark_file_add_application, MRB_ARGS_ARG(g_bookmark_file_add_application_REQUIRED_ARGC, g_bookmark_file_add_application_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_add_group_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_add_group", mrb_GLib_g_bookmark_file_add_group, MRB_ARGS_ARG(g_bookmark_file_add_group_REQUIRED_ARGC, g_bookmark_file_add_group_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_error_quark", mrb_GLib_g_bookmark_file_error_quark, MRB_ARGS_ARG(g_bookmark_file_error_quark_REQUIRED_ARGC, g_bookmark_file_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_free", mrb_GLib_g_bookmark_file_free, MRB_ARGS_ARG(g_bookmark_file_free_REQUIRED_ARGC, g_bookmark_file_free_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_added_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_added", mrb_GLib_g_bookmark_file_get_added, MRB_ARGS_ARG(g_bookmark_file_get_added_REQUIRED_ARGC, g_bookmark_file_get_added_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_app_info_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_app_info", mrb_GLib_g_bookmark_file_get_app_info, MRB_ARGS_ARG(g_bookmark_file_get_app_info_REQUIRED_ARGC, g_bookmark_file_get_app_info_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_applications_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_applications", mrb_GLib_g_bookmark_file_get_applications, MRB_ARGS_ARG(g_bookmark_file_get_applications_REQUIRED_ARGC, g_bookmark_file_get_applications_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_description_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_description", mrb_GLib_g_bookmark_file_get_description, MRB_ARGS_ARG(g_bookmark_file_get_description_REQUIRED_ARGC, g_bookmark_file_get_description_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_groups_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_groups", mrb_GLib_g_bookmark_file_get_groups, MRB_ARGS_ARG(g_bookmark_file_get_groups_REQUIRED_ARGC, g_bookmark_file_get_groups_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_icon_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_icon", mrb_GLib_g_bookmark_file_get_icon, MRB_ARGS_ARG(g_bookmark_file_get_icon_REQUIRED_ARGC, g_bookmark_file_get_icon_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_is_private_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_is_private", mrb_GLib_g_bookmark_file_get_is_private, MRB_ARGS_ARG(g_bookmark_file_get_is_private_REQUIRED_ARGC, g_bookmark_file_get_is_private_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_mime_type_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_mime_type", mrb_GLib_g_bookmark_file_get_mime_type, MRB_ARGS_ARG(g_bookmark_file_get_mime_type_REQUIRED_ARGC, g_bookmark_file_get_mime_type_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_modified_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_modified", mrb_GLib_g_bookmark_file_get_modified, MRB_ARGS_ARG(g_bookmark_file_get_modified_REQUIRED_ARGC, g_bookmark_file_get_modified_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_size", mrb_GLib_g_bookmark_file_get_size, MRB_ARGS_ARG(g_bookmark_file_get_size_REQUIRED_ARGC, g_bookmark_file_get_size_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_title_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_title", mrb_GLib_g_bookmark_file_get_title, MRB_ARGS_ARG(g_bookmark_file_get_title_REQUIRED_ARGC, g_bookmark_file_get_title_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_uris_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_uris", mrb_GLib_g_bookmark_file_get_uris, MRB_ARGS_ARG(g_bookmark_file_get_uris_REQUIRED_ARGC, g_bookmark_file_get_uris_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_get_visited_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_get_visited", mrb_GLib_g_bookmark_file_get_visited, MRB_ARGS_ARG(g_bookmark_file_get_visited_REQUIRED_ARGC, g_bookmark_file_get_visited_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_has_application_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_has_application", mrb_GLib_g_bookmark_file_has_application, MRB_ARGS_ARG(g_bookmark_file_has_application_REQUIRED_ARGC, g_bookmark_file_has_application_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_has_group_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_has_group", mrb_GLib_g_bookmark_file_has_group, MRB_ARGS_ARG(g_bookmark_file_has_group_REQUIRED_ARGC, g_bookmark_file_has_group_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_has_item_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_has_item", mrb_GLib_g_bookmark_file_has_item, MRB_ARGS_ARG(g_bookmark_file_has_item_REQUIRED_ARGC, g_bookmark_file_has_item_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_load_from_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_load_from_data", mrb_GLib_g_bookmark_file_load_from_data, MRB_ARGS_ARG(g_bookmark_file_load_from_data_REQUIRED_ARGC, g_bookmark_file_load_from_data_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_load_from_data_dirs_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_load_from_data_dirs", mrb_GLib_g_bookmark_file_load_from_data_dirs, MRB_ARGS_ARG(g_bookmark_file_load_from_data_dirs_REQUIRED_ARGC, g_bookmark_file_load_from_data_dirs_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_load_from_file_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_load_from_file", mrb_GLib_g_bookmark_file_load_from_file, MRB_ARGS_ARG(g_bookmark_file_load_from_file_REQUIRED_ARGC, g_bookmark_file_load_from_file_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_move_item_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_move_item", mrb_GLib_g_bookmark_file_move_item, MRB_ARGS_ARG(g_bookmark_file_move_item_REQUIRED_ARGC, g_bookmark_file_move_item_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_new", mrb_GLib_g_bookmark_file_new, MRB_ARGS_ARG(g_bookmark_file_new_REQUIRED_ARGC, g_bookmark_file_new_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_remove_application_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_remove_application", mrb_GLib_g_bookmark_file_remove_application, MRB_ARGS_ARG(g_bookmark_file_remove_application_REQUIRED_ARGC, g_bookmark_file_remove_application_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_remove_group_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_remove_group", mrb_GLib_g_bookmark_file_remove_group, MRB_ARGS_ARG(g_bookmark_file_remove_group_REQUIRED_ARGC, g_bookmark_file_remove_group_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_remove_item_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_remove_item", mrb_GLib_g_bookmark_file_remove_item, MRB_ARGS_ARG(g_bookmark_file_remove_item_REQUIRED_ARGC, g_bookmark_file_remove_item_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_set_added_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_set_added", mrb_GLib_g_bookmark_file_set_added, MRB_ARGS_ARG(g_bookmark_file_set_added_REQUIRED_ARGC, g_bookmark_file_set_added_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_set_app_info_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_set_app_info", mrb_GLib_g_bookmark_file_set_app_info, MRB_ARGS_ARG(g_bookmark_file_set_app_info_REQUIRED_ARGC, g_bookmark_file_set_app_info_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_set_description_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_set_description", mrb_GLib_g_bookmark_file_set_description, MRB_ARGS_ARG(g_bookmark_file_set_description_REQUIRED_ARGC, g_bookmark_file_set_description_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_set_groups_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_set_groups", mrb_GLib_g_bookmark_file_set_groups, MRB_ARGS_ARG(g_bookmark_file_set_groups_REQUIRED_ARGC, g_bookmark_file_set_groups_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_set_icon_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_set_icon", mrb_GLib_g_bookmark_file_set_icon, MRB_ARGS_ARG(g_bookmark_file_set_icon_REQUIRED_ARGC, g_bookmark_file_set_icon_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_set_is_private_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_set_is_private", mrb_GLib_g_bookmark_file_set_is_private, MRB_ARGS_ARG(g_bookmark_file_set_is_private_REQUIRED_ARGC, g_bookmark_file_set_is_private_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_set_mime_type_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_set_mime_type", mrb_GLib_g_bookmark_file_set_mime_type, MRB_ARGS_ARG(g_bookmark_file_set_mime_type_REQUIRED_ARGC, g_bookmark_file_set_mime_type_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_set_modified_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_set_modified", mrb_GLib_g_bookmark_file_set_modified, MRB_ARGS_ARG(g_bookmark_file_set_modified_REQUIRED_ARGC, g_bookmark_file_set_modified_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_set_title_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_set_title", mrb_GLib_g_bookmark_file_set_title, MRB_ARGS_ARG(g_bookmark_file_set_title_REQUIRED_ARGC, g_bookmark_file_set_title_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_set_visited_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_set_visited", mrb_GLib_g_bookmark_file_set_visited, MRB_ARGS_ARG(g_bookmark_file_set_visited_REQUIRED_ARGC, g_bookmark_file_set_visited_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_to_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_to_data", mrb_GLib_g_bookmark_file_to_data, MRB_ARGS_ARG(g_bookmark_file_to_data_REQUIRED_ARGC, g_bookmark_file_to_data_OPTIONAL_ARGC));
#endif
#if BIND_g_bookmark_file_to_file_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bookmark_file_to_file", mrb_GLib_g_bookmark_file_to_file, MRB_ARGS_ARG(g_bookmark_file_to_file_REQUIRED_ARGC, g_bookmark_file_to_file_OPTIONAL_ARGC));
#endif
#if BIND_g_build_filename_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_build_filename", mrb_GLib_g_build_filename, MRB_ARGS_ARG(g_build_filename_REQUIRED_ARGC, g_build_filename_OPTIONAL_ARGC));
#endif
#if BIND_g_build_filenamev_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_build_filenamev", mrb_GLib_g_build_filenamev, MRB_ARGS_ARG(g_build_filenamev_REQUIRED_ARGC, g_build_filenamev_OPTIONAL_ARGC));
#endif
#if BIND_g_build_path_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_build_path", mrb_GLib_g_build_path, MRB_ARGS_ARG(g_build_path_REQUIRED_ARGC, g_build_path_OPTIONAL_ARGC));
#endif
#if BIND_g_build_pathv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_build_pathv", mrb_GLib_g_build_pathv, MRB_ARGS_ARG(g_build_pathv_REQUIRED_ARGC, g_build_pathv_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_append_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_append", mrb_GLib_g_byte_array_append, MRB_ARGS_ARG(g_byte_array_append_REQUIRED_ARGC, g_byte_array_append_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_free", mrb_GLib_g_byte_array_free, MRB_ARGS_ARG(g_byte_array_free_REQUIRED_ARGC, g_byte_array_free_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_free_to_bytes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_free_to_bytes", mrb_GLib_g_byte_array_free_to_bytes, MRB_ARGS_ARG(g_byte_array_free_to_bytes_REQUIRED_ARGC, g_byte_array_free_to_bytes_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_new", mrb_GLib_g_byte_array_new, MRB_ARGS_ARG(g_byte_array_new_REQUIRED_ARGC, g_byte_array_new_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_new_take_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_new_take", mrb_GLib_g_byte_array_new_take, MRB_ARGS_ARG(g_byte_array_new_take_REQUIRED_ARGC, g_byte_array_new_take_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_prepend_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_prepend", mrb_GLib_g_byte_array_prepend, MRB_ARGS_ARG(g_byte_array_prepend_REQUIRED_ARGC, g_byte_array_prepend_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_ref", mrb_GLib_g_byte_array_ref, MRB_ARGS_ARG(g_byte_array_ref_REQUIRED_ARGC, g_byte_array_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_remove_index_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_remove_index", mrb_GLib_g_byte_array_remove_index, MRB_ARGS_ARG(g_byte_array_remove_index_REQUIRED_ARGC, g_byte_array_remove_index_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_remove_index_fast_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_remove_index_fast", mrb_GLib_g_byte_array_remove_index_fast, MRB_ARGS_ARG(g_byte_array_remove_index_fast_REQUIRED_ARGC, g_byte_array_remove_index_fast_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_remove_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_remove_range", mrb_GLib_g_byte_array_remove_range, MRB_ARGS_ARG(g_byte_array_remove_range_REQUIRED_ARGC, g_byte_array_remove_range_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_set_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_set_size", mrb_GLib_g_byte_array_set_size, MRB_ARGS_ARG(g_byte_array_set_size_REQUIRED_ARGC, g_byte_array_set_size_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_sized_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_sized_new", mrb_GLib_g_byte_array_sized_new, MRB_ARGS_ARG(g_byte_array_sized_new_REQUIRED_ARGC, g_byte_array_sized_new_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_sort_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_sort", mrb_GLib_g_byte_array_sort, MRB_ARGS_ARG(g_byte_array_sort_REQUIRED_ARGC, g_byte_array_sort_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_sort_with_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_sort_with_data", mrb_GLib_g_byte_array_sort_with_data, MRB_ARGS_ARG(g_byte_array_sort_with_data_REQUIRED_ARGC, g_byte_array_sort_with_data_OPTIONAL_ARGC));
#endif
#if BIND_g_byte_array_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_byte_array_unref", mrb_GLib_g_byte_array_unref, MRB_ARGS_ARG(g_byte_array_unref_REQUIRED_ARGC, g_byte_array_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_compare_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_compare", mrb_GLib_g_bytes_compare, MRB_ARGS_ARG(g_bytes_compare_REQUIRED_ARGC, g_bytes_compare_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_equal", mrb_GLib_g_bytes_equal, MRB_ARGS_ARG(g_bytes_equal_REQUIRED_ARGC, g_bytes_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_get_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_get_data", mrb_GLib_g_bytes_get_data, MRB_ARGS_ARG(g_bytes_get_data_REQUIRED_ARGC, g_bytes_get_data_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_get_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_get_size", mrb_GLib_g_bytes_get_size, MRB_ARGS_ARG(g_bytes_get_size_REQUIRED_ARGC, g_bytes_get_size_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_hash_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_hash", mrb_GLib_g_bytes_hash, MRB_ARGS_ARG(g_bytes_hash_REQUIRED_ARGC, g_bytes_hash_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_new", mrb_GLib_g_bytes_new, MRB_ARGS_ARG(g_bytes_new_REQUIRED_ARGC, g_bytes_new_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_new_from_bytes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_new_from_bytes", mrb_GLib_g_bytes_new_from_bytes, MRB_ARGS_ARG(g_bytes_new_from_bytes_REQUIRED_ARGC, g_bytes_new_from_bytes_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_new_static_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_new_static", mrb_GLib_g_bytes_new_static, MRB_ARGS_ARG(g_bytes_new_static_REQUIRED_ARGC, g_bytes_new_static_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_new_take_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_new_take", mrb_GLib_g_bytes_new_take, MRB_ARGS_ARG(g_bytes_new_take_REQUIRED_ARGC, g_bytes_new_take_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_new_with_free_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_new_with_free_func", mrb_GLib_g_bytes_new_with_free_func, MRB_ARGS_ARG(g_bytes_new_with_free_func_REQUIRED_ARGC, g_bytes_new_with_free_func_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_ref", mrb_GLib_g_bytes_ref, MRB_ARGS_ARG(g_bytes_ref_REQUIRED_ARGC, g_bytes_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_unref", mrb_GLib_g_bytes_unref, MRB_ARGS_ARG(g_bytes_unref_REQUIRED_ARGC, g_bytes_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_unref_to_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_unref_to_array", mrb_GLib_g_bytes_unref_to_array, MRB_ARGS_ARG(g_bytes_unref_to_array_REQUIRED_ARGC, g_bytes_unref_to_array_OPTIONAL_ARGC));
#endif
#if BIND_g_bytes_unref_to_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_bytes_unref_to_data", mrb_GLib_g_bytes_unref_to_data, MRB_ARGS_ARG(g_bytes_unref_to_data_REQUIRED_ARGC, g_bytes_unref_to_data_OPTIONAL_ARGC));
#endif
#if BIND_g_chdir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_chdir", mrb_GLib_g_chdir, MRB_ARGS_ARG(g_chdir_REQUIRED_ARGC, g_chdir_OPTIONAL_ARGC));
#endif
#if BIND_g_checksum_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_checksum_copy", mrb_GLib_g_checksum_copy, MRB_ARGS_ARG(g_checksum_copy_REQUIRED_ARGC, g_checksum_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_checksum_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_checksum_free", mrb_GLib_g_checksum_free, MRB_ARGS_ARG(g_checksum_free_REQUIRED_ARGC, g_checksum_free_OPTIONAL_ARGC));
#endif
#if BIND_g_checksum_get_digest_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_checksum_get_digest", mrb_GLib_g_checksum_get_digest, MRB_ARGS_ARG(g_checksum_get_digest_REQUIRED_ARGC, g_checksum_get_digest_OPTIONAL_ARGC));
#endif
#if BIND_g_checksum_get_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_checksum_get_string", mrb_GLib_g_checksum_get_string, MRB_ARGS_ARG(g_checksum_get_string_REQUIRED_ARGC, g_checksum_get_string_OPTIONAL_ARGC));
#endif
#if BIND_g_checksum_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_checksum_new", mrb_GLib_g_checksum_new, MRB_ARGS_ARG(g_checksum_new_REQUIRED_ARGC, g_checksum_new_OPTIONAL_ARGC));
#endif
#if BIND_g_checksum_reset_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_checksum_reset", mrb_GLib_g_checksum_reset, MRB_ARGS_ARG(g_checksum_reset_REQUIRED_ARGC, g_checksum_reset_OPTIONAL_ARGC));
#endif
#if BIND_g_checksum_type_get_length_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_checksum_type_get_length", mrb_GLib_g_checksum_type_get_length, MRB_ARGS_ARG(g_checksum_type_get_length_REQUIRED_ARGC, g_checksum_type_get_length_OPTIONAL_ARGC));
#endif
#if BIND_g_checksum_update_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_checksum_update", mrb_GLib_g_checksum_update, MRB_ARGS_ARG(g_checksum_update_REQUIRED_ARGC, g_checksum_update_OPTIONAL_ARGC));
#endif
#if BIND_g_child_watch_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_child_watch_add", mrb_GLib_g_child_watch_add, MRB_ARGS_ARG(g_child_watch_add_REQUIRED_ARGC, g_child_watch_add_OPTIONAL_ARGC));
#endif
#if BIND_g_child_watch_add_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_child_watch_add_full", mrb_GLib_g_child_watch_add_full, MRB_ARGS_ARG(g_child_watch_add_full_REQUIRED_ARGC, g_child_watch_add_full_OPTIONAL_ARGC));
#endif
#if BIND_g_child_watch_source_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_child_watch_source_new", mrb_GLib_g_child_watch_source_new, MRB_ARGS_ARG(g_child_watch_source_new_REQUIRED_ARGC, g_child_watch_source_new_OPTIONAL_ARGC));
#endif
#if BIND_g_clear_error_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_clear_error", mrb_GLib_g_clear_error, MRB_ARGS_ARG(g_clear_error_REQUIRED_ARGC, g_clear_error_OPTIONAL_ARGC));
#endif
#if BIND_g_clear_pointer_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_clear_pointer", mrb_GLib_g_clear_pointer, MRB_ARGS_ARG(g_clear_pointer_REQUIRED_ARGC, g_clear_pointer_OPTIONAL_ARGC));
#endif
#if BIND_g_close_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_close", mrb_GLib_g_close, MRB_ARGS_ARG(g_close_REQUIRED_ARGC, g_close_OPTIONAL_ARGC));
#endif
#if BIND_g_compute_checksum_for_bytes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_compute_checksum_for_bytes", mrb_GLib_g_compute_checksum_for_bytes, MRB_ARGS_ARG(g_compute_checksum_for_bytes_REQUIRED_ARGC, g_compute_checksum_for_bytes_OPTIONAL_ARGC));
#endif
#if BIND_g_compute_checksum_for_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_compute_checksum_for_data", mrb_GLib_g_compute_checksum_for_data, MRB_ARGS_ARG(g_compute_checksum_for_data_REQUIRED_ARGC, g_compute_checksum_for_data_OPTIONAL_ARGC));
#endif
#if BIND_g_compute_checksum_for_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_compute_checksum_for_string", mrb_GLib_g_compute_checksum_for_string, MRB_ARGS_ARG(g_compute_checksum_for_string_REQUIRED_ARGC, g_compute_checksum_for_string_OPTIONAL_ARGC));
#endif
#if BIND_g_compute_hmac_for_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_compute_hmac_for_data", mrb_GLib_g_compute_hmac_for_data, MRB_ARGS_ARG(g_compute_hmac_for_data_REQUIRED_ARGC, g_compute_hmac_for_data_OPTIONAL_ARGC));
#endif
#if BIND_g_compute_hmac_for_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_compute_hmac_for_string", mrb_GLib_g_compute_hmac_for_string, MRB_ARGS_ARG(g_compute_hmac_for_string_REQUIRED_ARGC, g_compute_hmac_for_string_OPTIONAL_ARGC));
#endif
#if BIND_g_cond_broadcast_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_cond_broadcast", mrb_GLib_g_cond_broadcast, MRB_ARGS_ARG(g_cond_broadcast_REQUIRED_ARGC, g_cond_broadcast_OPTIONAL_ARGC));
#endif
#if BIND_g_cond_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_cond_clear", mrb_GLib_g_cond_clear, MRB_ARGS_ARG(g_cond_clear_REQUIRED_ARGC, g_cond_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_cond_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_cond_init", mrb_GLib_g_cond_init, MRB_ARGS_ARG(g_cond_init_REQUIRED_ARGC, g_cond_init_OPTIONAL_ARGC));
#endif
#if BIND_g_cond_signal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_cond_signal", mrb_GLib_g_cond_signal, MRB_ARGS_ARG(g_cond_signal_REQUIRED_ARGC, g_cond_signal_OPTIONAL_ARGC));
#endif
#if BIND_g_cond_wait_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_cond_wait", mrb_GLib_g_cond_wait, MRB_ARGS_ARG(g_cond_wait_REQUIRED_ARGC, g_cond_wait_OPTIONAL_ARGC));
#endif
#if BIND_g_cond_wait_until_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_cond_wait_until", mrb_GLib_g_cond_wait_until, MRB_ARGS_ARG(g_cond_wait_until_REQUIRED_ARGC, g_cond_wait_until_OPTIONAL_ARGC));
#endif
#if BIND_g_convert_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_convert", mrb_GLib_g_convert, MRB_ARGS_ARG(g_convert_REQUIRED_ARGC, g_convert_OPTIONAL_ARGC));
#endif
#if BIND_g_convert_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_convert_error_quark", mrb_GLib_g_convert_error_quark, MRB_ARGS_ARG(g_convert_error_quark_REQUIRED_ARGC, g_convert_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_convert_with_fallback_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_convert_with_fallback", mrb_GLib_g_convert_with_fallback, MRB_ARGS_ARG(g_convert_with_fallback_REQUIRED_ARGC, g_convert_with_fallback_OPTIONAL_ARGC));
#endif
#if BIND_g_convert_with_iconv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_convert_with_iconv", mrb_GLib_g_convert_with_iconv, MRB_ARGS_ARG(g_convert_with_iconv_REQUIRED_ARGC, g_convert_with_iconv_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_clear", mrb_GLib_g_datalist_clear, MRB_ARGS_ARG(g_datalist_clear_REQUIRED_ARGC, g_datalist_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_foreach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_foreach", mrb_GLib_g_datalist_foreach, MRB_ARGS_ARG(g_datalist_foreach_REQUIRED_ARGC, g_datalist_foreach_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_get_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_get_data", mrb_GLib_g_datalist_get_data, MRB_ARGS_ARG(g_datalist_get_data_REQUIRED_ARGC, g_datalist_get_data_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_get_flags_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_get_flags", mrb_GLib_g_datalist_get_flags, MRB_ARGS_ARG(g_datalist_get_flags_REQUIRED_ARGC, g_datalist_get_flags_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_id_dup_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_id_dup_data", mrb_GLib_g_datalist_id_dup_data, MRB_ARGS_ARG(g_datalist_id_dup_data_REQUIRED_ARGC, g_datalist_id_dup_data_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_id_get_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_id_get_data", mrb_GLib_g_datalist_id_get_data, MRB_ARGS_ARG(g_datalist_id_get_data_REQUIRED_ARGC, g_datalist_id_get_data_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_id_remove_no_notify_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_id_remove_no_notify", mrb_GLib_g_datalist_id_remove_no_notify, MRB_ARGS_ARG(g_datalist_id_remove_no_notify_REQUIRED_ARGC, g_datalist_id_remove_no_notify_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_id_replace_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_id_replace_data", mrb_GLib_g_datalist_id_replace_data, MRB_ARGS_ARG(g_datalist_id_replace_data_REQUIRED_ARGC, g_datalist_id_replace_data_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_id_set_data_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_id_set_data_full", mrb_GLib_g_datalist_id_set_data_full, MRB_ARGS_ARG(g_datalist_id_set_data_full_REQUIRED_ARGC, g_datalist_id_set_data_full_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_init", mrb_GLib_g_datalist_init, MRB_ARGS_ARG(g_datalist_init_REQUIRED_ARGC, g_datalist_init_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_set_flags_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_set_flags", mrb_GLib_g_datalist_set_flags, MRB_ARGS_ARG(g_datalist_set_flags_REQUIRED_ARGC, g_datalist_set_flags_OPTIONAL_ARGC));
#endif
#if BIND_g_datalist_unset_flags_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_datalist_unset_flags", mrb_GLib_g_datalist_unset_flags, MRB_ARGS_ARG(g_datalist_unset_flags_REQUIRED_ARGC, g_datalist_unset_flags_OPTIONAL_ARGC));
#endif
#if BIND_g_dataset_destroy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dataset_destroy", mrb_GLib_g_dataset_destroy, MRB_ARGS_ARG(g_dataset_destroy_REQUIRED_ARGC, g_dataset_destroy_OPTIONAL_ARGC));
#endif
#if BIND_g_dataset_foreach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dataset_foreach", mrb_GLib_g_dataset_foreach, MRB_ARGS_ARG(g_dataset_foreach_REQUIRED_ARGC, g_dataset_foreach_OPTIONAL_ARGC));
#endif
#if BIND_g_dataset_id_get_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dataset_id_get_data", mrb_GLib_g_dataset_id_get_data, MRB_ARGS_ARG(g_dataset_id_get_data_REQUIRED_ARGC, g_dataset_id_get_data_OPTIONAL_ARGC));
#endif
#if BIND_g_dataset_id_remove_no_notify_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dataset_id_remove_no_notify", mrb_GLib_g_dataset_id_remove_no_notify, MRB_ARGS_ARG(g_dataset_id_remove_no_notify_REQUIRED_ARGC, g_dataset_id_remove_no_notify_OPTIONAL_ARGC));
#endif
#if BIND_g_dataset_id_set_data_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dataset_id_set_data_full", mrb_GLib_g_dataset_id_set_data_full, MRB_ARGS_ARG(g_dataset_id_set_data_full_REQUIRED_ARGC, g_dataset_id_set_data_full_OPTIONAL_ARGC));
#endif
#if BIND_g_date_add_days_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_add_days", mrb_GLib_g_date_add_days, MRB_ARGS_ARG(g_date_add_days_REQUIRED_ARGC, g_date_add_days_OPTIONAL_ARGC));
#endif
#if BIND_g_date_add_months_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_add_months", mrb_GLib_g_date_add_months, MRB_ARGS_ARG(g_date_add_months_REQUIRED_ARGC, g_date_add_months_OPTIONAL_ARGC));
#endif
#if BIND_g_date_add_years_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_add_years", mrb_GLib_g_date_add_years, MRB_ARGS_ARG(g_date_add_years_REQUIRED_ARGC, g_date_add_years_OPTIONAL_ARGC));
#endif
#if BIND_g_date_clamp_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_clamp", mrb_GLib_g_date_clamp, MRB_ARGS_ARG(g_date_clamp_REQUIRED_ARGC, g_date_clamp_OPTIONAL_ARGC));
#endif
#if BIND_g_date_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_clear", mrb_GLib_g_date_clear, MRB_ARGS_ARG(g_date_clear_REQUIRED_ARGC, g_date_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_date_compare_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_compare", mrb_GLib_g_date_compare, MRB_ARGS_ARG(g_date_compare_REQUIRED_ARGC, g_date_compare_OPTIONAL_ARGC));
#endif
#if BIND_g_date_days_between_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_days_between", mrb_GLib_g_date_days_between, MRB_ARGS_ARG(g_date_days_between_REQUIRED_ARGC, g_date_days_between_OPTIONAL_ARGC));
#endif
#if BIND_g_date_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_free", mrb_GLib_g_date_free, MRB_ARGS_ARG(g_date_free_REQUIRED_ARGC, g_date_free_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_day_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_day", mrb_GLib_g_date_get_day, MRB_ARGS_ARG(g_date_get_day_REQUIRED_ARGC, g_date_get_day_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_day_of_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_day_of_year", mrb_GLib_g_date_get_day_of_year, MRB_ARGS_ARG(g_date_get_day_of_year_REQUIRED_ARGC, g_date_get_day_of_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_days_in_month_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_days_in_month", mrb_GLib_g_date_get_days_in_month, MRB_ARGS_ARG(g_date_get_days_in_month_REQUIRED_ARGC, g_date_get_days_in_month_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_iso8601_week_of_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_iso8601_week_of_year", mrb_GLib_g_date_get_iso8601_week_of_year, MRB_ARGS_ARG(g_date_get_iso8601_week_of_year_REQUIRED_ARGC, g_date_get_iso8601_week_of_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_julian_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_julian", mrb_GLib_g_date_get_julian, MRB_ARGS_ARG(g_date_get_julian_REQUIRED_ARGC, g_date_get_julian_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_monday_week_of_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_monday_week_of_year", mrb_GLib_g_date_get_monday_week_of_year, MRB_ARGS_ARG(g_date_get_monday_week_of_year_REQUIRED_ARGC, g_date_get_monday_week_of_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_monday_weeks_in_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_monday_weeks_in_year", mrb_GLib_g_date_get_monday_weeks_in_year, MRB_ARGS_ARG(g_date_get_monday_weeks_in_year_REQUIRED_ARGC, g_date_get_monday_weeks_in_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_month_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_month", mrb_GLib_g_date_get_month, MRB_ARGS_ARG(g_date_get_month_REQUIRED_ARGC, g_date_get_month_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_sunday_week_of_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_sunday_week_of_year", mrb_GLib_g_date_get_sunday_week_of_year, MRB_ARGS_ARG(g_date_get_sunday_week_of_year_REQUIRED_ARGC, g_date_get_sunday_week_of_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_sunday_weeks_in_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_sunday_weeks_in_year", mrb_GLib_g_date_get_sunday_weeks_in_year, MRB_ARGS_ARG(g_date_get_sunday_weeks_in_year_REQUIRED_ARGC, g_date_get_sunday_weeks_in_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_weekday_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_weekday", mrb_GLib_g_date_get_weekday, MRB_ARGS_ARG(g_date_get_weekday_REQUIRED_ARGC, g_date_get_weekday_OPTIONAL_ARGC));
#endif
#if BIND_g_date_get_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_get_year", mrb_GLib_g_date_get_year, MRB_ARGS_ARG(g_date_get_year_REQUIRED_ARGC, g_date_get_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_is_first_of_month_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_is_first_of_month", mrb_GLib_g_date_is_first_of_month, MRB_ARGS_ARG(g_date_is_first_of_month_REQUIRED_ARGC, g_date_is_first_of_month_OPTIONAL_ARGC));
#endif
#if BIND_g_date_is_last_of_month_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_is_last_of_month", mrb_GLib_g_date_is_last_of_month, MRB_ARGS_ARG(g_date_is_last_of_month_REQUIRED_ARGC, g_date_is_last_of_month_OPTIONAL_ARGC));
#endif
#if BIND_g_date_is_leap_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_is_leap_year", mrb_GLib_g_date_is_leap_year, MRB_ARGS_ARG(g_date_is_leap_year_REQUIRED_ARGC, g_date_is_leap_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_new", mrb_GLib_g_date_new, MRB_ARGS_ARG(g_date_new_REQUIRED_ARGC, g_date_new_OPTIONAL_ARGC));
#endif
#if BIND_g_date_new_dmy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_new_dmy", mrb_GLib_g_date_new_dmy, MRB_ARGS_ARG(g_date_new_dmy_REQUIRED_ARGC, g_date_new_dmy_OPTIONAL_ARGC));
#endif
#if BIND_g_date_new_julian_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_new_julian", mrb_GLib_g_date_new_julian, MRB_ARGS_ARG(g_date_new_julian_REQUIRED_ARGC, g_date_new_julian_OPTIONAL_ARGC));
#endif
#if BIND_g_date_order_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_order", mrb_GLib_g_date_order, MRB_ARGS_ARG(g_date_order_REQUIRED_ARGC, g_date_order_OPTIONAL_ARGC));
#endif
#if BIND_g_date_set_day_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_set_day", mrb_GLib_g_date_set_day, MRB_ARGS_ARG(g_date_set_day_REQUIRED_ARGC, g_date_set_day_OPTIONAL_ARGC));
#endif
#if BIND_g_date_set_dmy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_set_dmy", mrb_GLib_g_date_set_dmy, MRB_ARGS_ARG(g_date_set_dmy_REQUIRED_ARGC, g_date_set_dmy_OPTIONAL_ARGC));
#endif
#if BIND_g_date_set_julian_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_set_julian", mrb_GLib_g_date_set_julian, MRB_ARGS_ARG(g_date_set_julian_REQUIRED_ARGC, g_date_set_julian_OPTIONAL_ARGC));
#endif
#if BIND_g_date_set_month_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_set_month", mrb_GLib_g_date_set_month, MRB_ARGS_ARG(g_date_set_month_REQUIRED_ARGC, g_date_set_month_OPTIONAL_ARGC));
#endif
#if BIND_g_date_set_parse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_set_parse", mrb_GLib_g_date_set_parse, MRB_ARGS_ARG(g_date_set_parse_REQUIRED_ARGC, g_date_set_parse_OPTIONAL_ARGC));
#endif
#if BIND_g_date_set_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_set_time", mrb_GLib_g_date_set_time, MRB_ARGS_ARG(g_date_set_time_REQUIRED_ARGC, g_date_set_time_OPTIONAL_ARGC));
#endif
#if BIND_g_date_set_time_t_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_set_time_t", mrb_GLib_g_date_set_time_t, MRB_ARGS_ARG(g_date_set_time_t_REQUIRED_ARGC, g_date_set_time_t_OPTIONAL_ARGC));
#endif
#if BIND_g_date_set_time_val_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_set_time_val", mrb_GLib_g_date_set_time_val, MRB_ARGS_ARG(g_date_set_time_val_REQUIRED_ARGC, g_date_set_time_val_OPTIONAL_ARGC));
#endif
#if BIND_g_date_set_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_set_year", mrb_GLib_g_date_set_year, MRB_ARGS_ARG(g_date_set_year_REQUIRED_ARGC, g_date_set_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_strftime_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_strftime", mrb_GLib_g_date_strftime, MRB_ARGS_ARG(g_date_strftime_REQUIRED_ARGC, g_date_strftime_OPTIONAL_ARGC));
#endif
#if BIND_g_date_subtract_days_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_subtract_days", mrb_GLib_g_date_subtract_days, MRB_ARGS_ARG(g_date_subtract_days_REQUIRED_ARGC, g_date_subtract_days_OPTIONAL_ARGC));
#endif
#if BIND_g_date_subtract_months_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_subtract_months", mrb_GLib_g_date_subtract_months, MRB_ARGS_ARG(g_date_subtract_months_REQUIRED_ARGC, g_date_subtract_months_OPTIONAL_ARGC));
#endif
#if BIND_g_date_subtract_years_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_subtract_years", mrb_GLib_g_date_subtract_years, MRB_ARGS_ARG(g_date_subtract_years_REQUIRED_ARGC, g_date_subtract_years_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_add", mrb_GLib_g_date_time_add, MRB_ARGS_ARG(g_date_time_add_REQUIRED_ARGC, g_date_time_add_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_add_days_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_add_days", mrb_GLib_g_date_time_add_days, MRB_ARGS_ARG(g_date_time_add_days_REQUIRED_ARGC, g_date_time_add_days_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_add_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_add_full", mrb_GLib_g_date_time_add_full, MRB_ARGS_ARG(g_date_time_add_full_REQUIRED_ARGC, g_date_time_add_full_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_add_hours_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_add_hours", mrb_GLib_g_date_time_add_hours, MRB_ARGS_ARG(g_date_time_add_hours_REQUIRED_ARGC, g_date_time_add_hours_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_add_minutes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_add_minutes", mrb_GLib_g_date_time_add_minutes, MRB_ARGS_ARG(g_date_time_add_minutes_REQUIRED_ARGC, g_date_time_add_minutes_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_add_months_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_add_months", mrb_GLib_g_date_time_add_months, MRB_ARGS_ARG(g_date_time_add_months_REQUIRED_ARGC, g_date_time_add_months_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_add_seconds_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_add_seconds", mrb_GLib_g_date_time_add_seconds, MRB_ARGS_ARG(g_date_time_add_seconds_REQUIRED_ARGC, g_date_time_add_seconds_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_add_weeks_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_add_weeks", mrb_GLib_g_date_time_add_weeks, MRB_ARGS_ARG(g_date_time_add_weeks_REQUIRED_ARGC, g_date_time_add_weeks_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_add_years_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_add_years", mrb_GLib_g_date_time_add_years, MRB_ARGS_ARG(g_date_time_add_years_REQUIRED_ARGC, g_date_time_add_years_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_compare_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_compare", mrb_GLib_g_date_time_compare, MRB_ARGS_ARG(g_date_time_compare_REQUIRED_ARGC, g_date_time_compare_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_difference_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_difference", mrb_GLib_g_date_time_difference, MRB_ARGS_ARG(g_date_time_difference_REQUIRED_ARGC, g_date_time_difference_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_equal", mrb_GLib_g_date_time_equal, MRB_ARGS_ARG(g_date_time_equal_REQUIRED_ARGC, g_date_time_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_format_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_format", mrb_GLib_g_date_time_format, MRB_ARGS_ARG(g_date_time_format_REQUIRED_ARGC, g_date_time_format_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_day_of_month_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_day_of_month", mrb_GLib_g_date_time_get_day_of_month, MRB_ARGS_ARG(g_date_time_get_day_of_month_REQUIRED_ARGC, g_date_time_get_day_of_month_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_day_of_week_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_day_of_week", mrb_GLib_g_date_time_get_day_of_week, MRB_ARGS_ARG(g_date_time_get_day_of_week_REQUIRED_ARGC, g_date_time_get_day_of_week_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_day_of_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_day_of_year", mrb_GLib_g_date_time_get_day_of_year, MRB_ARGS_ARG(g_date_time_get_day_of_year_REQUIRED_ARGC, g_date_time_get_day_of_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_hour_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_hour", mrb_GLib_g_date_time_get_hour, MRB_ARGS_ARG(g_date_time_get_hour_REQUIRED_ARGC, g_date_time_get_hour_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_microsecond_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_microsecond", mrb_GLib_g_date_time_get_microsecond, MRB_ARGS_ARG(g_date_time_get_microsecond_REQUIRED_ARGC, g_date_time_get_microsecond_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_minute_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_minute", mrb_GLib_g_date_time_get_minute, MRB_ARGS_ARG(g_date_time_get_minute_REQUIRED_ARGC, g_date_time_get_minute_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_month_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_month", mrb_GLib_g_date_time_get_month, MRB_ARGS_ARG(g_date_time_get_month_REQUIRED_ARGC, g_date_time_get_month_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_second_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_second", mrb_GLib_g_date_time_get_second, MRB_ARGS_ARG(g_date_time_get_second_REQUIRED_ARGC, g_date_time_get_second_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_seconds_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_seconds", mrb_GLib_g_date_time_get_seconds, MRB_ARGS_ARG(g_date_time_get_seconds_REQUIRED_ARGC, g_date_time_get_seconds_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_timezone_abbreviation_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_timezone_abbreviation", mrb_GLib_g_date_time_get_timezone_abbreviation, MRB_ARGS_ARG(g_date_time_get_timezone_abbreviation_REQUIRED_ARGC, g_date_time_get_timezone_abbreviation_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_utc_offset_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_utc_offset", mrb_GLib_g_date_time_get_utc_offset, MRB_ARGS_ARG(g_date_time_get_utc_offset_REQUIRED_ARGC, g_date_time_get_utc_offset_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_week_numbering_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_week_numbering_year", mrb_GLib_g_date_time_get_week_numbering_year, MRB_ARGS_ARG(g_date_time_get_week_numbering_year_REQUIRED_ARGC, g_date_time_get_week_numbering_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_week_of_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_week_of_year", mrb_GLib_g_date_time_get_week_of_year, MRB_ARGS_ARG(g_date_time_get_week_of_year_REQUIRED_ARGC, g_date_time_get_week_of_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_year", mrb_GLib_g_date_time_get_year, MRB_ARGS_ARG(g_date_time_get_year_REQUIRED_ARGC, g_date_time_get_year_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_get_ymd_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_get_ymd", mrb_GLib_g_date_time_get_ymd, MRB_ARGS_ARG(g_date_time_get_ymd_REQUIRED_ARGC, g_date_time_get_ymd_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_hash_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_hash", mrb_GLib_g_date_time_hash, MRB_ARGS_ARG(g_date_time_hash_REQUIRED_ARGC, g_date_time_hash_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_is_daylight_savings_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_is_daylight_savings", mrb_GLib_g_date_time_is_daylight_savings, MRB_ARGS_ARG(g_date_time_is_daylight_savings_REQUIRED_ARGC, g_date_time_is_daylight_savings_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_new", mrb_GLib_g_date_time_new, MRB_ARGS_ARG(g_date_time_new_REQUIRED_ARGC, g_date_time_new_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_new_from_timeval_local_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_new_from_timeval_local", mrb_GLib_g_date_time_new_from_timeval_local, MRB_ARGS_ARG(g_date_time_new_from_timeval_local_REQUIRED_ARGC, g_date_time_new_from_timeval_local_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_new_from_timeval_utc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_new_from_timeval_utc", mrb_GLib_g_date_time_new_from_timeval_utc, MRB_ARGS_ARG(g_date_time_new_from_timeval_utc_REQUIRED_ARGC, g_date_time_new_from_timeval_utc_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_new_from_unix_local_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_new_from_unix_local", mrb_GLib_g_date_time_new_from_unix_local, MRB_ARGS_ARG(g_date_time_new_from_unix_local_REQUIRED_ARGC, g_date_time_new_from_unix_local_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_new_from_unix_utc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_new_from_unix_utc", mrb_GLib_g_date_time_new_from_unix_utc, MRB_ARGS_ARG(g_date_time_new_from_unix_utc_REQUIRED_ARGC, g_date_time_new_from_unix_utc_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_new_local_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_new_local", mrb_GLib_g_date_time_new_local, MRB_ARGS_ARG(g_date_time_new_local_REQUIRED_ARGC, g_date_time_new_local_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_new_now_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_new_now", mrb_GLib_g_date_time_new_now, MRB_ARGS_ARG(g_date_time_new_now_REQUIRED_ARGC, g_date_time_new_now_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_new_now_local_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_new_now_local", mrb_GLib_g_date_time_new_now_local, MRB_ARGS_ARG(g_date_time_new_now_local_REQUIRED_ARGC, g_date_time_new_now_local_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_new_now_utc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_new_now_utc", mrb_GLib_g_date_time_new_now_utc, MRB_ARGS_ARG(g_date_time_new_now_utc_REQUIRED_ARGC, g_date_time_new_now_utc_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_new_utc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_new_utc", mrb_GLib_g_date_time_new_utc, MRB_ARGS_ARG(g_date_time_new_utc_REQUIRED_ARGC, g_date_time_new_utc_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_ref", mrb_GLib_g_date_time_ref, MRB_ARGS_ARG(g_date_time_ref_REQUIRED_ARGC, g_date_time_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_to_local_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_to_local", mrb_GLib_g_date_time_to_local, MRB_ARGS_ARG(g_date_time_to_local_REQUIRED_ARGC, g_date_time_to_local_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_to_timeval_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_to_timeval", mrb_GLib_g_date_time_to_timeval, MRB_ARGS_ARG(g_date_time_to_timeval_REQUIRED_ARGC, g_date_time_to_timeval_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_to_timezone_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_to_timezone", mrb_GLib_g_date_time_to_timezone, MRB_ARGS_ARG(g_date_time_to_timezone_REQUIRED_ARGC, g_date_time_to_timezone_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_to_unix_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_to_unix", mrb_GLib_g_date_time_to_unix, MRB_ARGS_ARG(g_date_time_to_unix_REQUIRED_ARGC, g_date_time_to_unix_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_to_utc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_to_utc", mrb_GLib_g_date_time_to_utc, MRB_ARGS_ARG(g_date_time_to_utc_REQUIRED_ARGC, g_date_time_to_utc_OPTIONAL_ARGC));
#endif
#if BIND_g_date_time_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_time_unref", mrb_GLib_g_date_time_unref, MRB_ARGS_ARG(g_date_time_unref_REQUIRED_ARGC, g_date_time_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_date_to_struct_tm_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_to_struct_tm", mrb_GLib_g_date_to_struct_tm, MRB_ARGS_ARG(g_date_to_struct_tm_REQUIRED_ARGC, g_date_to_struct_tm_OPTIONAL_ARGC));
#endif
#if BIND_g_date_valid_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_valid", mrb_GLib_g_date_valid, MRB_ARGS_ARG(g_date_valid_REQUIRED_ARGC, g_date_valid_OPTIONAL_ARGC));
#endif
#if BIND_g_date_valid_day_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_valid_day", mrb_GLib_g_date_valid_day, MRB_ARGS_ARG(g_date_valid_day_REQUIRED_ARGC, g_date_valid_day_OPTIONAL_ARGC));
#endif
#if BIND_g_date_valid_dmy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_valid_dmy", mrb_GLib_g_date_valid_dmy, MRB_ARGS_ARG(g_date_valid_dmy_REQUIRED_ARGC, g_date_valid_dmy_OPTIONAL_ARGC));
#endif
#if BIND_g_date_valid_julian_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_valid_julian", mrb_GLib_g_date_valid_julian, MRB_ARGS_ARG(g_date_valid_julian_REQUIRED_ARGC, g_date_valid_julian_OPTIONAL_ARGC));
#endif
#if BIND_g_date_valid_month_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_valid_month", mrb_GLib_g_date_valid_month, MRB_ARGS_ARG(g_date_valid_month_REQUIRED_ARGC, g_date_valid_month_OPTIONAL_ARGC));
#endif
#if BIND_g_date_valid_weekday_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_valid_weekday", mrb_GLib_g_date_valid_weekday, MRB_ARGS_ARG(g_date_valid_weekday_REQUIRED_ARGC, g_date_valid_weekday_OPTIONAL_ARGC));
#endif
#if BIND_g_date_valid_year_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_date_valid_year", mrb_GLib_g_date_valid_year, MRB_ARGS_ARG(g_date_valid_year_REQUIRED_ARGC, g_date_valid_year_OPTIONAL_ARGC));
#endif
#if BIND_g_dcgettext_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dcgettext", mrb_GLib_g_dcgettext, MRB_ARGS_ARG(g_dcgettext_REQUIRED_ARGC, g_dcgettext_OPTIONAL_ARGC));
#endif
#if BIND_g_dgettext_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dgettext", mrb_GLib_g_dgettext, MRB_ARGS_ARG(g_dgettext_REQUIRED_ARGC, g_dgettext_OPTIONAL_ARGC));
#endif
#if BIND_g_dir_close_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dir_close", mrb_GLib_g_dir_close, MRB_ARGS_ARG(g_dir_close_REQUIRED_ARGC, g_dir_close_OPTIONAL_ARGC));
#endif
#if BIND_g_dir_make_tmp_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dir_make_tmp", mrb_GLib_g_dir_make_tmp, MRB_ARGS_ARG(g_dir_make_tmp_REQUIRED_ARGC, g_dir_make_tmp_OPTIONAL_ARGC));
#endif
#if BIND_g_dir_open_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dir_open", mrb_GLib_g_dir_open, MRB_ARGS_ARG(g_dir_open_REQUIRED_ARGC, g_dir_open_OPTIONAL_ARGC));
#endif
#if BIND_g_dir_read_name_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dir_read_name", mrb_GLib_g_dir_read_name, MRB_ARGS_ARG(g_dir_read_name_REQUIRED_ARGC, g_dir_read_name_OPTIONAL_ARGC));
#endif
#if BIND_g_dir_rewind_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dir_rewind", mrb_GLib_g_dir_rewind, MRB_ARGS_ARG(g_dir_rewind_REQUIRED_ARGC, g_dir_rewind_OPTIONAL_ARGC));
#endif
#if BIND_g_direct_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_direct_equal", mrb_GLib_g_direct_equal, MRB_ARGS_ARG(g_direct_equal_REQUIRED_ARGC, g_direct_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_direct_hash_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_direct_hash", mrb_GLib_g_direct_hash, MRB_ARGS_ARG(g_direct_hash_REQUIRED_ARGC, g_direct_hash_OPTIONAL_ARGC));
#endif
#if BIND_g_dngettext_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dngettext", mrb_GLib_g_dngettext, MRB_ARGS_ARG(g_dngettext_REQUIRED_ARGC, g_dngettext_OPTIONAL_ARGC));
#endif
#if BIND_g_double_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_double_equal", mrb_GLib_g_double_equal, MRB_ARGS_ARG(g_double_equal_REQUIRED_ARGC, g_double_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_double_hash_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_double_hash", mrb_GLib_g_double_hash, MRB_ARGS_ARG(g_double_hash_REQUIRED_ARGC, g_double_hash_OPTIONAL_ARGC));
#endif
#if BIND_g_dpgettext_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dpgettext", mrb_GLib_g_dpgettext, MRB_ARGS_ARG(g_dpgettext_REQUIRED_ARGC, g_dpgettext_OPTIONAL_ARGC));
#endif
#if BIND_g_dpgettext2_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_dpgettext2", mrb_GLib_g_dpgettext2, MRB_ARGS_ARG(g_dpgettext2_REQUIRED_ARGC, g_dpgettext2_OPTIONAL_ARGC));
#endif
#if BIND_g_environ_getenv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_environ_getenv", mrb_GLib_g_environ_getenv, MRB_ARGS_ARG(g_environ_getenv_REQUIRED_ARGC, g_environ_getenv_OPTIONAL_ARGC));
#endif
#if BIND_g_environ_setenv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_environ_setenv", mrb_GLib_g_environ_setenv, MRB_ARGS_ARG(g_environ_setenv_REQUIRED_ARGC, g_environ_setenv_OPTIONAL_ARGC));
#endif
#if BIND_g_environ_unsetenv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_environ_unsetenv", mrb_GLib_g_environ_unsetenv, MRB_ARGS_ARG(g_environ_unsetenv_REQUIRED_ARGC, g_environ_unsetenv_OPTIONAL_ARGC));
#endif
#if BIND_g_error_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_error_copy", mrb_GLib_g_error_copy, MRB_ARGS_ARG(g_error_copy_REQUIRED_ARGC, g_error_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_error_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_error_free", mrb_GLib_g_error_free, MRB_ARGS_ARG(g_error_free_REQUIRED_ARGC, g_error_free_OPTIONAL_ARGC));
#endif
#if BIND_g_error_matches_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_error_matches", mrb_GLib_g_error_matches, MRB_ARGS_ARG(g_error_matches_REQUIRED_ARGC, g_error_matches_OPTIONAL_ARGC));
#endif
#if BIND_g_error_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_error_new", mrb_GLib_g_error_new, MRB_ARGS_ARG(g_error_new_REQUIRED_ARGC, g_error_new_OPTIONAL_ARGC));
#endif
#if BIND_g_error_new_literal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_error_new_literal", mrb_GLib_g_error_new_literal, MRB_ARGS_ARG(g_error_new_literal_REQUIRED_ARGC, g_error_new_literal_OPTIONAL_ARGC));
#endif
#if BIND_g_error_new_valist_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_error_new_valist", mrb_GLib_g_error_new_valist, MRB_ARGS_ARG(g_error_new_valist_REQUIRED_ARGC, g_error_new_valist_OPTIONAL_ARGC));
#endif
#if BIND_g_file_error_from_errno_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_file_error_from_errno", mrb_GLib_g_file_error_from_errno, MRB_ARGS_ARG(g_file_error_from_errno_REQUIRED_ARGC, g_file_error_from_errno_OPTIONAL_ARGC));
#endif
#if BIND_g_file_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_file_error_quark", mrb_GLib_g_file_error_quark, MRB_ARGS_ARG(g_file_error_quark_REQUIRED_ARGC, g_file_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_file_get_contents_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_file_get_contents", mrb_GLib_g_file_get_contents, MRB_ARGS_ARG(g_file_get_contents_REQUIRED_ARGC, g_file_get_contents_OPTIONAL_ARGC));
#endif
#if BIND_g_file_open_tmp_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_file_open_tmp", mrb_GLib_g_file_open_tmp, MRB_ARGS_ARG(g_file_open_tmp_REQUIRED_ARGC, g_file_open_tmp_OPTIONAL_ARGC));
#endif
#if BIND_g_file_read_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_file_read_link", mrb_GLib_g_file_read_link, MRB_ARGS_ARG(g_file_read_link_REQUIRED_ARGC, g_file_read_link_OPTIONAL_ARGC));
#endif
#if BIND_g_file_set_contents_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_file_set_contents", mrb_GLib_g_file_set_contents, MRB_ARGS_ARG(g_file_set_contents_REQUIRED_ARGC, g_file_set_contents_OPTIONAL_ARGC));
#endif
#if BIND_g_file_test_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_file_test", mrb_GLib_g_file_test, MRB_ARGS_ARG(g_file_test_REQUIRED_ARGC, g_file_test_OPTIONAL_ARGC));
#endif
#if BIND_g_filename_display_basename_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_filename_display_basename", mrb_GLib_g_filename_display_basename, MRB_ARGS_ARG(g_filename_display_basename_REQUIRED_ARGC, g_filename_display_basename_OPTIONAL_ARGC));
#endif
#if BIND_g_filename_display_name_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_filename_display_name", mrb_GLib_g_filename_display_name, MRB_ARGS_ARG(g_filename_display_name_REQUIRED_ARGC, g_filename_display_name_OPTIONAL_ARGC));
#endif
#if BIND_g_filename_from_uri_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_filename_from_uri", mrb_GLib_g_filename_from_uri, MRB_ARGS_ARG(g_filename_from_uri_REQUIRED_ARGC, g_filename_from_uri_OPTIONAL_ARGC));
#endif
#if BIND_g_filename_from_utf8_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_filename_from_utf8", mrb_GLib_g_filename_from_utf8, MRB_ARGS_ARG(g_filename_from_utf8_REQUIRED_ARGC, g_filename_from_utf8_OPTIONAL_ARGC));
#endif
#if BIND_g_filename_to_uri_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_filename_to_uri", mrb_GLib_g_filename_to_uri, MRB_ARGS_ARG(g_filename_to_uri_REQUIRED_ARGC, g_filename_to_uri_OPTIONAL_ARGC));
#endif
#if BIND_g_filename_to_utf8_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_filename_to_utf8", mrb_GLib_g_filename_to_utf8, MRB_ARGS_ARG(g_filename_to_utf8_REQUIRED_ARGC, g_filename_to_utf8_OPTIONAL_ARGC));
#endif
#if BIND_g_find_program_in_path_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_find_program_in_path", mrb_GLib_g_find_program_in_path, MRB_ARGS_ARG(g_find_program_in_path_REQUIRED_ARGC, g_find_program_in_path_OPTIONAL_ARGC));
#endif
#if BIND_g_format_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_format_size", mrb_GLib_g_format_size, MRB_ARGS_ARG(g_format_size_REQUIRED_ARGC, g_format_size_OPTIONAL_ARGC));
#endif
#if BIND_g_format_size_for_display_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_format_size_for_display", mrb_GLib_g_format_size_for_display, MRB_ARGS_ARG(g_format_size_for_display_REQUIRED_ARGC, g_format_size_for_display_OPTIONAL_ARGC));
#endif
#if BIND_g_format_size_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_format_size_full", mrb_GLib_g_format_size_full, MRB_ARGS_ARG(g_format_size_full_REQUIRED_ARGC, g_format_size_full_OPTIONAL_ARGC));
#endif
#if BIND_g_fprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_fprintf", mrb_GLib_g_fprintf, MRB_ARGS_ARG(g_fprintf_REQUIRED_ARGC, g_fprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_free", mrb_GLib_g_free, MRB_ARGS_ARG(g_free_REQUIRED_ARGC, g_free_OPTIONAL_ARGC));
#endif
#if BIND_g_get_application_name_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_application_name", mrb_GLib_g_get_application_name, MRB_ARGS_ARG(g_get_application_name_REQUIRED_ARGC, g_get_application_name_OPTIONAL_ARGC));
#endif
#if BIND_g_get_charset_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_charset", mrb_GLib_g_get_charset, MRB_ARGS_ARG(g_get_charset_REQUIRED_ARGC, g_get_charset_OPTIONAL_ARGC));
#endif
#if BIND_g_get_codeset_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_codeset", mrb_GLib_g_get_codeset, MRB_ARGS_ARG(g_get_codeset_REQUIRED_ARGC, g_get_codeset_OPTIONAL_ARGC));
#endif
#if BIND_g_get_current_dir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_current_dir", mrb_GLib_g_get_current_dir, MRB_ARGS_ARG(g_get_current_dir_REQUIRED_ARGC, g_get_current_dir_OPTIONAL_ARGC));
#endif
#if BIND_g_get_current_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_current_time", mrb_GLib_g_get_current_time, MRB_ARGS_ARG(g_get_current_time_REQUIRED_ARGC, g_get_current_time_OPTIONAL_ARGC));
#endif
#if BIND_g_get_environ_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_environ", mrb_GLib_g_get_environ, MRB_ARGS_ARG(g_get_environ_REQUIRED_ARGC, g_get_environ_OPTIONAL_ARGC));
#endif
#if BIND_g_get_filename_charsets_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_filename_charsets", mrb_GLib_g_get_filename_charsets, MRB_ARGS_ARG(g_get_filename_charsets_REQUIRED_ARGC, g_get_filename_charsets_OPTIONAL_ARGC));
#endif
#if BIND_g_get_home_dir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_home_dir", mrb_GLib_g_get_home_dir, MRB_ARGS_ARG(g_get_home_dir_REQUIRED_ARGC, g_get_home_dir_OPTIONAL_ARGC));
#endif
#if BIND_g_get_host_name_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_host_name", mrb_GLib_g_get_host_name, MRB_ARGS_ARG(g_get_host_name_REQUIRED_ARGC, g_get_host_name_OPTIONAL_ARGC));
#endif
#if BIND_g_get_language_names_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_language_names", mrb_GLib_g_get_language_names, MRB_ARGS_ARG(g_get_language_names_REQUIRED_ARGC, g_get_language_names_OPTIONAL_ARGC));
#endif
#if BIND_g_get_locale_variants_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_locale_variants", mrb_GLib_g_get_locale_variants, MRB_ARGS_ARG(g_get_locale_variants_REQUIRED_ARGC, g_get_locale_variants_OPTIONAL_ARGC));
#endif
#if BIND_g_get_monotonic_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_monotonic_time", mrb_GLib_g_get_monotonic_time, MRB_ARGS_ARG(g_get_monotonic_time_REQUIRED_ARGC, g_get_monotonic_time_OPTIONAL_ARGC));
#endif
#if BIND_g_get_num_processors_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_num_processors", mrb_GLib_g_get_num_processors, MRB_ARGS_ARG(g_get_num_processors_REQUIRED_ARGC, g_get_num_processors_OPTIONAL_ARGC));
#endif
#if BIND_g_get_prgname_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_prgname", mrb_GLib_g_get_prgname, MRB_ARGS_ARG(g_get_prgname_REQUIRED_ARGC, g_get_prgname_OPTIONAL_ARGC));
#endif
#if BIND_g_get_real_name_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_real_name", mrb_GLib_g_get_real_name, MRB_ARGS_ARG(g_get_real_name_REQUIRED_ARGC, g_get_real_name_OPTIONAL_ARGC));
#endif
#if BIND_g_get_real_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_real_time", mrb_GLib_g_get_real_time, MRB_ARGS_ARG(g_get_real_time_REQUIRED_ARGC, g_get_real_time_OPTIONAL_ARGC));
#endif
#if BIND_g_get_system_config_dirs_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_system_config_dirs", mrb_GLib_g_get_system_config_dirs, MRB_ARGS_ARG(g_get_system_config_dirs_REQUIRED_ARGC, g_get_system_config_dirs_OPTIONAL_ARGC));
#endif
#if BIND_g_get_system_data_dirs_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_system_data_dirs", mrb_GLib_g_get_system_data_dirs, MRB_ARGS_ARG(g_get_system_data_dirs_REQUIRED_ARGC, g_get_system_data_dirs_OPTIONAL_ARGC));
#endif
#if BIND_g_get_tmp_dir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_tmp_dir", mrb_GLib_g_get_tmp_dir, MRB_ARGS_ARG(g_get_tmp_dir_REQUIRED_ARGC, g_get_tmp_dir_OPTIONAL_ARGC));
#endif
#if BIND_g_get_user_cache_dir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_user_cache_dir", mrb_GLib_g_get_user_cache_dir, MRB_ARGS_ARG(g_get_user_cache_dir_REQUIRED_ARGC, g_get_user_cache_dir_OPTIONAL_ARGC));
#endif
#if BIND_g_get_user_config_dir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_user_config_dir", mrb_GLib_g_get_user_config_dir, MRB_ARGS_ARG(g_get_user_config_dir_REQUIRED_ARGC, g_get_user_config_dir_OPTIONAL_ARGC));
#endif
#if BIND_g_get_user_data_dir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_user_data_dir", mrb_GLib_g_get_user_data_dir, MRB_ARGS_ARG(g_get_user_data_dir_REQUIRED_ARGC, g_get_user_data_dir_OPTIONAL_ARGC));
#endif
#if BIND_g_get_user_name_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_user_name", mrb_GLib_g_get_user_name, MRB_ARGS_ARG(g_get_user_name_REQUIRED_ARGC, g_get_user_name_OPTIONAL_ARGC));
#endif
#if BIND_g_get_user_runtime_dir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_user_runtime_dir", mrb_GLib_g_get_user_runtime_dir, MRB_ARGS_ARG(g_get_user_runtime_dir_REQUIRED_ARGC, g_get_user_runtime_dir_OPTIONAL_ARGC));
#endif
#if BIND_g_get_user_special_dir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_get_user_special_dir", mrb_GLib_g_get_user_special_dir, MRB_ARGS_ARG(g_get_user_special_dir_REQUIRED_ARGC, g_get_user_special_dir_OPTIONAL_ARGC));
#endif
#if BIND_g_getenv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_getenv", mrb_GLib_g_getenv, MRB_ARGS_ARG(g_getenv_REQUIRED_ARGC, g_getenv_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_add", mrb_GLib_g_hash_table_add, MRB_ARGS_ARG(g_hash_table_add_REQUIRED_ARGC, g_hash_table_add_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_contains_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_contains", mrb_GLib_g_hash_table_contains, MRB_ARGS_ARG(g_hash_table_contains_REQUIRED_ARGC, g_hash_table_contains_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_destroy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_destroy", mrb_GLib_g_hash_table_destroy, MRB_ARGS_ARG(g_hash_table_destroy_REQUIRED_ARGC, g_hash_table_destroy_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_find_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_find", mrb_GLib_g_hash_table_find, MRB_ARGS_ARG(g_hash_table_find_REQUIRED_ARGC, g_hash_table_find_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_foreach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_foreach", mrb_GLib_g_hash_table_foreach, MRB_ARGS_ARG(g_hash_table_foreach_REQUIRED_ARGC, g_hash_table_foreach_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_foreach_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_foreach_remove", mrb_GLib_g_hash_table_foreach_remove, MRB_ARGS_ARG(g_hash_table_foreach_remove_REQUIRED_ARGC, g_hash_table_foreach_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_foreach_steal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_foreach_steal", mrb_GLib_g_hash_table_foreach_steal, MRB_ARGS_ARG(g_hash_table_foreach_steal_REQUIRED_ARGC, g_hash_table_foreach_steal_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_get_keys_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_get_keys", mrb_GLib_g_hash_table_get_keys, MRB_ARGS_ARG(g_hash_table_get_keys_REQUIRED_ARGC, g_hash_table_get_keys_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_get_keys_as_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_get_keys_as_array", mrb_GLib_g_hash_table_get_keys_as_array, MRB_ARGS_ARG(g_hash_table_get_keys_as_array_REQUIRED_ARGC, g_hash_table_get_keys_as_array_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_get_values_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_get_values", mrb_GLib_g_hash_table_get_values, MRB_ARGS_ARG(g_hash_table_get_values_REQUIRED_ARGC, g_hash_table_get_values_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_insert_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_insert", mrb_GLib_g_hash_table_insert, MRB_ARGS_ARG(g_hash_table_insert_REQUIRED_ARGC, g_hash_table_insert_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_iter_get_hash_table_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_iter_get_hash_table", mrb_GLib_g_hash_table_iter_get_hash_table, MRB_ARGS_ARG(g_hash_table_iter_get_hash_table_REQUIRED_ARGC, g_hash_table_iter_get_hash_table_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_iter_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_iter_init", mrb_GLib_g_hash_table_iter_init, MRB_ARGS_ARG(g_hash_table_iter_init_REQUIRED_ARGC, g_hash_table_iter_init_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_iter_next_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_iter_next", mrb_GLib_g_hash_table_iter_next, MRB_ARGS_ARG(g_hash_table_iter_next_REQUIRED_ARGC, g_hash_table_iter_next_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_iter_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_iter_remove", mrb_GLib_g_hash_table_iter_remove, MRB_ARGS_ARG(g_hash_table_iter_remove_REQUIRED_ARGC, g_hash_table_iter_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_iter_replace_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_iter_replace", mrb_GLib_g_hash_table_iter_replace, MRB_ARGS_ARG(g_hash_table_iter_replace_REQUIRED_ARGC, g_hash_table_iter_replace_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_iter_steal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_iter_steal", mrb_GLib_g_hash_table_iter_steal, MRB_ARGS_ARG(g_hash_table_iter_steal_REQUIRED_ARGC, g_hash_table_iter_steal_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_lookup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_lookup", mrb_GLib_g_hash_table_lookup, MRB_ARGS_ARG(g_hash_table_lookup_REQUIRED_ARGC, g_hash_table_lookup_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_lookup_extended_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_lookup_extended", mrb_GLib_g_hash_table_lookup_extended, MRB_ARGS_ARG(g_hash_table_lookup_extended_REQUIRED_ARGC, g_hash_table_lookup_extended_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_new", mrb_GLib_g_hash_table_new, MRB_ARGS_ARG(g_hash_table_new_REQUIRED_ARGC, g_hash_table_new_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_new_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_new_full", mrb_GLib_g_hash_table_new_full, MRB_ARGS_ARG(g_hash_table_new_full_REQUIRED_ARGC, g_hash_table_new_full_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_ref", mrb_GLib_g_hash_table_ref, MRB_ARGS_ARG(g_hash_table_ref_REQUIRED_ARGC, g_hash_table_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_remove", mrb_GLib_g_hash_table_remove, MRB_ARGS_ARG(g_hash_table_remove_REQUIRED_ARGC, g_hash_table_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_remove_all_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_remove_all", mrb_GLib_g_hash_table_remove_all, MRB_ARGS_ARG(g_hash_table_remove_all_REQUIRED_ARGC, g_hash_table_remove_all_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_replace_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_replace", mrb_GLib_g_hash_table_replace, MRB_ARGS_ARG(g_hash_table_replace_REQUIRED_ARGC, g_hash_table_replace_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_size", mrb_GLib_g_hash_table_size, MRB_ARGS_ARG(g_hash_table_size_REQUIRED_ARGC, g_hash_table_size_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_steal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_steal", mrb_GLib_g_hash_table_steal, MRB_ARGS_ARG(g_hash_table_steal_REQUIRED_ARGC, g_hash_table_steal_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_steal_all_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_steal_all", mrb_GLib_g_hash_table_steal_all, MRB_ARGS_ARG(g_hash_table_steal_all_REQUIRED_ARGC, g_hash_table_steal_all_OPTIONAL_ARGC));
#endif
#if BIND_g_hash_table_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hash_table_unref", mrb_GLib_g_hash_table_unref, MRB_ARGS_ARG(g_hash_table_unref_REQUIRED_ARGC, g_hash_table_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_hmac_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hmac_copy", mrb_GLib_g_hmac_copy, MRB_ARGS_ARG(g_hmac_copy_REQUIRED_ARGC, g_hmac_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_hmac_get_digest_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hmac_get_digest", mrb_GLib_g_hmac_get_digest, MRB_ARGS_ARG(g_hmac_get_digest_REQUIRED_ARGC, g_hmac_get_digest_OPTIONAL_ARGC));
#endif
#if BIND_g_hmac_get_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hmac_get_string", mrb_GLib_g_hmac_get_string, MRB_ARGS_ARG(g_hmac_get_string_REQUIRED_ARGC, g_hmac_get_string_OPTIONAL_ARGC));
#endif
#if BIND_g_hmac_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hmac_new", mrb_GLib_g_hmac_new, MRB_ARGS_ARG(g_hmac_new_REQUIRED_ARGC, g_hmac_new_OPTIONAL_ARGC));
#endif
#if BIND_g_hmac_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hmac_ref", mrb_GLib_g_hmac_ref, MRB_ARGS_ARG(g_hmac_ref_REQUIRED_ARGC, g_hmac_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_hmac_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hmac_unref", mrb_GLib_g_hmac_unref, MRB_ARGS_ARG(g_hmac_unref_REQUIRED_ARGC, g_hmac_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_hmac_update_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hmac_update", mrb_GLib_g_hmac_update, MRB_ARGS_ARG(g_hmac_update_REQUIRED_ARGC, g_hmac_update_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_alloc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_alloc", mrb_GLib_g_hook_alloc, MRB_ARGS_ARG(g_hook_alloc_REQUIRED_ARGC, g_hook_alloc_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_compare_ids_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_compare_ids", mrb_GLib_g_hook_compare_ids, MRB_ARGS_ARG(g_hook_compare_ids_REQUIRED_ARGC, g_hook_compare_ids_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_destroy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_destroy", mrb_GLib_g_hook_destroy, MRB_ARGS_ARG(g_hook_destroy_REQUIRED_ARGC, g_hook_destroy_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_destroy_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_destroy_link", mrb_GLib_g_hook_destroy_link, MRB_ARGS_ARG(g_hook_destroy_link_REQUIRED_ARGC, g_hook_destroy_link_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_find_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_find", mrb_GLib_g_hook_find, MRB_ARGS_ARG(g_hook_find_REQUIRED_ARGC, g_hook_find_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_find_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_find_data", mrb_GLib_g_hook_find_data, MRB_ARGS_ARG(g_hook_find_data_REQUIRED_ARGC, g_hook_find_data_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_find_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_find_func", mrb_GLib_g_hook_find_func, MRB_ARGS_ARG(g_hook_find_func_REQUIRED_ARGC, g_hook_find_func_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_find_func_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_find_func_data", mrb_GLib_g_hook_find_func_data, MRB_ARGS_ARG(g_hook_find_func_data_REQUIRED_ARGC, g_hook_find_func_data_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_first_valid_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_first_valid", mrb_GLib_g_hook_first_valid, MRB_ARGS_ARG(g_hook_first_valid_REQUIRED_ARGC, g_hook_first_valid_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_free", mrb_GLib_g_hook_free, MRB_ARGS_ARG(g_hook_free_REQUIRED_ARGC, g_hook_free_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_get_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_get", mrb_GLib_g_hook_get, MRB_ARGS_ARG(g_hook_get_REQUIRED_ARGC, g_hook_get_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_insert_before_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_insert_before", mrb_GLib_g_hook_insert_before, MRB_ARGS_ARG(g_hook_insert_before_REQUIRED_ARGC, g_hook_insert_before_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_insert_sorted_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_insert_sorted", mrb_GLib_g_hook_insert_sorted, MRB_ARGS_ARG(g_hook_insert_sorted_REQUIRED_ARGC, g_hook_insert_sorted_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_list_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_list_clear", mrb_GLib_g_hook_list_clear, MRB_ARGS_ARG(g_hook_list_clear_REQUIRED_ARGC, g_hook_list_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_list_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_list_init", mrb_GLib_g_hook_list_init, MRB_ARGS_ARG(g_hook_list_init_REQUIRED_ARGC, g_hook_list_init_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_list_invoke_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_list_invoke", mrb_GLib_g_hook_list_invoke, MRB_ARGS_ARG(g_hook_list_invoke_REQUIRED_ARGC, g_hook_list_invoke_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_list_invoke_check_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_list_invoke_check", mrb_GLib_g_hook_list_invoke_check, MRB_ARGS_ARG(g_hook_list_invoke_check_REQUIRED_ARGC, g_hook_list_invoke_check_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_list_marshal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_list_marshal", mrb_GLib_g_hook_list_marshal, MRB_ARGS_ARG(g_hook_list_marshal_REQUIRED_ARGC, g_hook_list_marshal_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_list_marshal_check_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_list_marshal_check", mrb_GLib_g_hook_list_marshal_check, MRB_ARGS_ARG(g_hook_list_marshal_check_REQUIRED_ARGC, g_hook_list_marshal_check_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_next_valid_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_next_valid", mrb_GLib_g_hook_next_valid, MRB_ARGS_ARG(g_hook_next_valid_REQUIRED_ARGC, g_hook_next_valid_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_prepend_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_prepend", mrb_GLib_g_hook_prepend, MRB_ARGS_ARG(g_hook_prepend_REQUIRED_ARGC, g_hook_prepend_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_ref", mrb_GLib_g_hook_ref, MRB_ARGS_ARG(g_hook_ref_REQUIRED_ARGC, g_hook_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_hook_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hook_unref", mrb_GLib_g_hook_unref, MRB_ARGS_ARG(g_hook_unref_REQUIRED_ARGC, g_hook_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_hostname_is_ascii_encoded_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hostname_is_ascii_encoded", mrb_GLib_g_hostname_is_ascii_encoded, MRB_ARGS_ARG(g_hostname_is_ascii_encoded_REQUIRED_ARGC, g_hostname_is_ascii_encoded_OPTIONAL_ARGC));
#endif
#if BIND_g_hostname_is_ip_address_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hostname_is_ip_address", mrb_GLib_g_hostname_is_ip_address, MRB_ARGS_ARG(g_hostname_is_ip_address_REQUIRED_ARGC, g_hostname_is_ip_address_OPTIONAL_ARGC));
#endif
#if BIND_g_hostname_is_non_ascii_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hostname_is_non_ascii", mrb_GLib_g_hostname_is_non_ascii, MRB_ARGS_ARG(g_hostname_is_non_ascii_REQUIRED_ARGC, g_hostname_is_non_ascii_OPTIONAL_ARGC));
#endif
#if BIND_g_hostname_to_ascii_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hostname_to_ascii", mrb_GLib_g_hostname_to_ascii, MRB_ARGS_ARG(g_hostname_to_ascii_REQUIRED_ARGC, g_hostname_to_ascii_OPTIONAL_ARGC));
#endif
#if BIND_g_hostname_to_unicode_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_hostname_to_unicode", mrb_GLib_g_hostname_to_unicode, MRB_ARGS_ARG(g_hostname_to_unicode_REQUIRED_ARGC, g_hostname_to_unicode_OPTIONAL_ARGC));
#endif
#if BIND_g_iconv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_iconv", mrb_GLib_g_iconv, MRB_ARGS_ARG(g_iconv_REQUIRED_ARGC, g_iconv_OPTIONAL_ARGC));
#endif
#if BIND_g_iconv_close_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_iconv_close", mrb_GLib_g_iconv_close, MRB_ARGS_ARG(g_iconv_close_REQUIRED_ARGC, g_iconv_close_OPTIONAL_ARGC));
#endif
#if BIND_g_iconv_open_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_iconv_open", mrb_GLib_g_iconv_open, MRB_ARGS_ARG(g_iconv_open_REQUIRED_ARGC, g_iconv_open_OPTIONAL_ARGC));
#endif
#if BIND_g_idle_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_idle_add", mrb_GLib_g_idle_add, MRB_ARGS_ARG(g_idle_add_REQUIRED_ARGC, g_idle_add_OPTIONAL_ARGC));
#endif
#if BIND_g_idle_add_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_idle_add_full", mrb_GLib_g_idle_add_full, MRB_ARGS_ARG(g_idle_add_full_REQUIRED_ARGC, g_idle_add_full_OPTIONAL_ARGC));
#endif
#if BIND_g_idle_remove_by_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_idle_remove_by_data", mrb_GLib_g_idle_remove_by_data, MRB_ARGS_ARG(g_idle_remove_by_data_REQUIRED_ARGC, g_idle_remove_by_data_OPTIONAL_ARGC));
#endif
#if BIND_g_idle_source_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_idle_source_new", mrb_GLib_g_idle_source_new, MRB_ARGS_ARG(g_idle_source_new_REQUIRED_ARGC, g_idle_source_new_OPTIONAL_ARGC));
#endif
#if BIND_g_int64_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_int64_equal", mrb_GLib_g_int64_equal, MRB_ARGS_ARG(g_int64_equal_REQUIRED_ARGC, g_int64_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_int64_hash_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_int64_hash", mrb_GLib_g_int64_hash, MRB_ARGS_ARG(g_int64_hash_REQUIRED_ARGC, g_int64_hash_OPTIONAL_ARGC));
#endif
#if BIND_g_int_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_int_equal", mrb_GLib_g_int_equal, MRB_ARGS_ARG(g_int_equal_REQUIRED_ARGC, g_int_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_int_hash_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_int_hash", mrb_GLib_g_int_hash, MRB_ARGS_ARG(g_int_hash_REQUIRED_ARGC, g_int_hash_OPTIONAL_ARGC));
#endif
#if BIND_g_intern_static_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_intern_static_string", mrb_GLib_g_intern_static_string, MRB_ARGS_ARG(g_intern_static_string_REQUIRED_ARGC, g_intern_static_string_OPTIONAL_ARGC));
#endif
#if BIND_g_intern_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_intern_string", mrb_GLib_g_intern_string, MRB_ARGS_ARG(g_intern_string_REQUIRED_ARGC, g_intern_string_OPTIONAL_ARGC));
#endif
#if BIND_g_io_add_watch_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_add_watch", mrb_GLib_g_io_add_watch, MRB_ARGS_ARG(g_io_add_watch_REQUIRED_ARGC, g_io_add_watch_OPTIONAL_ARGC));
#endif
#if BIND_g_io_add_watch_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_add_watch_full", mrb_GLib_g_io_add_watch_full, MRB_ARGS_ARG(g_io_add_watch_full_REQUIRED_ARGC, g_io_add_watch_full_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_close_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_close", mrb_GLib_g_io_channel_close, MRB_ARGS_ARG(g_io_channel_close_REQUIRED_ARGC, g_io_channel_close_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_error_from_errno_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_error_from_errno", mrb_GLib_g_io_channel_error_from_errno, MRB_ARGS_ARG(g_io_channel_error_from_errno_REQUIRED_ARGC, g_io_channel_error_from_errno_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_error_quark", mrb_GLib_g_io_channel_error_quark, MRB_ARGS_ARG(g_io_channel_error_quark_REQUIRED_ARGC, g_io_channel_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_flush_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_flush", mrb_GLib_g_io_channel_flush, MRB_ARGS_ARG(g_io_channel_flush_REQUIRED_ARGC, g_io_channel_flush_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_get_buffer_condition_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_get_buffer_condition", mrb_GLib_g_io_channel_get_buffer_condition, MRB_ARGS_ARG(g_io_channel_get_buffer_condition_REQUIRED_ARGC, g_io_channel_get_buffer_condition_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_get_buffer_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_get_buffer_size", mrb_GLib_g_io_channel_get_buffer_size, MRB_ARGS_ARG(g_io_channel_get_buffer_size_REQUIRED_ARGC, g_io_channel_get_buffer_size_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_get_buffered_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_get_buffered", mrb_GLib_g_io_channel_get_buffered, MRB_ARGS_ARG(g_io_channel_get_buffered_REQUIRED_ARGC, g_io_channel_get_buffered_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_get_close_on_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_get_close_on_unref", mrb_GLib_g_io_channel_get_close_on_unref, MRB_ARGS_ARG(g_io_channel_get_close_on_unref_REQUIRED_ARGC, g_io_channel_get_close_on_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_get_encoding_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_get_encoding", mrb_GLib_g_io_channel_get_encoding, MRB_ARGS_ARG(g_io_channel_get_encoding_REQUIRED_ARGC, g_io_channel_get_encoding_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_get_flags_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_get_flags", mrb_GLib_g_io_channel_get_flags, MRB_ARGS_ARG(g_io_channel_get_flags_REQUIRED_ARGC, g_io_channel_get_flags_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_get_line_term_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_get_line_term", mrb_GLib_g_io_channel_get_line_term, MRB_ARGS_ARG(g_io_channel_get_line_term_REQUIRED_ARGC, g_io_channel_get_line_term_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_init", mrb_GLib_g_io_channel_init, MRB_ARGS_ARG(g_io_channel_init_REQUIRED_ARGC, g_io_channel_init_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_new_file_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_new_file", mrb_GLib_g_io_channel_new_file, MRB_ARGS_ARG(g_io_channel_new_file_REQUIRED_ARGC, g_io_channel_new_file_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_read_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_read", mrb_GLib_g_io_channel_read, MRB_ARGS_ARG(g_io_channel_read_REQUIRED_ARGC, g_io_channel_read_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_read_chars_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_read_chars", mrb_GLib_g_io_channel_read_chars, MRB_ARGS_ARG(g_io_channel_read_chars_REQUIRED_ARGC, g_io_channel_read_chars_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_read_line_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_read_line", mrb_GLib_g_io_channel_read_line, MRB_ARGS_ARG(g_io_channel_read_line_REQUIRED_ARGC, g_io_channel_read_line_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_read_line_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_read_line_string", mrb_GLib_g_io_channel_read_line_string, MRB_ARGS_ARG(g_io_channel_read_line_string_REQUIRED_ARGC, g_io_channel_read_line_string_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_read_to_end_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_read_to_end", mrb_GLib_g_io_channel_read_to_end, MRB_ARGS_ARG(g_io_channel_read_to_end_REQUIRED_ARGC, g_io_channel_read_to_end_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_read_unichar_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_read_unichar", mrb_GLib_g_io_channel_read_unichar, MRB_ARGS_ARG(g_io_channel_read_unichar_REQUIRED_ARGC, g_io_channel_read_unichar_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_ref", mrb_GLib_g_io_channel_ref, MRB_ARGS_ARG(g_io_channel_ref_REQUIRED_ARGC, g_io_channel_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_seek_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_seek", mrb_GLib_g_io_channel_seek, MRB_ARGS_ARG(g_io_channel_seek_REQUIRED_ARGC, g_io_channel_seek_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_seek_position_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_seek_position", mrb_GLib_g_io_channel_seek_position, MRB_ARGS_ARG(g_io_channel_seek_position_REQUIRED_ARGC, g_io_channel_seek_position_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_set_buffer_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_set_buffer_size", mrb_GLib_g_io_channel_set_buffer_size, MRB_ARGS_ARG(g_io_channel_set_buffer_size_REQUIRED_ARGC, g_io_channel_set_buffer_size_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_set_buffered_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_set_buffered", mrb_GLib_g_io_channel_set_buffered, MRB_ARGS_ARG(g_io_channel_set_buffered_REQUIRED_ARGC, g_io_channel_set_buffered_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_set_close_on_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_set_close_on_unref", mrb_GLib_g_io_channel_set_close_on_unref, MRB_ARGS_ARG(g_io_channel_set_close_on_unref_REQUIRED_ARGC, g_io_channel_set_close_on_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_set_encoding_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_set_encoding", mrb_GLib_g_io_channel_set_encoding, MRB_ARGS_ARG(g_io_channel_set_encoding_REQUIRED_ARGC, g_io_channel_set_encoding_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_set_flags_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_set_flags", mrb_GLib_g_io_channel_set_flags, MRB_ARGS_ARG(g_io_channel_set_flags_REQUIRED_ARGC, g_io_channel_set_flags_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_set_line_term_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_set_line_term", mrb_GLib_g_io_channel_set_line_term, MRB_ARGS_ARG(g_io_channel_set_line_term_REQUIRED_ARGC, g_io_channel_set_line_term_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_shutdown_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_shutdown", mrb_GLib_g_io_channel_shutdown, MRB_ARGS_ARG(g_io_channel_shutdown_REQUIRED_ARGC, g_io_channel_shutdown_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_unix_get_fd_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_unix_get_fd", mrb_GLib_g_io_channel_unix_get_fd, MRB_ARGS_ARG(g_io_channel_unix_get_fd_REQUIRED_ARGC, g_io_channel_unix_get_fd_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_unix_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_unix_new", mrb_GLib_g_io_channel_unix_new, MRB_ARGS_ARG(g_io_channel_unix_new_REQUIRED_ARGC, g_io_channel_unix_new_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_unref", mrb_GLib_g_io_channel_unref, MRB_ARGS_ARG(g_io_channel_unref_REQUIRED_ARGC, g_io_channel_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_write_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_write", mrb_GLib_g_io_channel_write, MRB_ARGS_ARG(g_io_channel_write_REQUIRED_ARGC, g_io_channel_write_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_write_chars_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_write_chars", mrb_GLib_g_io_channel_write_chars, MRB_ARGS_ARG(g_io_channel_write_chars_REQUIRED_ARGC, g_io_channel_write_chars_OPTIONAL_ARGC));
#endif
#if BIND_g_io_channel_write_unichar_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_channel_write_unichar", mrb_GLib_g_io_channel_write_unichar, MRB_ARGS_ARG(g_io_channel_write_unichar_REQUIRED_ARGC, g_io_channel_write_unichar_OPTIONAL_ARGC));
#endif
#if BIND_g_io_create_watch_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_io_create_watch", mrb_GLib_g_io_create_watch, MRB_ARGS_ARG(g_io_create_watch_REQUIRED_ARGC, g_io_create_watch_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_error_quark", mrb_GLib_g_key_file_error_quark, MRB_ARGS_ARG(g_key_file_error_quark_REQUIRED_ARGC, g_key_file_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_free", mrb_GLib_g_key_file_free, MRB_ARGS_ARG(g_key_file_free_REQUIRED_ARGC, g_key_file_free_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_boolean_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_boolean", mrb_GLib_g_key_file_get_boolean, MRB_ARGS_ARG(g_key_file_get_boolean_REQUIRED_ARGC, g_key_file_get_boolean_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_boolean_list_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_boolean_list", mrb_GLib_g_key_file_get_boolean_list, MRB_ARGS_ARG(g_key_file_get_boolean_list_REQUIRED_ARGC, g_key_file_get_boolean_list_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_comment_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_comment", mrb_GLib_g_key_file_get_comment, MRB_ARGS_ARG(g_key_file_get_comment_REQUIRED_ARGC, g_key_file_get_comment_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_double_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_double", mrb_GLib_g_key_file_get_double, MRB_ARGS_ARG(g_key_file_get_double_REQUIRED_ARGC, g_key_file_get_double_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_double_list_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_double_list", mrb_GLib_g_key_file_get_double_list, MRB_ARGS_ARG(g_key_file_get_double_list_REQUIRED_ARGC, g_key_file_get_double_list_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_groups_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_groups", mrb_GLib_g_key_file_get_groups, MRB_ARGS_ARG(g_key_file_get_groups_REQUIRED_ARGC, g_key_file_get_groups_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_int64_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_int64", mrb_GLib_g_key_file_get_int64, MRB_ARGS_ARG(g_key_file_get_int64_REQUIRED_ARGC, g_key_file_get_int64_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_integer_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_integer", mrb_GLib_g_key_file_get_integer, MRB_ARGS_ARG(g_key_file_get_integer_REQUIRED_ARGC, g_key_file_get_integer_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_integer_list_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_integer_list", mrb_GLib_g_key_file_get_integer_list, MRB_ARGS_ARG(g_key_file_get_integer_list_REQUIRED_ARGC, g_key_file_get_integer_list_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_keys_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_keys", mrb_GLib_g_key_file_get_keys, MRB_ARGS_ARG(g_key_file_get_keys_REQUIRED_ARGC, g_key_file_get_keys_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_locale_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_locale_string", mrb_GLib_g_key_file_get_locale_string, MRB_ARGS_ARG(g_key_file_get_locale_string_REQUIRED_ARGC, g_key_file_get_locale_string_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_locale_string_list_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_locale_string_list", mrb_GLib_g_key_file_get_locale_string_list, MRB_ARGS_ARG(g_key_file_get_locale_string_list_REQUIRED_ARGC, g_key_file_get_locale_string_list_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_start_group_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_start_group", mrb_GLib_g_key_file_get_start_group, MRB_ARGS_ARG(g_key_file_get_start_group_REQUIRED_ARGC, g_key_file_get_start_group_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_string", mrb_GLib_g_key_file_get_string, MRB_ARGS_ARG(g_key_file_get_string_REQUIRED_ARGC, g_key_file_get_string_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_string_list_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_string_list", mrb_GLib_g_key_file_get_string_list, MRB_ARGS_ARG(g_key_file_get_string_list_REQUIRED_ARGC, g_key_file_get_string_list_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_uint64_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_uint64", mrb_GLib_g_key_file_get_uint64, MRB_ARGS_ARG(g_key_file_get_uint64_REQUIRED_ARGC, g_key_file_get_uint64_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_get_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_get_value", mrb_GLib_g_key_file_get_value, MRB_ARGS_ARG(g_key_file_get_value_REQUIRED_ARGC, g_key_file_get_value_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_has_group_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_has_group", mrb_GLib_g_key_file_has_group, MRB_ARGS_ARG(g_key_file_has_group_REQUIRED_ARGC, g_key_file_has_group_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_has_key_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_has_key", mrb_GLib_g_key_file_has_key, MRB_ARGS_ARG(g_key_file_has_key_REQUIRED_ARGC, g_key_file_has_key_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_load_from_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_load_from_data", mrb_GLib_g_key_file_load_from_data, MRB_ARGS_ARG(g_key_file_load_from_data_REQUIRED_ARGC, g_key_file_load_from_data_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_load_from_data_dirs_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_load_from_data_dirs", mrb_GLib_g_key_file_load_from_data_dirs, MRB_ARGS_ARG(g_key_file_load_from_data_dirs_REQUIRED_ARGC, g_key_file_load_from_data_dirs_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_load_from_dirs_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_load_from_dirs", mrb_GLib_g_key_file_load_from_dirs, MRB_ARGS_ARG(g_key_file_load_from_dirs_REQUIRED_ARGC, g_key_file_load_from_dirs_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_load_from_file_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_load_from_file", mrb_GLib_g_key_file_load_from_file, MRB_ARGS_ARG(g_key_file_load_from_file_REQUIRED_ARGC, g_key_file_load_from_file_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_new", mrb_GLib_g_key_file_new, MRB_ARGS_ARG(g_key_file_new_REQUIRED_ARGC, g_key_file_new_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_ref", mrb_GLib_g_key_file_ref, MRB_ARGS_ARG(g_key_file_ref_REQUIRED_ARGC, g_key_file_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_remove_comment_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_remove_comment", mrb_GLib_g_key_file_remove_comment, MRB_ARGS_ARG(g_key_file_remove_comment_REQUIRED_ARGC, g_key_file_remove_comment_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_remove_group_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_remove_group", mrb_GLib_g_key_file_remove_group, MRB_ARGS_ARG(g_key_file_remove_group_REQUIRED_ARGC, g_key_file_remove_group_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_remove_key_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_remove_key", mrb_GLib_g_key_file_remove_key, MRB_ARGS_ARG(g_key_file_remove_key_REQUIRED_ARGC, g_key_file_remove_key_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_save_to_file_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_save_to_file", mrb_GLib_g_key_file_save_to_file, MRB_ARGS_ARG(g_key_file_save_to_file_REQUIRED_ARGC, g_key_file_save_to_file_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_boolean_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_boolean", mrb_GLib_g_key_file_set_boolean, MRB_ARGS_ARG(g_key_file_set_boolean_REQUIRED_ARGC, g_key_file_set_boolean_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_boolean_list_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_boolean_list", mrb_GLib_g_key_file_set_boolean_list, MRB_ARGS_ARG(g_key_file_set_boolean_list_REQUIRED_ARGC, g_key_file_set_boolean_list_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_comment_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_comment", mrb_GLib_g_key_file_set_comment, MRB_ARGS_ARG(g_key_file_set_comment_REQUIRED_ARGC, g_key_file_set_comment_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_double_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_double", mrb_GLib_g_key_file_set_double, MRB_ARGS_ARG(g_key_file_set_double_REQUIRED_ARGC, g_key_file_set_double_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_double_list_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_double_list", mrb_GLib_g_key_file_set_double_list, MRB_ARGS_ARG(g_key_file_set_double_list_REQUIRED_ARGC, g_key_file_set_double_list_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_int64_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_int64", mrb_GLib_g_key_file_set_int64, MRB_ARGS_ARG(g_key_file_set_int64_REQUIRED_ARGC, g_key_file_set_int64_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_integer_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_integer", mrb_GLib_g_key_file_set_integer, MRB_ARGS_ARG(g_key_file_set_integer_REQUIRED_ARGC, g_key_file_set_integer_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_integer_list_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_integer_list", mrb_GLib_g_key_file_set_integer_list, MRB_ARGS_ARG(g_key_file_set_integer_list_REQUIRED_ARGC, g_key_file_set_integer_list_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_list_separator_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_list_separator", mrb_GLib_g_key_file_set_list_separator, MRB_ARGS_ARG(g_key_file_set_list_separator_REQUIRED_ARGC, g_key_file_set_list_separator_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_locale_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_locale_string", mrb_GLib_g_key_file_set_locale_string, MRB_ARGS_ARG(g_key_file_set_locale_string_REQUIRED_ARGC, g_key_file_set_locale_string_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_locale_string_list_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_locale_string_list", mrb_GLib_g_key_file_set_locale_string_list, MRB_ARGS_ARG(g_key_file_set_locale_string_list_REQUIRED_ARGC, g_key_file_set_locale_string_list_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_string", mrb_GLib_g_key_file_set_string, MRB_ARGS_ARG(g_key_file_set_string_REQUIRED_ARGC, g_key_file_set_string_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_string_list_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_string_list", mrb_GLib_g_key_file_set_string_list, MRB_ARGS_ARG(g_key_file_set_string_list_REQUIRED_ARGC, g_key_file_set_string_list_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_uint64_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_uint64", mrb_GLib_g_key_file_set_uint64, MRB_ARGS_ARG(g_key_file_set_uint64_REQUIRED_ARGC, g_key_file_set_uint64_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_set_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_set_value", mrb_GLib_g_key_file_set_value, MRB_ARGS_ARG(g_key_file_set_value_REQUIRED_ARGC, g_key_file_set_value_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_to_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_to_data", mrb_GLib_g_key_file_to_data, MRB_ARGS_ARG(g_key_file_to_data_REQUIRED_ARGC, g_key_file_to_data_OPTIONAL_ARGC));
#endif
#if BIND_g_key_file_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_key_file_unref", mrb_GLib_g_key_file_unref, MRB_ARGS_ARG(g_key_file_unref_REQUIRED_ARGC, g_key_file_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_list_alloc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_alloc", mrb_GLib_g_list_alloc, MRB_ARGS_ARG(g_list_alloc_REQUIRED_ARGC, g_list_alloc_OPTIONAL_ARGC));
#endif
#if BIND_g_list_append_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_append", mrb_GLib_g_list_append, MRB_ARGS_ARG(g_list_append_REQUIRED_ARGC, g_list_append_OPTIONAL_ARGC));
#endif
#if BIND_g_list_concat_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_concat", mrb_GLib_g_list_concat, MRB_ARGS_ARG(g_list_concat_REQUIRED_ARGC, g_list_concat_OPTIONAL_ARGC));
#endif
#if BIND_g_list_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_copy", mrb_GLib_g_list_copy, MRB_ARGS_ARG(g_list_copy_REQUIRED_ARGC, g_list_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_list_copy_deep_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_copy_deep", mrb_GLib_g_list_copy_deep, MRB_ARGS_ARG(g_list_copy_deep_REQUIRED_ARGC, g_list_copy_deep_OPTIONAL_ARGC));
#endif
#if BIND_g_list_delete_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_delete_link", mrb_GLib_g_list_delete_link, MRB_ARGS_ARG(g_list_delete_link_REQUIRED_ARGC, g_list_delete_link_OPTIONAL_ARGC));
#endif
#if BIND_g_list_find_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_find", mrb_GLib_g_list_find, MRB_ARGS_ARG(g_list_find_REQUIRED_ARGC, g_list_find_OPTIONAL_ARGC));
#endif
#if BIND_g_list_find_custom_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_find_custom", mrb_GLib_g_list_find_custom, MRB_ARGS_ARG(g_list_find_custom_REQUIRED_ARGC, g_list_find_custom_OPTIONAL_ARGC));
#endif
#if BIND_g_list_first_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_first", mrb_GLib_g_list_first, MRB_ARGS_ARG(g_list_first_REQUIRED_ARGC, g_list_first_OPTIONAL_ARGC));
#endif
#if BIND_g_list_foreach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_foreach", mrb_GLib_g_list_foreach, MRB_ARGS_ARG(g_list_foreach_REQUIRED_ARGC, g_list_foreach_OPTIONAL_ARGC));
#endif
#if BIND_g_list_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_free", mrb_GLib_g_list_free, MRB_ARGS_ARG(g_list_free_REQUIRED_ARGC, g_list_free_OPTIONAL_ARGC));
#endif
#if BIND_g_list_free_1_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_free_1", mrb_GLib_g_list_free_1, MRB_ARGS_ARG(g_list_free_1_REQUIRED_ARGC, g_list_free_1_OPTIONAL_ARGC));
#endif
#if BIND_g_list_free_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_free_full", mrb_GLib_g_list_free_full, MRB_ARGS_ARG(g_list_free_full_REQUIRED_ARGC, g_list_free_full_OPTIONAL_ARGC));
#endif
#if BIND_g_list_index_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_index", mrb_GLib_g_list_index, MRB_ARGS_ARG(g_list_index_REQUIRED_ARGC, g_list_index_OPTIONAL_ARGC));
#endif
#if BIND_g_list_insert_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_insert", mrb_GLib_g_list_insert, MRB_ARGS_ARG(g_list_insert_REQUIRED_ARGC, g_list_insert_OPTIONAL_ARGC));
#endif
#if BIND_g_list_insert_before_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_insert_before", mrb_GLib_g_list_insert_before, MRB_ARGS_ARG(g_list_insert_before_REQUIRED_ARGC, g_list_insert_before_OPTIONAL_ARGC));
#endif
#if BIND_g_list_insert_sorted_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_insert_sorted", mrb_GLib_g_list_insert_sorted, MRB_ARGS_ARG(g_list_insert_sorted_REQUIRED_ARGC, g_list_insert_sorted_OPTIONAL_ARGC));
#endif
#if BIND_g_list_insert_sorted_with_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_insert_sorted_with_data", mrb_GLib_g_list_insert_sorted_with_data, MRB_ARGS_ARG(g_list_insert_sorted_with_data_REQUIRED_ARGC, g_list_insert_sorted_with_data_OPTIONAL_ARGC));
#endif
#if BIND_g_list_last_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_last", mrb_GLib_g_list_last, MRB_ARGS_ARG(g_list_last_REQUIRED_ARGC, g_list_last_OPTIONAL_ARGC));
#endif
#if BIND_g_list_length_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_length", mrb_GLib_g_list_length, MRB_ARGS_ARG(g_list_length_REQUIRED_ARGC, g_list_length_OPTIONAL_ARGC));
#endif
#if BIND_g_list_nth_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_nth", mrb_GLib_g_list_nth, MRB_ARGS_ARG(g_list_nth_REQUIRED_ARGC, g_list_nth_OPTIONAL_ARGC));
#endif
#if BIND_g_list_nth_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_nth_data", mrb_GLib_g_list_nth_data, MRB_ARGS_ARG(g_list_nth_data_REQUIRED_ARGC, g_list_nth_data_OPTIONAL_ARGC));
#endif
#if BIND_g_list_nth_prev_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_nth_prev", mrb_GLib_g_list_nth_prev, MRB_ARGS_ARG(g_list_nth_prev_REQUIRED_ARGC, g_list_nth_prev_OPTIONAL_ARGC));
#endif
#if BIND_g_list_position_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_position", mrb_GLib_g_list_position, MRB_ARGS_ARG(g_list_position_REQUIRED_ARGC, g_list_position_OPTIONAL_ARGC));
#endif
#if BIND_g_list_prepend_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_prepend", mrb_GLib_g_list_prepend, MRB_ARGS_ARG(g_list_prepend_REQUIRED_ARGC, g_list_prepend_OPTIONAL_ARGC));
#endif
#if BIND_g_list_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_remove", mrb_GLib_g_list_remove, MRB_ARGS_ARG(g_list_remove_REQUIRED_ARGC, g_list_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_list_remove_all_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_remove_all", mrb_GLib_g_list_remove_all, MRB_ARGS_ARG(g_list_remove_all_REQUIRED_ARGC, g_list_remove_all_OPTIONAL_ARGC));
#endif
#if BIND_g_list_remove_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_remove_link", mrb_GLib_g_list_remove_link, MRB_ARGS_ARG(g_list_remove_link_REQUIRED_ARGC, g_list_remove_link_OPTIONAL_ARGC));
#endif
#if BIND_g_list_reverse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_reverse", mrb_GLib_g_list_reverse, MRB_ARGS_ARG(g_list_reverse_REQUIRED_ARGC, g_list_reverse_OPTIONAL_ARGC));
#endif
#if BIND_g_list_sort_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_sort", mrb_GLib_g_list_sort, MRB_ARGS_ARG(g_list_sort_REQUIRED_ARGC, g_list_sort_OPTIONAL_ARGC));
#endif
#if BIND_g_list_sort_with_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_list_sort_with_data", mrb_GLib_g_list_sort_with_data, MRB_ARGS_ARG(g_list_sort_with_data_REQUIRED_ARGC, g_list_sort_with_data_OPTIONAL_ARGC));
#endif
#if BIND_g_listenv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_listenv", mrb_GLib_g_listenv, MRB_ARGS_ARG(g_listenv_REQUIRED_ARGC, g_listenv_OPTIONAL_ARGC));
#endif
#if BIND_g_locale_from_utf8_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_locale_from_utf8", mrb_GLib_g_locale_from_utf8, MRB_ARGS_ARG(g_locale_from_utf8_REQUIRED_ARGC, g_locale_from_utf8_OPTIONAL_ARGC));
#endif
#if BIND_g_locale_to_utf8_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_locale_to_utf8", mrb_GLib_g_locale_to_utf8, MRB_ARGS_ARG(g_locale_to_utf8_REQUIRED_ARGC, g_locale_to_utf8_OPTIONAL_ARGC));
#endif
#if BIND_g_log_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_log", mrb_GLib_g_log, MRB_ARGS_ARG(g_log_REQUIRED_ARGC, g_log_OPTIONAL_ARGC));
#endif
#if BIND_g_log_default_handler_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_log_default_handler", mrb_GLib_g_log_default_handler, MRB_ARGS_ARG(g_log_default_handler_REQUIRED_ARGC, g_log_default_handler_OPTIONAL_ARGC));
#endif
#if BIND_g_log_remove_handler_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_log_remove_handler", mrb_GLib_g_log_remove_handler, MRB_ARGS_ARG(g_log_remove_handler_REQUIRED_ARGC, g_log_remove_handler_OPTIONAL_ARGC));
#endif
#if BIND_g_log_set_always_fatal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_log_set_always_fatal", mrb_GLib_g_log_set_always_fatal, MRB_ARGS_ARG(g_log_set_always_fatal_REQUIRED_ARGC, g_log_set_always_fatal_OPTIONAL_ARGC));
#endif
#if BIND_g_log_set_default_handler_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_log_set_default_handler", mrb_GLib_g_log_set_default_handler, MRB_ARGS_ARG(g_log_set_default_handler_REQUIRED_ARGC, g_log_set_default_handler_OPTIONAL_ARGC));
#endif
#if BIND_g_log_set_fatal_mask_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_log_set_fatal_mask", mrb_GLib_g_log_set_fatal_mask, MRB_ARGS_ARG(g_log_set_fatal_mask_REQUIRED_ARGC, g_log_set_fatal_mask_OPTIONAL_ARGC));
#endif
#if BIND_g_log_set_handler_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_log_set_handler", mrb_GLib_g_log_set_handler, MRB_ARGS_ARG(g_log_set_handler_REQUIRED_ARGC, g_log_set_handler_OPTIONAL_ARGC));
#endif
#if BIND_g_log_set_handler_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_log_set_handler_full", mrb_GLib_g_log_set_handler_full, MRB_ARGS_ARG(g_log_set_handler_full_REQUIRED_ARGC, g_log_set_handler_full_OPTIONAL_ARGC));
#endif
#if BIND_g_logv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_logv", mrb_GLib_g_logv, MRB_ARGS_ARG(g_logv_REQUIRED_ARGC, g_logv_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_acquire_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_acquire", mrb_GLib_g_main_context_acquire, MRB_ARGS_ARG(g_main_context_acquire_REQUIRED_ARGC, g_main_context_acquire_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_add_poll_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_add_poll", mrb_GLib_g_main_context_add_poll, MRB_ARGS_ARG(g_main_context_add_poll_REQUIRED_ARGC, g_main_context_add_poll_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_check_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_check", mrb_GLib_g_main_context_check, MRB_ARGS_ARG(g_main_context_check_REQUIRED_ARGC, g_main_context_check_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_default_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_default", mrb_GLib_g_main_context_default, MRB_ARGS_ARG(g_main_context_default_REQUIRED_ARGC, g_main_context_default_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_dispatch_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_dispatch", mrb_GLib_g_main_context_dispatch, MRB_ARGS_ARG(g_main_context_dispatch_REQUIRED_ARGC, g_main_context_dispatch_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_find_source_by_funcs_user_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_find_source_by_funcs_user_data", mrb_GLib_g_main_context_find_source_by_funcs_user_data, MRB_ARGS_ARG(g_main_context_find_source_by_funcs_user_data_REQUIRED_ARGC, g_main_context_find_source_by_funcs_user_data_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_find_source_by_id_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_find_source_by_id", mrb_GLib_g_main_context_find_source_by_id, MRB_ARGS_ARG(g_main_context_find_source_by_id_REQUIRED_ARGC, g_main_context_find_source_by_id_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_find_source_by_user_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_find_source_by_user_data", mrb_GLib_g_main_context_find_source_by_user_data, MRB_ARGS_ARG(g_main_context_find_source_by_user_data_REQUIRED_ARGC, g_main_context_find_source_by_user_data_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_get_poll_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_get_poll_func", mrb_GLib_g_main_context_get_poll_func, MRB_ARGS_ARG(g_main_context_get_poll_func_REQUIRED_ARGC, g_main_context_get_poll_func_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_get_thread_default_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_get_thread_default", mrb_GLib_g_main_context_get_thread_default, MRB_ARGS_ARG(g_main_context_get_thread_default_REQUIRED_ARGC, g_main_context_get_thread_default_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_invoke_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_invoke", mrb_GLib_g_main_context_invoke, MRB_ARGS_ARG(g_main_context_invoke_REQUIRED_ARGC, g_main_context_invoke_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_invoke_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_invoke_full", mrb_GLib_g_main_context_invoke_full, MRB_ARGS_ARG(g_main_context_invoke_full_REQUIRED_ARGC, g_main_context_invoke_full_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_is_owner_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_is_owner", mrb_GLib_g_main_context_is_owner, MRB_ARGS_ARG(g_main_context_is_owner_REQUIRED_ARGC, g_main_context_is_owner_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_iteration_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_iteration", mrb_GLib_g_main_context_iteration, MRB_ARGS_ARG(g_main_context_iteration_REQUIRED_ARGC, g_main_context_iteration_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_new", mrb_GLib_g_main_context_new, MRB_ARGS_ARG(g_main_context_new_REQUIRED_ARGC, g_main_context_new_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_pending_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_pending", mrb_GLib_g_main_context_pending, MRB_ARGS_ARG(g_main_context_pending_REQUIRED_ARGC, g_main_context_pending_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_pop_thread_default_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_pop_thread_default", mrb_GLib_g_main_context_pop_thread_default, MRB_ARGS_ARG(g_main_context_pop_thread_default_REQUIRED_ARGC, g_main_context_pop_thread_default_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_prepare_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_prepare", mrb_GLib_g_main_context_prepare, MRB_ARGS_ARG(g_main_context_prepare_REQUIRED_ARGC, g_main_context_prepare_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_push_thread_default_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_push_thread_default", mrb_GLib_g_main_context_push_thread_default, MRB_ARGS_ARG(g_main_context_push_thread_default_REQUIRED_ARGC, g_main_context_push_thread_default_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_query_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_query", mrb_GLib_g_main_context_query, MRB_ARGS_ARG(g_main_context_query_REQUIRED_ARGC, g_main_context_query_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_ref", mrb_GLib_g_main_context_ref, MRB_ARGS_ARG(g_main_context_ref_REQUIRED_ARGC, g_main_context_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_ref_thread_default_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_ref_thread_default", mrb_GLib_g_main_context_ref_thread_default, MRB_ARGS_ARG(g_main_context_ref_thread_default_REQUIRED_ARGC, g_main_context_ref_thread_default_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_release_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_release", mrb_GLib_g_main_context_release, MRB_ARGS_ARG(g_main_context_release_REQUIRED_ARGC, g_main_context_release_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_remove_poll_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_remove_poll", mrb_GLib_g_main_context_remove_poll, MRB_ARGS_ARG(g_main_context_remove_poll_REQUIRED_ARGC, g_main_context_remove_poll_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_set_poll_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_set_poll_func", mrb_GLib_g_main_context_set_poll_func, MRB_ARGS_ARG(g_main_context_set_poll_func_REQUIRED_ARGC, g_main_context_set_poll_func_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_unref", mrb_GLib_g_main_context_unref, MRB_ARGS_ARG(g_main_context_unref_REQUIRED_ARGC, g_main_context_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_wait_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_wait", mrb_GLib_g_main_context_wait, MRB_ARGS_ARG(g_main_context_wait_REQUIRED_ARGC, g_main_context_wait_OPTIONAL_ARGC));
#endif
#if BIND_g_main_context_wakeup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_context_wakeup", mrb_GLib_g_main_context_wakeup, MRB_ARGS_ARG(g_main_context_wakeup_REQUIRED_ARGC, g_main_context_wakeup_OPTIONAL_ARGC));
#endif
#if BIND_g_main_current_source_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_current_source", mrb_GLib_g_main_current_source, MRB_ARGS_ARG(g_main_current_source_REQUIRED_ARGC, g_main_current_source_OPTIONAL_ARGC));
#endif
#if BIND_g_main_depth_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_depth", mrb_GLib_g_main_depth, MRB_ARGS_ARG(g_main_depth_REQUIRED_ARGC, g_main_depth_OPTIONAL_ARGC));
#endif
#if BIND_g_main_loop_get_context_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_loop_get_context", mrb_GLib_g_main_loop_get_context, MRB_ARGS_ARG(g_main_loop_get_context_REQUIRED_ARGC, g_main_loop_get_context_OPTIONAL_ARGC));
#endif
#if BIND_g_main_loop_is_running_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_loop_is_running", mrb_GLib_g_main_loop_is_running, MRB_ARGS_ARG(g_main_loop_is_running_REQUIRED_ARGC, g_main_loop_is_running_OPTIONAL_ARGC));
#endif
#if BIND_g_main_loop_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_loop_new", mrb_GLib_g_main_loop_new, MRB_ARGS_ARG(g_main_loop_new_REQUIRED_ARGC, g_main_loop_new_OPTIONAL_ARGC));
#endif
#if BIND_g_main_loop_quit_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_loop_quit", mrb_GLib_g_main_loop_quit, MRB_ARGS_ARG(g_main_loop_quit_REQUIRED_ARGC, g_main_loop_quit_OPTIONAL_ARGC));
#endif
#if BIND_g_main_loop_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_loop_ref", mrb_GLib_g_main_loop_ref, MRB_ARGS_ARG(g_main_loop_ref_REQUIRED_ARGC, g_main_loop_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_main_loop_run_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_loop_run", mrb_GLib_g_main_loop_run, MRB_ARGS_ARG(g_main_loop_run_REQUIRED_ARGC, g_main_loop_run_OPTIONAL_ARGC));
#endif
#if BIND_g_main_loop_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_main_loop_unref", mrb_GLib_g_main_loop_unref, MRB_ARGS_ARG(g_main_loop_unref_REQUIRED_ARGC, g_main_loop_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_malloc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_malloc", mrb_GLib_g_malloc, MRB_ARGS_ARG(g_malloc_REQUIRED_ARGC, g_malloc_OPTIONAL_ARGC));
#endif
#if BIND_g_malloc0_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_malloc0", mrb_GLib_g_malloc0, MRB_ARGS_ARG(g_malloc0_REQUIRED_ARGC, g_malloc0_OPTIONAL_ARGC));
#endif
#if BIND_g_malloc0_n_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_malloc0_n", mrb_GLib_g_malloc0_n, MRB_ARGS_ARG(g_malloc0_n_REQUIRED_ARGC, g_malloc0_n_OPTIONAL_ARGC));
#endif
#if BIND_g_malloc_n_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_malloc_n", mrb_GLib_g_malloc_n, MRB_ARGS_ARG(g_malloc_n_REQUIRED_ARGC, g_malloc_n_OPTIONAL_ARGC));
#endif
#if BIND_g_mapped_file_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mapped_file_free", mrb_GLib_g_mapped_file_free, MRB_ARGS_ARG(g_mapped_file_free_REQUIRED_ARGC, g_mapped_file_free_OPTIONAL_ARGC));
#endif
#if BIND_g_mapped_file_get_bytes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mapped_file_get_bytes", mrb_GLib_g_mapped_file_get_bytes, MRB_ARGS_ARG(g_mapped_file_get_bytes_REQUIRED_ARGC, g_mapped_file_get_bytes_OPTIONAL_ARGC));
#endif
#if BIND_g_mapped_file_get_contents_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mapped_file_get_contents", mrb_GLib_g_mapped_file_get_contents, MRB_ARGS_ARG(g_mapped_file_get_contents_REQUIRED_ARGC, g_mapped_file_get_contents_OPTIONAL_ARGC));
#endif
#if BIND_g_mapped_file_get_length_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mapped_file_get_length", mrb_GLib_g_mapped_file_get_length, MRB_ARGS_ARG(g_mapped_file_get_length_REQUIRED_ARGC, g_mapped_file_get_length_OPTIONAL_ARGC));
#endif
#if BIND_g_mapped_file_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mapped_file_new", mrb_GLib_g_mapped_file_new, MRB_ARGS_ARG(g_mapped_file_new_REQUIRED_ARGC, g_mapped_file_new_OPTIONAL_ARGC));
#endif
#if BIND_g_mapped_file_new_from_fd_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mapped_file_new_from_fd", mrb_GLib_g_mapped_file_new_from_fd, MRB_ARGS_ARG(g_mapped_file_new_from_fd_REQUIRED_ARGC, g_mapped_file_new_from_fd_OPTIONAL_ARGC));
#endif
#if BIND_g_mapped_file_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mapped_file_ref", mrb_GLib_g_mapped_file_ref, MRB_ARGS_ARG(g_mapped_file_ref_REQUIRED_ARGC, g_mapped_file_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_mapped_file_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mapped_file_unref", mrb_GLib_g_mapped_file_unref, MRB_ARGS_ARG(g_mapped_file_unref_REQUIRED_ARGC, g_mapped_file_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_collect_attributes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_collect_attributes", mrb_GLib_g_markup_collect_attributes, MRB_ARGS_ARG(g_markup_collect_attributes_REQUIRED_ARGC, g_markup_collect_attributes_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_error_quark", mrb_GLib_g_markup_error_quark, MRB_ARGS_ARG(g_markup_error_quark_REQUIRED_ARGC, g_markup_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_escape_text_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_escape_text", mrb_GLib_g_markup_escape_text, MRB_ARGS_ARG(g_markup_escape_text_REQUIRED_ARGC, g_markup_escape_text_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_end_parse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_end_parse", mrb_GLib_g_markup_parse_context_end_parse, MRB_ARGS_ARG(g_markup_parse_context_end_parse_REQUIRED_ARGC, g_markup_parse_context_end_parse_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_free", mrb_GLib_g_markup_parse_context_free, MRB_ARGS_ARG(g_markup_parse_context_free_REQUIRED_ARGC, g_markup_parse_context_free_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_get_element_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_get_element", mrb_GLib_g_markup_parse_context_get_element, MRB_ARGS_ARG(g_markup_parse_context_get_element_REQUIRED_ARGC, g_markup_parse_context_get_element_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_get_element_stack_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_get_element_stack", mrb_GLib_g_markup_parse_context_get_element_stack, MRB_ARGS_ARG(g_markup_parse_context_get_element_stack_REQUIRED_ARGC, g_markup_parse_context_get_element_stack_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_get_position_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_get_position", mrb_GLib_g_markup_parse_context_get_position, MRB_ARGS_ARG(g_markup_parse_context_get_position_REQUIRED_ARGC, g_markup_parse_context_get_position_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_get_user_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_get_user_data", mrb_GLib_g_markup_parse_context_get_user_data, MRB_ARGS_ARG(g_markup_parse_context_get_user_data_REQUIRED_ARGC, g_markup_parse_context_get_user_data_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_new", mrb_GLib_g_markup_parse_context_new, MRB_ARGS_ARG(g_markup_parse_context_new_REQUIRED_ARGC, g_markup_parse_context_new_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_parse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_parse", mrb_GLib_g_markup_parse_context_parse, MRB_ARGS_ARG(g_markup_parse_context_parse_REQUIRED_ARGC, g_markup_parse_context_parse_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_pop_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_pop", mrb_GLib_g_markup_parse_context_pop, MRB_ARGS_ARG(g_markup_parse_context_pop_REQUIRED_ARGC, g_markup_parse_context_pop_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_push_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_push", mrb_GLib_g_markup_parse_context_push, MRB_ARGS_ARG(g_markup_parse_context_push_REQUIRED_ARGC, g_markup_parse_context_push_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_ref", mrb_GLib_g_markup_parse_context_ref, MRB_ARGS_ARG(g_markup_parse_context_ref_REQUIRED_ARGC, g_markup_parse_context_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_parse_context_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_parse_context_unref", mrb_GLib_g_markup_parse_context_unref, MRB_ARGS_ARG(g_markup_parse_context_unref_REQUIRED_ARGC, g_markup_parse_context_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_printf_escaped_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_printf_escaped", mrb_GLib_g_markup_printf_escaped, MRB_ARGS_ARG(g_markup_printf_escaped_REQUIRED_ARGC, g_markup_printf_escaped_OPTIONAL_ARGC));
#endif
#if BIND_g_markup_vprintf_escaped_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_markup_vprintf_escaped", mrb_GLib_g_markup_vprintf_escaped, MRB_ARGS_ARG(g_markup_vprintf_escaped_REQUIRED_ARGC, g_markup_vprintf_escaped_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_expand_references_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_expand_references", mrb_GLib_g_match_info_expand_references, MRB_ARGS_ARG(g_match_info_expand_references_REQUIRED_ARGC, g_match_info_expand_references_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_fetch_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_fetch", mrb_GLib_g_match_info_fetch, MRB_ARGS_ARG(g_match_info_fetch_REQUIRED_ARGC, g_match_info_fetch_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_fetch_all_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_fetch_all", mrb_GLib_g_match_info_fetch_all, MRB_ARGS_ARG(g_match_info_fetch_all_REQUIRED_ARGC, g_match_info_fetch_all_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_fetch_named_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_fetch_named", mrb_GLib_g_match_info_fetch_named, MRB_ARGS_ARG(g_match_info_fetch_named_REQUIRED_ARGC, g_match_info_fetch_named_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_fetch_named_pos_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_fetch_named_pos", mrb_GLib_g_match_info_fetch_named_pos, MRB_ARGS_ARG(g_match_info_fetch_named_pos_REQUIRED_ARGC, g_match_info_fetch_named_pos_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_fetch_pos_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_fetch_pos", mrb_GLib_g_match_info_fetch_pos, MRB_ARGS_ARG(g_match_info_fetch_pos_REQUIRED_ARGC, g_match_info_fetch_pos_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_free", mrb_GLib_g_match_info_free, MRB_ARGS_ARG(g_match_info_free_REQUIRED_ARGC, g_match_info_free_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_get_match_count_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_get_match_count", mrb_GLib_g_match_info_get_match_count, MRB_ARGS_ARG(g_match_info_get_match_count_REQUIRED_ARGC, g_match_info_get_match_count_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_get_regex_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_get_regex", mrb_GLib_g_match_info_get_regex, MRB_ARGS_ARG(g_match_info_get_regex_REQUIRED_ARGC, g_match_info_get_regex_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_get_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_get_string", mrb_GLib_g_match_info_get_string, MRB_ARGS_ARG(g_match_info_get_string_REQUIRED_ARGC, g_match_info_get_string_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_is_partial_match_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_is_partial_match", mrb_GLib_g_match_info_is_partial_match, MRB_ARGS_ARG(g_match_info_is_partial_match_REQUIRED_ARGC, g_match_info_is_partial_match_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_matches_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_matches", mrb_GLib_g_match_info_matches, MRB_ARGS_ARG(g_match_info_matches_REQUIRED_ARGC, g_match_info_matches_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_next_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_next", mrb_GLib_g_match_info_next, MRB_ARGS_ARG(g_match_info_next_REQUIRED_ARGC, g_match_info_next_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_ref", mrb_GLib_g_match_info_ref, MRB_ARGS_ARG(g_match_info_ref_REQUIRED_ARGC, g_match_info_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_match_info_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_match_info_unref", mrb_GLib_g_match_info_unref, MRB_ARGS_ARG(g_match_info_unref_REQUIRED_ARGC, g_match_info_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_mem_is_system_malloc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mem_is_system_malloc", mrb_GLib_g_mem_is_system_malloc, MRB_ARGS_ARG(g_mem_is_system_malloc_REQUIRED_ARGC, g_mem_is_system_malloc_OPTIONAL_ARGC));
#endif
#if BIND_g_mem_profile_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mem_profile", mrb_GLib_g_mem_profile, MRB_ARGS_ARG(g_mem_profile_REQUIRED_ARGC, g_mem_profile_OPTIONAL_ARGC));
#endif
#if BIND_g_mem_set_vtable_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mem_set_vtable", mrb_GLib_g_mem_set_vtable, MRB_ARGS_ARG(g_mem_set_vtable_REQUIRED_ARGC, g_mem_set_vtable_OPTIONAL_ARGC));
#endif
#if BIND_g_memdup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_memdup", mrb_GLib_g_memdup, MRB_ARGS_ARG(g_memdup_REQUIRED_ARGC, g_memdup_OPTIONAL_ARGC));
#endif
#if BIND_g_mkdir_with_parents_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mkdir_with_parents", mrb_GLib_g_mkdir_with_parents, MRB_ARGS_ARG(g_mkdir_with_parents_REQUIRED_ARGC, g_mkdir_with_parents_OPTIONAL_ARGC));
#endif
#if BIND_g_mkdtemp_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mkdtemp", mrb_GLib_g_mkdtemp, MRB_ARGS_ARG(g_mkdtemp_REQUIRED_ARGC, g_mkdtemp_OPTIONAL_ARGC));
#endif
#if BIND_g_mkdtemp_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mkdtemp_full", mrb_GLib_g_mkdtemp_full, MRB_ARGS_ARG(g_mkdtemp_full_REQUIRED_ARGC, g_mkdtemp_full_OPTIONAL_ARGC));
#endif
#if BIND_g_mkstemp_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mkstemp", mrb_GLib_g_mkstemp, MRB_ARGS_ARG(g_mkstemp_REQUIRED_ARGC, g_mkstemp_OPTIONAL_ARGC));
#endif
#if BIND_g_mkstemp_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mkstemp_full", mrb_GLib_g_mkstemp_full, MRB_ARGS_ARG(g_mkstemp_full_REQUIRED_ARGC, g_mkstemp_full_OPTIONAL_ARGC));
#endif
#if BIND_g_mutex_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mutex_clear", mrb_GLib_g_mutex_clear, MRB_ARGS_ARG(g_mutex_clear_REQUIRED_ARGC, g_mutex_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_mutex_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mutex_init", mrb_GLib_g_mutex_init, MRB_ARGS_ARG(g_mutex_init_REQUIRED_ARGC, g_mutex_init_OPTIONAL_ARGC));
#endif
#if BIND_g_mutex_lock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mutex_lock", mrb_GLib_g_mutex_lock, MRB_ARGS_ARG(g_mutex_lock_REQUIRED_ARGC, g_mutex_lock_OPTIONAL_ARGC));
#endif
#if BIND_g_mutex_locker_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mutex_locker_free", mrb_GLib_g_mutex_locker_free, MRB_ARGS_ARG(g_mutex_locker_free_REQUIRED_ARGC, g_mutex_locker_free_OPTIONAL_ARGC));
#endif
#if BIND_g_mutex_locker_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mutex_locker_new", mrb_GLib_g_mutex_locker_new, MRB_ARGS_ARG(g_mutex_locker_new_REQUIRED_ARGC, g_mutex_locker_new_OPTIONAL_ARGC));
#endif
#if BIND_g_mutex_trylock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mutex_trylock", mrb_GLib_g_mutex_trylock, MRB_ARGS_ARG(g_mutex_trylock_REQUIRED_ARGC, g_mutex_trylock_OPTIONAL_ARGC));
#endif
#if BIND_g_mutex_unlock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_mutex_unlock", mrb_GLib_g_mutex_unlock, MRB_ARGS_ARG(g_mutex_unlock_REQUIRED_ARGC, g_mutex_unlock_OPTIONAL_ARGC));
#endif
#if BIND_g_node_child_index_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_child_index", mrb_GLib_g_node_child_index, MRB_ARGS_ARG(g_node_child_index_REQUIRED_ARGC, g_node_child_index_OPTIONAL_ARGC));
#endif
#if BIND_g_node_child_position_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_child_position", mrb_GLib_g_node_child_position, MRB_ARGS_ARG(g_node_child_position_REQUIRED_ARGC, g_node_child_position_OPTIONAL_ARGC));
#endif
#if BIND_g_node_children_foreach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_children_foreach", mrb_GLib_g_node_children_foreach, MRB_ARGS_ARG(g_node_children_foreach_REQUIRED_ARGC, g_node_children_foreach_OPTIONAL_ARGC));
#endif
#if BIND_g_node_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_copy", mrb_GLib_g_node_copy, MRB_ARGS_ARG(g_node_copy_REQUIRED_ARGC, g_node_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_node_copy_deep_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_copy_deep", mrb_GLib_g_node_copy_deep, MRB_ARGS_ARG(g_node_copy_deep_REQUIRED_ARGC, g_node_copy_deep_OPTIONAL_ARGC));
#endif
#if BIND_g_node_depth_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_depth", mrb_GLib_g_node_depth, MRB_ARGS_ARG(g_node_depth_REQUIRED_ARGC, g_node_depth_OPTIONAL_ARGC));
#endif
#if BIND_g_node_destroy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_destroy", mrb_GLib_g_node_destroy, MRB_ARGS_ARG(g_node_destroy_REQUIRED_ARGC, g_node_destroy_OPTIONAL_ARGC));
#endif
#if BIND_g_node_find_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_find", mrb_GLib_g_node_find, MRB_ARGS_ARG(g_node_find_REQUIRED_ARGC, g_node_find_OPTIONAL_ARGC));
#endif
#if BIND_g_node_find_child_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_find_child", mrb_GLib_g_node_find_child, MRB_ARGS_ARG(g_node_find_child_REQUIRED_ARGC, g_node_find_child_OPTIONAL_ARGC));
#endif
#if BIND_g_node_first_sibling_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_first_sibling", mrb_GLib_g_node_first_sibling, MRB_ARGS_ARG(g_node_first_sibling_REQUIRED_ARGC, g_node_first_sibling_OPTIONAL_ARGC));
#endif
#if BIND_g_node_get_root_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_get_root", mrb_GLib_g_node_get_root, MRB_ARGS_ARG(g_node_get_root_REQUIRED_ARGC, g_node_get_root_OPTIONAL_ARGC));
#endif
#if BIND_g_node_insert_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_insert", mrb_GLib_g_node_insert, MRB_ARGS_ARG(g_node_insert_REQUIRED_ARGC, g_node_insert_OPTIONAL_ARGC));
#endif
#if BIND_g_node_insert_after_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_insert_after", mrb_GLib_g_node_insert_after, MRB_ARGS_ARG(g_node_insert_after_REQUIRED_ARGC, g_node_insert_after_OPTIONAL_ARGC));
#endif
#if BIND_g_node_insert_before_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_insert_before", mrb_GLib_g_node_insert_before, MRB_ARGS_ARG(g_node_insert_before_REQUIRED_ARGC, g_node_insert_before_OPTIONAL_ARGC));
#endif
#if BIND_g_node_is_ancestor_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_is_ancestor", mrb_GLib_g_node_is_ancestor, MRB_ARGS_ARG(g_node_is_ancestor_REQUIRED_ARGC, g_node_is_ancestor_OPTIONAL_ARGC));
#endif
#if BIND_g_node_last_child_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_last_child", mrb_GLib_g_node_last_child, MRB_ARGS_ARG(g_node_last_child_REQUIRED_ARGC, g_node_last_child_OPTIONAL_ARGC));
#endif
#if BIND_g_node_last_sibling_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_last_sibling", mrb_GLib_g_node_last_sibling, MRB_ARGS_ARG(g_node_last_sibling_REQUIRED_ARGC, g_node_last_sibling_OPTIONAL_ARGC));
#endif
#if BIND_g_node_max_height_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_max_height", mrb_GLib_g_node_max_height, MRB_ARGS_ARG(g_node_max_height_REQUIRED_ARGC, g_node_max_height_OPTIONAL_ARGC));
#endif
#if BIND_g_node_n_children_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_n_children", mrb_GLib_g_node_n_children, MRB_ARGS_ARG(g_node_n_children_REQUIRED_ARGC, g_node_n_children_OPTIONAL_ARGC));
#endif
#if BIND_g_node_n_nodes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_n_nodes", mrb_GLib_g_node_n_nodes, MRB_ARGS_ARG(g_node_n_nodes_REQUIRED_ARGC, g_node_n_nodes_OPTIONAL_ARGC));
#endif
#if BIND_g_node_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_new", mrb_GLib_g_node_new, MRB_ARGS_ARG(g_node_new_REQUIRED_ARGC, g_node_new_OPTIONAL_ARGC));
#endif
#if BIND_g_node_nth_child_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_nth_child", mrb_GLib_g_node_nth_child, MRB_ARGS_ARG(g_node_nth_child_REQUIRED_ARGC, g_node_nth_child_OPTIONAL_ARGC));
#endif
#if BIND_g_node_prepend_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_prepend", mrb_GLib_g_node_prepend, MRB_ARGS_ARG(g_node_prepend_REQUIRED_ARGC, g_node_prepend_OPTIONAL_ARGC));
#endif
#if BIND_g_node_reverse_children_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_reverse_children", mrb_GLib_g_node_reverse_children, MRB_ARGS_ARG(g_node_reverse_children_REQUIRED_ARGC, g_node_reverse_children_OPTIONAL_ARGC));
#endif
#if BIND_g_node_traverse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_traverse", mrb_GLib_g_node_traverse, MRB_ARGS_ARG(g_node_traverse_REQUIRED_ARGC, g_node_traverse_OPTIONAL_ARGC));
#endif
#if BIND_g_node_unlink_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_node_unlink", mrb_GLib_g_node_unlink, MRB_ARGS_ARG(g_node_unlink_REQUIRED_ARGC, g_node_unlink_OPTIONAL_ARGC));
#endif
#if BIND_g_nullify_pointer_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_nullify_pointer", mrb_GLib_g_nullify_pointer, MRB_ARGS_ARG(g_nullify_pointer_REQUIRED_ARGC, g_nullify_pointer_OPTIONAL_ARGC));
#endif
#if BIND_g_on_error_query_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_on_error_query", mrb_GLib_g_on_error_query, MRB_ARGS_ARG(g_on_error_query_REQUIRED_ARGC, g_on_error_query_OPTIONAL_ARGC));
#endif
#if BIND_g_on_error_stack_trace_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_on_error_stack_trace", mrb_GLib_g_on_error_stack_trace, MRB_ARGS_ARG(g_on_error_stack_trace_REQUIRED_ARGC, g_on_error_stack_trace_OPTIONAL_ARGC));
#endif
#if BIND_g_once_impl_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_once_impl", mrb_GLib_g_once_impl, MRB_ARGS_ARG(g_once_impl_REQUIRED_ARGC, g_once_impl_OPTIONAL_ARGC));
#endif
#if BIND_g_once_init_enter_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_once_init_enter", mrb_GLib_g_once_init_enter, MRB_ARGS_ARG(g_once_init_enter_REQUIRED_ARGC, g_once_init_enter_OPTIONAL_ARGC));
#endif
#if BIND_g_once_init_leave_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_once_init_leave", mrb_GLib_g_once_init_leave, MRB_ARGS_ARG(g_once_init_leave_REQUIRED_ARGC, g_once_init_leave_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_add_group_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_add_group", mrb_GLib_g_option_context_add_group, MRB_ARGS_ARG(g_option_context_add_group_REQUIRED_ARGC, g_option_context_add_group_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_add_main_entries_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_add_main_entries", mrb_GLib_g_option_context_add_main_entries, MRB_ARGS_ARG(g_option_context_add_main_entries_REQUIRED_ARGC, g_option_context_add_main_entries_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_free", mrb_GLib_g_option_context_free, MRB_ARGS_ARG(g_option_context_free_REQUIRED_ARGC, g_option_context_free_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_get_description_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_get_description", mrb_GLib_g_option_context_get_description, MRB_ARGS_ARG(g_option_context_get_description_REQUIRED_ARGC, g_option_context_get_description_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_get_help_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_get_help", mrb_GLib_g_option_context_get_help, MRB_ARGS_ARG(g_option_context_get_help_REQUIRED_ARGC, g_option_context_get_help_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_get_help_enabled_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_get_help_enabled", mrb_GLib_g_option_context_get_help_enabled, MRB_ARGS_ARG(g_option_context_get_help_enabled_REQUIRED_ARGC, g_option_context_get_help_enabled_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_get_ignore_unknown_options_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_get_ignore_unknown_options", mrb_GLib_g_option_context_get_ignore_unknown_options, MRB_ARGS_ARG(g_option_context_get_ignore_unknown_options_REQUIRED_ARGC, g_option_context_get_ignore_unknown_options_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_get_main_group_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_get_main_group", mrb_GLib_g_option_context_get_main_group, MRB_ARGS_ARG(g_option_context_get_main_group_REQUIRED_ARGC, g_option_context_get_main_group_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_get_strict_posix_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_get_strict_posix", mrb_GLib_g_option_context_get_strict_posix, MRB_ARGS_ARG(g_option_context_get_strict_posix_REQUIRED_ARGC, g_option_context_get_strict_posix_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_get_summary_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_get_summary", mrb_GLib_g_option_context_get_summary, MRB_ARGS_ARG(g_option_context_get_summary_REQUIRED_ARGC, g_option_context_get_summary_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_new", mrb_GLib_g_option_context_new, MRB_ARGS_ARG(g_option_context_new_REQUIRED_ARGC, g_option_context_new_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_parse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_parse", mrb_GLib_g_option_context_parse, MRB_ARGS_ARG(g_option_context_parse_REQUIRED_ARGC, g_option_context_parse_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_parse_strv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_parse_strv", mrb_GLib_g_option_context_parse_strv, MRB_ARGS_ARG(g_option_context_parse_strv_REQUIRED_ARGC, g_option_context_parse_strv_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_set_description_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_set_description", mrb_GLib_g_option_context_set_description, MRB_ARGS_ARG(g_option_context_set_description_REQUIRED_ARGC, g_option_context_set_description_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_set_help_enabled_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_set_help_enabled", mrb_GLib_g_option_context_set_help_enabled, MRB_ARGS_ARG(g_option_context_set_help_enabled_REQUIRED_ARGC, g_option_context_set_help_enabled_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_set_ignore_unknown_options_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_set_ignore_unknown_options", mrb_GLib_g_option_context_set_ignore_unknown_options, MRB_ARGS_ARG(g_option_context_set_ignore_unknown_options_REQUIRED_ARGC, g_option_context_set_ignore_unknown_options_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_set_main_group_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_set_main_group", mrb_GLib_g_option_context_set_main_group, MRB_ARGS_ARG(g_option_context_set_main_group_REQUIRED_ARGC, g_option_context_set_main_group_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_set_strict_posix_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_set_strict_posix", mrb_GLib_g_option_context_set_strict_posix, MRB_ARGS_ARG(g_option_context_set_strict_posix_REQUIRED_ARGC, g_option_context_set_strict_posix_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_set_summary_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_set_summary", mrb_GLib_g_option_context_set_summary, MRB_ARGS_ARG(g_option_context_set_summary_REQUIRED_ARGC, g_option_context_set_summary_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_set_translate_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_set_translate_func", mrb_GLib_g_option_context_set_translate_func, MRB_ARGS_ARG(g_option_context_set_translate_func_REQUIRED_ARGC, g_option_context_set_translate_func_OPTIONAL_ARGC));
#endif
#if BIND_g_option_context_set_translation_domain_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_context_set_translation_domain", mrb_GLib_g_option_context_set_translation_domain, MRB_ARGS_ARG(g_option_context_set_translation_domain_REQUIRED_ARGC, g_option_context_set_translation_domain_OPTIONAL_ARGC));
#endif
#if BIND_g_option_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_error_quark", mrb_GLib_g_option_error_quark, MRB_ARGS_ARG(g_option_error_quark_REQUIRED_ARGC, g_option_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_option_group_add_entries_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_group_add_entries", mrb_GLib_g_option_group_add_entries, MRB_ARGS_ARG(g_option_group_add_entries_REQUIRED_ARGC, g_option_group_add_entries_OPTIONAL_ARGC));
#endif
#if BIND_g_option_group_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_group_free", mrb_GLib_g_option_group_free, MRB_ARGS_ARG(g_option_group_free_REQUIRED_ARGC, g_option_group_free_OPTIONAL_ARGC));
#endif
#if BIND_g_option_group_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_group_new", mrb_GLib_g_option_group_new, MRB_ARGS_ARG(g_option_group_new_REQUIRED_ARGC, g_option_group_new_OPTIONAL_ARGC));
#endif
#if BIND_g_option_group_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_group_ref", mrb_GLib_g_option_group_ref, MRB_ARGS_ARG(g_option_group_ref_REQUIRED_ARGC, g_option_group_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_option_group_set_error_hook_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_group_set_error_hook", mrb_GLib_g_option_group_set_error_hook, MRB_ARGS_ARG(g_option_group_set_error_hook_REQUIRED_ARGC, g_option_group_set_error_hook_OPTIONAL_ARGC));
#endif
#if BIND_g_option_group_set_parse_hooks_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_group_set_parse_hooks", mrb_GLib_g_option_group_set_parse_hooks, MRB_ARGS_ARG(g_option_group_set_parse_hooks_REQUIRED_ARGC, g_option_group_set_parse_hooks_OPTIONAL_ARGC));
#endif
#if BIND_g_option_group_set_translate_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_group_set_translate_func", mrb_GLib_g_option_group_set_translate_func, MRB_ARGS_ARG(g_option_group_set_translate_func_REQUIRED_ARGC, g_option_group_set_translate_func_OPTIONAL_ARGC));
#endif
#if BIND_g_option_group_set_translation_domain_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_group_set_translation_domain", mrb_GLib_g_option_group_set_translation_domain, MRB_ARGS_ARG(g_option_group_set_translation_domain_REQUIRED_ARGC, g_option_group_set_translation_domain_OPTIONAL_ARGC));
#endif
#if BIND_g_option_group_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_option_group_unref", mrb_GLib_g_option_group_unref, MRB_ARGS_ARG(g_option_group_unref_REQUIRED_ARGC, g_option_group_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_parse_debug_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_parse_debug_string", mrb_GLib_g_parse_debug_string, MRB_ARGS_ARG(g_parse_debug_string_REQUIRED_ARGC, g_parse_debug_string_OPTIONAL_ARGC));
#endif
#if BIND_g_path_get_basename_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_path_get_basename", mrb_GLib_g_path_get_basename, MRB_ARGS_ARG(g_path_get_basename_REQUIRED_ARGC, g_path_get_basename_OPTIONAL_ARGC));
#endif
#if BIND_g_path_get_dirname_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_path_get_dirname", mrb_GLib_g_path_get_dirname, MRB_ARGS_ARG(g_path_get_dirname_REQUIRED_ARGC, g_path_get_dirname_OPTIONAL_ARGC));
#endif
#if BIND_g_path_is_absolute_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_path_is_absolute", mrb_GLib_g_path_is_absolute, MRB_ARGS_ARG(g_path_is_absolute_REQUIRED_ARGC, g_path_is_absolute_OPTIONAL_ARGC));
#endif
#if BIND_g_path_skip_root_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_path_skip_root", mrb_GLib_g_path_skip_root, MRB_ARGS_ARG(g_path_skip_root_REQUIRED_ARGC, g_path_skip_root_OPTIONAL_ARGC));
#endif
#if BIND_g_pattern_match_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_pattern_match", mrb_GLib_g_pattern_match, MRB_ARGS_ARG(g_pattern_match_REQUIRED_ARGC, g_pattern_match_OPTIONAL_ARGC));
#endif
#if BIND_g_pattern_match_simple_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_pattern_match_simple", mrb_GLib_g_pattern_match_simple, MRB_ARGS_ARG(g_pattern_match_simple_REQUIRED_ARGC, g_pattern_match_simple_OPTIONAL_ARGC));
#endif
#if BIND_g_pattern_match_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_pattern_match_string", mrb_GLib_g_pattern_match_string, MRB_ARGS_ARG(g_pattern_match_string_REQUIRED_ARGC, g_pattern_match_string_OPTIONAL_ARGC));
#endif
#if BIND_g_pattern_spec_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_pattern_spec_equal", mrb_GLib_g_pattern_spec_equal, MRB_ARGS_ARG(g_pattern_spec_equal_REQUIRED_ARGC, g_pattern_spec_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_pattern_spec_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_pattern_spec_free", mrb_GLib_g_pattern_spec_free, MRB_ARGS_ARG(g_pattern_spec_free_REQUIRED_ARGC, g_pattern_spec_free_OPTIONAL_ARGC));
#endif
#if BIND_g_pattern_spec_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_pattern_spec_new", mrb_GLib_g_pattern_spec_new, MRB_ARGS_ARG(g_pattern_spec_new_REQUIRED_ARGC, g_pattern_spec_new_OPTIONAL_ARGC));
#endif
#if BIND_g_pointer_bit_lock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_pointer_bit_lock", mrb_GLib_g_pointer_bit_lock, MRB_ARGS_ARG(g_pointer_bit_lock_REQUIRED_ARGC, g_pointer_bit_lock_OPTIONAL_ARGC));
#endif
#if BIND_g_pointer_bit_trylock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_pointer_bit_trylock", mrb_GLib_g_pointer_bit_trylock, MRB_ARGS_ARG(g_pointer_bit_trylock_REQUIRED_ARGC, g_pointer_bit_trylock_OPTIONAL_ARGC));
#endif
#if BIND_g_pointer_bit_unlock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_pointer_bit_unlock", mrb_GLib_g_pointer_bit_unlock, MRB_ARGS_ARG(g_pointer_bit_unlock_REQUIRED_ARGC, g_pointer_bit_unlock_OPTIONAL_ARGC));
#endif
#if BIND_g_poll_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_poll", mrb_GLib_g_poll, MRB_ARGS_ARG(g_poll_REQUIRED_ARGC, g_poll_OPTIONAL_ARGC));
#endif
#if BIND_g_prefix_error_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_prefix_error", mrb_GLib_g_prefix_error, MRB_ARGS_ARG(g_prefix_error_REQUIRED_ARGC, g_prefix_error_OPTIONAL_ARGC));
#endif
#if BIND_g_print_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_print", mrb_GLib_g_print, MRB_ARGS_ARG(g_print_REQUIRED_ARGC, g_print_OPTIONAL_ARGC));
#endif
#if BIND_g_printerr_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_printerr", mrb_GLib_g_printerr, MRB_ARGS_ARG(g_printerr_REQUIRED_ARGC, g_printerr_OPTIONAL_ARGC));
#endif
#if BIND_g_printf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_printf", mrb_GLib_g_printf, MRB_ARGS_ARG(g_printf_REQUIRED_ARGC, g_printf_OPTIONAL_ARGC));
#endif
#if BIND_g_printf_string_upper_bound_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_printf_string_upper_bound", mrb_GLib_g_printf_string_upper_bound, MRB_ARGS_ARG(g_printf_string_upper_bound_REQUIRED_ARGC, g_printf_string_upper_bound_OPTIONAL_ARGC));
#endif
#if BIND_g_private_get_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_private_get", mrb_GLib_g_private_get, MRB_ARGS_ARG(g_private_get_REQUIRED_ARGC, g_private_get_OPTIONAL_ARGC));
#endif
#if BIND_g_private_replace_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_private_replace", mrb_GLib_g_private_replace, MRB_ARGS_ARG(g_private_replace_REQUIRED_ARGC, g_private_replace_OPTIONAL_ARGC));
#endif
#if BIND_g_private_set_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_private_set", mrb_GLib_g_private_set, MRB_ARGS_ARG(g_private_set_REQUIRED_ARGC, g_private_set_OPTIONAL_ARGC));
#endif
#if BIND_g_propagate_error_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_propagate_error", mrb_GLib_g_propagate_error, MRB_ARGS_ARG(g_propagate_error_REQUIRED_ARGC, g_propagate_error_OPTIONAL_ARGC));
#endif
#if BIND_g_propagate_prefixed_error_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_propagate_prefixed_error", mrb_GLib_g_propagate_prefixed_error, MRB_ARGS_ARG(g_propagate_prefixed_error_REQUIRED_ARGC, g_propagate_prefixed_error_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_add", mrb_GLib_g_ptr_array_add, MRB_ARGS_ARG(g_ptr_array_add_REQUIRED_ARGC, g_ptr_array_add_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_foreach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_foreach", mrb_GLib_g_ptr_array_foreach, MRB_ARGS_ARG(g_ptr_array_foreach_REQUIRED_ARGC, g_ptr_array_foreach_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_free", mrb_GLib_g_ptr_array_free, MRB_ARGS_ARG(g_ptr_array_free_REQUIRED_ARGC, g_ptr_array_free_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_insert_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_insert", mrb_GLib_g_ptr_array_insert, MRB_ARGS_ARG(g_ptr_array_insert_REQUIRED_ARGC, g_ptr_array_insert_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_new", mrb_GLib_g_ptr_array_new, MRB_ARGS_ARG(g_ptr_array_new_REQUIRED_ARGC, g_ptr_array_new_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_new_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_new_full", mrb_GLib_g_ptr_array_new_full, MRB_ARGS_ARG(g_ptr_array_new_full_REQUIRED_ARGC, g_ptr_array_new_full_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_new_with_free_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_new_with_free_func", mrb_GLib_g_ptr_array_new_with_free_func, MRB_ARGS_ARG(g_ptr_array_new_with_free_func_REQUIRED_ARGC, g_ptr_array_new_with_free_func_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_ref", mrb_GLib_g_ptr_array_ref, MRB_ARGS_ARG(g_ptr_array_ref_REQUIRED_ARGC, g_ptr_array_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_remove", mrb_GLib_g_ptr_array_remove, MRB_ARGS_ARG(g_ptr_array_remove_REQUIRED_ARGC, g_ptr_array_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_remove_fast_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_remove_fast", mrb_GLib_g_ptr_array_remove_fast, MRB_ARGS_ARG(g_ptr_array_remove_fast_REQUIRED_ARGC, g_ptr_array_remove_fast_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_remove_index_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_remove_index", mrb_GLib_g_ptr_array_remove_index, MRB_ARGS_ARG(g_ptr_array_remove_index_REQUIRED_ARGC, g_ptr_array_remove_index_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_remove_index_fast_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_remove_index_fast", mrb_GLib_g_ptr_array_remove_index_fast, MRB_ARGS_ARG(g_ptr_array_remove_index_fast_REQUIRED_ARGC, g_ptr_array_remove_index_fast_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_remove_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_remove_range", mrb_GLib_g_ptr_array_remove_range, MRB_ARGS_ARG(g_ptr_array_remove_range_REQUIRED_ARGC, g_ptr_array_remove_range_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_set_free_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_set_free_func", mrb_GLib_g_ptr_array_set_free_func, MRB_ARGS_ARG(g_ptr_array_set_free_func_REQUIRED_ARGC, g_ptr_array_set_free_func_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_set_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_set_size", mrb_GLib_g_ptr_array_set_size, MRB_ARGS_ARG(g_ptr_array_set_size_REQUIRED_ARGC, g_ptr_array_set_size_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_sized_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_sized_new", mrb_GLib_g_ptr_array_sized_new, MRB_ARGS_ARG(g_ptr_array_sized_new_REQUIRED_ARGC, g_ptr_array_sized_new_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_sort_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_sort", mrb_GLib_g_ptr_array_sort, MRB_ARGS_ARG(g_ptr_array_sort_REQUIRED_ARGC, g_ptr_array_sort_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_sort_with_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_sort_with_data", mrb_GLib_g_ptr_array_sort_with_data, MRB_ARGS_ARG(g_ptr_array_sort_with_data_REQUIRED_ARGC, g_ptr_array_sort_with_data_OPTIONAL_ARGC));
#endif
#if BIND_g_ptr_array_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ptr_array_unref", mrb_GLib_g_ptr_array_unref, MRB_ARGS_ARG(g_ptr_array_unref_REQUIRED_ARGC, g_ptr_array_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_qsort_with_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_qsort_with_data", mrb_GLib_g_qsort_with_data, MRB_ARGS_ARG(g_qsort_with_data_REQUIRED_ARGC, g_qsort_with_data_OPTIONAL_ARGC));
#endif
#if BIND_g_quark_from_static_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_quark_from_static_string", mrb_GLib_g_quark_from_static_string, MRB_ARGS_ARG(g_quark_from_static_string_REQUIRED_ARGC, g_quark_from_static_string_OPTIONAL_ARGC));
#endif
#if BIND_g_quark_from_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_quark_from_string", mrb_GLib_g_quark_from_string, MRB_ARGS_ARG(g_quark_from_string_REQUIRED_ARGC, g_quark_from_string_OPTIONAL_ARGC));
#endif
#if BIND_g_quark_to_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_quark_to_string", mrb_GLib_g_quark_to_string, MRB_ARGS_ARG(g_quark_to_string_REQUIRED_ARGC, g_quark_to_string_OPTIONAL_ARGC));
#endif
#if BIND_g_quark_try_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_quark_try_string", mrb_GLib_g_quark_try_string, MRB_ARGS_ARG(g_quark_try_string_REQUIRED_ARGC, g_quark_try_string_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_clear", mrb_GLib_g_queue_clear, MRB_ARGS_ARG(g_queue_clear_REQUIRED_ARGC, g_queue_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_copy", mrb_GLib_g_queue_copy, MRB_ARGS_ARG(g_queue_copy_REQUIRED_ARGC, g_queue_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_delete_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_delete_link", mrb_GLib_g_queue_delete_link, MRB_ARGS_ARG(g_queue_delete_link_REQUIRED_ARGC, g_queue_delete_link_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_find_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_find", mrb_GLib_g_queue_find, MRB_ARGS_ARG(g_queue_find_REQUIRED_ARGC, g_queue_find_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_find_custom_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_find_custom", mrb_GLib_g_queue_find_custom, MRB_ARGS_ARG(g_queue_find_custom_REQUIRED_ARGC, g_queue_find_custom_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_foreach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_foreach", mrb_GLib_g_queue_foreach, MRB_ARGS_ARG(g_queue_foreach_REQUIRED_ARGC, g_queue_foreach_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_free", mrb_GLib_g_queue_free, MRB_ARGS_ARG(g_queue_free_REQUIRED_ARGC, g_queue_free_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_free_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_free_full", mrb_GLib_g_queue_free_full, MRB_ARGS_ARG(g_queue_free_full_REQUIRED_ARGC, g_queue_free_full_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_get_length_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_get_length", mrb_GLib_g_queue_get_length, MRB_ARGS_ARG(g_queue_get_length_REQUIRED_ARGC, g_queue_get_length_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_index_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_index", mrb_GLib_g_queue_index, MRB_ARGS_ARG(g_queue_index_REQUIRED_ARGC, g_queue_index_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_init", mrb_GLib_g_queue_init, MRB_ARGS_ARG(g_queue_init_REQUIRED_ARGC, g_queue_init_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_insert_after_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_insert_after", mrb_GLib_g_queue_insert_after, MRB_ARGS_ARG(g_queue_insert_after_REQUIRED_ARGC, g_queue_insert_after_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_insert_before_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_insert_before", mrb_GLib_g_queue_insert_before, MRB_ARGS_ARG(g_queue_insert_before_REQUIRED_ARGC, g_queue_insert_before_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_insert_sorted_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_insert_sorted", mrb_GLib_g_queue_insert_sorted, MRB_ARGS_ARG(g_queue_insert_sorted_REQUIRED_ARGC, g_queue_insert_sorted_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_is_empty_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_is_empty", mrb_GLib_g_queue_is_empty, MRB_ARGS_ARG(g_queue_is_empty_REQUIRED_ARGC, g_queue_is_empty_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_link_index_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_link_index", mrb_GLib_g_queue_link_index, MRB_ARGS_ARG(g_queue_link_index_REQUIRED_ARGC, g_queue_link_index_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_new", mrb_GLib_g_queue_new, MRB_ARGS_ARG(g_queue_new_REQUIRED_ARGC, g_queue_new_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_peek_head_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_peek_head", mrb_GLib_g_queue_peek_head, MRB_ARGS_ARG(g_queue_peek_head_REQUIRED_ARGC, g_queue_peek_head_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_peek_head_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_peek_head_link", mrb_GLib_g_queue_peek_head_link, MRB_ARGS_ARG(g_queue_peek_head_link_REQUIRED_ARGC, g_queue_peek_head_link_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_peek_nth_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_peek_nth", mrb_GLib_g_queue_peek_nth, MRB_ARGS_ARG(g_queue_peek_nth_REQUIRED_ARGC, g_queue_peek_nth_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_peek_nth_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_peek_nth_link", mrb_GLib_g_queue_peek_nth_link, MRB_ARGS_ARG(g_queue_peek_nth_link_REQUIRED_ARGC, g_queue_peek_nth_link_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_peek_tail_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_peek_tail", mrb_GLib_g_queue_peek_tail, MRB_ARGS_ARG(g_queue_peek_tail_REQUIRED_ARGC, g_queue_peek_tail_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_peek_tail_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_peek_tail_link", mrb_GLib_g_queue_peek_tail_link, MRB_ARGS_ARG(g_queue_peek_tail_link_REQUIRED_ARGC, g_queue_peek_tail_link_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_pop_head_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_pop_head", mrb_GLib_g_queue_pop_head, MRB_ARGS_ARG(g_queue_pop_head_REQUIRED_ARGC, g_queue_pop_head_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_pop_head_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_pop_head_link", mrb_GLib_g_queue_pop_head_link, MRB_ARGS_ARG(g_queue_pop_head_link_REQUIRED_ARGC, g_queue_pop_head_link_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_pop_nth_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_pop_nth", mrb_GLib_g_queue_pop_nth, MRB_ARGS_ARG(g_queue_pop_nth_REQUIRED_ARGC, g_queue_pop_nth_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_pop_nth_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_pop_nth_link", mrb_GLib_g_queue_pop_nth_link, MRB_ARGS_ARG(g_queue_pop_nth_link_REQUIRED_ARGC, g_queue_pop_nth_link_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_pop_tail_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_pop_tail", mrb_GLib_g_queue_pop_tail, MRB_ARGS_ARG(g_queue_pop_tail_REQUIRED_ARGC, g_queue_pop_tail_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_pop_tail_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_pop_tail_link", mrb_GLib_g_queue_pop_tail_link, MRB_ARGS_ARG(g_queue_pop_tail_link_REQUIRED_ARGC, g_queue_pop_tail_link_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_push_head_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_push_head", mrb_GLib_g_queue_push_head, MRB_ARGS_ARG(g_queue_push_head_REQUIRED_ARGC, g_queue_push_head_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_push_head_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_push_head_link", mrb_GLib_g_queue_push_head_link, MRB_ARGS_ARG(g_queue_push_head_link_REQUIRED_ARGC, g_queue_push_head_link_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_push_nth_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_push_nth", mrb_GLib_g_queue_push_nth, MRB_ARGS_ARG(g_queue_push_nth_REQUIRED_ARGC, g_queue_push_nth_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_push_nth_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_push_nth_link", mrb_GLib_g_queue_push_nth_link, MRB_ARGS_ARG(g_queue_push_nth_link_REQUIRED_ARGC, g_queue_push_nth_link_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_push_tail_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_push_tail", mrb_GLib_g_queue_push_tail, MRB_ARGS_ARG(g_queue_push_tail_REQUIRED_ARGC, g_queue_push_tail_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_push_tail_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_push_tail_link", mrb_GLib_g_queue_push_tail_link, MRB_ARGS_ARG(g_queue_push_tail_link_REQUIRED_ARGC, g_queue_push_tail_link_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_remove", mrb_GLib_g_queue_remove, MRB_ARGS_ARG(g_queue_remove_REQUIRED_ARGC, g_queue_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_remove_all_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_remove_all", mrb_GLib_g_queue_remove_all, MRB_ARGS_ARG(g_queue_remove_all_REQUIRED_ARGC, g_queue_remove_all_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_reverse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_reverse", mrb_GLib_g_queue_reverse, MRB_ARGS_ARG(g_queue_reverse_REQUIRED_ARGC, g_queue_reverse_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_sort_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_sort", mrb_GLib_g_queue_sort, MRB_ARGS_ARG(g_queue_sort_REQUIRED_ARGC, g_queue_sort_OPTIONAL_ARGC));
#endif
#if BIND_g_queue_unlink_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_queue_unlink", mrb_GLib_g_queue_unlink, MRB_ARGS_ARG(g_queue_unlink_REQUIRED_ARGC, g_queue_unlink_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_copy", mrb_GLib_g_rand_copy, MRB_ARGS_ARG(g_rand_copy_REQUIRED_ARGC, g_rand_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_double_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_double", mrb_GLib_g_rand_double, MRB_ARGS_ARG(g_rand_double_REQUIRED_ARGC, g_rand_double_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_double_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_double_range", mrb_GLib_g_rand_double_range, MRB_ARGS_ARG(g_rand_double_range_REQUIRED_ARGC, g_rand_double_range_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_free", mrb_GLib_g_rand_free, MRB_ARGS_ARG(g_rand_free_REQUIRED_ARGC, g_rand_free_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_int_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_int", mrb_GLib_g_rand_int, MRB_ARGS_ARG(g_rand_int_REQUIRED_ARGC, g_rand_int_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_int_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_int_range", mrb_GLib_g_rand_int_range, MRB_ARGS_ARG(g_rand_int_range_REQUIRED_ARGC, g_rand_int_range_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_new", mrb_GLib_g_rand_new, MRB_ARGS_ARG(g_rand_new_REQUIRED_ARGC, g_rand_new_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_new_with_seed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_new_with_seed", mrb_GLib_g_rand_new_with_seed, MRB_ARGS_ARG(g_rand_new_with_seed_REQUIRED_ARGC, g_rand_new_with_seed_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_new_with_seed_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_new_with_seed_array", mrb_GLib_g_rand_new_with_seed_array, MRB_ARGS_ARG(g_rand_new_with_seed_array_REQUIRED_ARGC, g_rand_new_with_seed_array_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_set_seed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_set_seed", mrb_GLib_g_rand_set_seed, MRB_ARGS_ARG(g_rand_set_seed_REQUIRED_ARGC, g_rand_set_seed_OPTIONAL_ARGC));
#endif
#if BIND_g_rand_set_seed_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rand_set_seed_array", mrb_GLib_g_rand_set_seed_array, MRB_ARGS_ARG(g_rand_set_seed_array_REQUIRED_ARGC, g_rand_set_seed_array_OPTIONAL_ARGC));
#endif
#if BIND_g_random_double_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_random_double", mrb_GLib_g_random_double, MRB_ARGS_ARG(g_random_double_REQUIRED_ARGC, g_random_double_OPTIONAL_ARGC));
#endif
#if BIND_g_random_double_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_random_double_range", mrb_GLib_g_random_double_range, MRB_ARGS_ARG(g_random_double_range_REQUIRED_ARGC, g_random_double_range_OPTIONAL_ARGC));
#endif
#if BIND_g_random_int_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_random_int", mrb_GLib_g_random_int, MRB_ARGS_ARG(g_random_int_REQUIRED_ARGC, g_random_int_OPTIONAL_ARGC));
#endif
#if BIND_g_random_int_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_random_int_range", mrb_GLib_g_random_int_range, MRB_ARGS_ARG(g_random_int_range_REQUIRED_ARGC, g_random_int_range_OPTIONAL_ARGC));
#endif
#if BIND_g_random_set_seed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_random_set_seed", mrb_GLib_g_random_set_seed, MRB_ARGS_ARG(g_random_set_seed_REQUIRED_ARGC, g_random_set_seed_OPTIONAL_ARGC));
#endif
#if BIND_g_realloc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_realloc", mrb_GLib_g_realloc, MRB_ARGS_ARG(g_realloc_REQUIRED_ARGC, g_realloc_OPTIONAL_ARGC));
#endif
#if BIND_g_realloc_n_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_realloc_n", mrb_GLib_g_realloc_n, MRB_ARGS_ARG(g_realloc_n_REQUIRED_ARGC, g_realloc_n_OPTIONAL_ARGC));
#endif
#if BIND_g_rec_mutex_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rec_mutex_clear", mrb_GLib_g_rec_mutex_clear, MRB_ARGS_ARG(g_rec_mutex_clear_REQUIRED_ARGC, g_rec_mutex_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_rec_mutex_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rec_mutex_init", mrb_GLib_g_rec_mutex_init, MRB_ARGS_ARG(g_rec_mutex_init_REQUIRED_ARGC, g_rec_mutex_init_OPTIONAL_ARGC));
#endif
#if BIND_g_rec_mutex_lock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rec_mutex_lock", mrb_GLib_g_rec_mutex_lock, MRB_ARGS_ARG(g_rec_mutex_lock_REQUIRED_ARGC, g_rec_mutex_lock_OPTIONAL_ARGC));
#endif
#if BIND_g_rec_mutex_trylock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rec_mutex_trylock", mrb_GLib_g_rec_mutex_trylock, MRB_ARGS_ARG(g_rec_mutex_trylock_REQUIRED_ARGC, g_rec_mutex_trylock_OPTIONAL_ARGC));
#endif
#if BIND_g_rec_mutex_unlock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rec_mutex_unlock", mrb_GLib_g_rec_mutex_unlock, MRB_ARGS_ARG(g_rec_mutex_unlock_REQUIRED_ARGC, g_rec_mutex_unlock_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_check_replacement_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_check_replacement", mrb_GLib_g_regex_check_replacement, MRB_ARGS_ARG(g_regex_check_replacement_REQUIRED_ARGC, g_regex_check_replacement_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_error_quark", mrb_GLib_g_regex_error_quark, MRB_ARGS_ARG(g_regex_error_quark_REQUIRED_ARGC, g_regex_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_escape_nul_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_escape_nul", mrb_GLib_g_regex_escape_nul, MRB_ARGS_ARG(g_regex_escape_nul_REQUIRED_ARGC, g_regex_escape_nul_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_escape_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_escape_string", mrb_GLib_g_regex_escape_string, MRB_ARGS_ARG(g_regex_escape_string_REQUIRED_ARGC, g_regex_escape_string_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_get_capture_count_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_get_capture_count", mrb_GLib_g_regex_get_capture_count, MRB_ARGS_ARG(g_regex_get_capture_count_REQUIRED_ARGC, g_regex_get_capture_count_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_get_compile_flags_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_get_compile_flags", mrb_GLib_g_regex_get_compile_flags, MRB_ARGS_ARG(g_regex_get_compile_flags_REQUIRED_ARGC, g_regex_get_compile_flags_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_get_has_cr_or_lf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_get_has_cr_or_lf", mrb_GLib_g_regex_get_has_cr_or_lf, MRB_ARGS_ARG(g_regex_get_has_cr_or_lf_REQUIRED_ARGC, g_regex_get_has_cr_or_lf_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_get_match_flags_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_get_match_flags", mrb_GLib_g_regex_get_match_flags, MRB_ARGS_ARG(g_regex_get_match_flags_REQUIRED_ARGC, g_regex_get_match_flags_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_get_max_backref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_get_max_backref", mrb_GLib_g_regex_get_max_backref, MRB_ARGS_ARG(g_regex_get_max_backref_REQUIRED_ARGC, g_regex_get_max_backref_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_get_max_lookbehind_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_get_max_lookbehind", mrb_GLib_g_regex_get_max_lookbehind, MRB_ARGS_ARG(g_regex_get_max_lookbehind_REQUIRED_ARGC, g_regex_get_max_lookbehind_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_get_pattern_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_get_pattern", mrb_GLib_g_regex_get_pattern, MRB_ARGS_ARG(g_regex_get_pattern_REQUIRED_ARGC, g_regex_get_pattern_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_get_string_number_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_get_string_number", mrb_GLib_g_regex_get_string_number, MRB_ARGS_ARG(g_regex_get_string_number_REQUIRED_ARGC, g_regex_get_string_number_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_match_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_match", mrb_GLib_g_regex_match, MRB_ARGS_ARG(g_regex_match_REQUIRED_ARGC, g_regex_match_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_match_all_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_match_all", mrb_GLib_g_regex_match_all, MRB_ARGS_ARG(g_regex_match_all_REQUIRED_ARGC, g_regex_match_all_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_match_all_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_match_all_full", mrb_GLib_g_regex_match_all_full, MRB_ARGS_ARG(g_regex_match_all_full_REQUIRED_ARGC, g_regex_match_all_full_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_match_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_match_full", mrb_GLib_g_regex_match_full, MRB_ARGS_ARG(g_regex_match_full_REQUIRED_ARGC, g_regex_match_full_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_match_simple_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_match_simple", mrb_GLib_g_regex_match_simple, MRB_ARGS_ARG(g_regex_match_simple_REQUIRED_ARGC, g_regex_match_simple_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_new", mrb_GLib_g_regex_new, MRB_ARGS_ARG(g_regex_new_REQUIRED_ARGC, g_regex_new_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_ref", mrb_GLib_g_regex_ref, MRB_ARGS_ARG(g_regex_ref_REQUIRED_ARGC, g_regex_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_replace_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_replace", mrb_GLib_g_regex_replace, MRB_ARGS_ARG(g_regex_replace_REQUIRED_ARGC, g_regex_replace_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_replace_eval_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_replace_eval", mrb_GLib_g_regex_replace_eval, MRB_ARGS_ARG(g_regex_replace_eval_REQUIRED_ARGC, g_regex_replace_eval_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_replace_literal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_replace_literal", mrb_GLib_g_regex_replace_literal, MRB_ARGS_ARG(g_regex_replace_literal_REQUIRED_ARGC, g_regex_replace_literal_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_split_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_split", mrb_GLib_g_regex_split, MRB_ARGS_ARG(g_regex_split_REQUIRED_ARGC, g_regex_split_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_split_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_split_full", mrb_GLib_g_regex_split_full, MRB_ARGS_ARG(g_regex_split_full_REQUIRED_ARGC, g_regex_split_full_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_split_simple_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_split_simple", mrb_GLib_g_regex_split_simple, MRB_ARGS_ARG(g_regex_split_simple_REQUIRED_ARGC, g_regex_split_simple_OPTIONAL_ARGC));
#endif
#if BIND_g_regex_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_regex_unref", mrb_GLib_g_regex_unref, MRB_ARGS_ARG(g_regex_unref_REQUIRED_ARGC, g_regex_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_reload_user_special_dirs_cache_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_reload_user_special_dirs_cache", mrb_GLib_g_reload_user_special_dirs_cache, MRB_ARGS_ARG(g_reload_user_special_dirs_cache_REQUIRED_ARGC, g_reload_user_special_dirs_cache_OPTIONAL_ARGC));
#endif
#if BIND_g_return_if_fail_warning_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_return_if_fail_warning", mrb_GLib_g_return_if_fail_warning, MRB_ARGS_ARG(g_return_if_fail_warning_REQUIRED_ARGC, g_return_if_fail_warning_OPTIONAL_ARGC));
#endif
#if BIND_g_rmdir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rmdir", mrb_GLib_g_rmdir, MRB_ARGS_ARG(g_rmdir_REQUIRED_ARGC, g_rmdir_OPTIONAL_ARGC));
#endif
#if BIND_g_rw_lock_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rw_lock_clear", mrb_GLib_g_rw_lock_clear, MRB_ARGS_ARG(g_rw_lock_clear_REQUIRED_ARGC, g_rw_lock_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_rw_lock_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rw_lock_init", mrb_GLib_g_rw_lock_init, MRB_ARGS_ARG(g_rw_lock_init_REQUIRED_ARGC, g_rw_lock_init_OPTIONAL_ARGC));
#endif
#if BIND_g_rw_lock_reader_lock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rw_lock_reader_lock", mrb_GLib_g_rw_lock_reader_lock, MRB_ARGS_ARG(g_rw_lock_reader_lock_REQUIRED_ARGC, g_rw_lock_reader_lock_OPTIONAL_ARGC));
#endif
#if BIND_g_rw_lock_reader_trylock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rw_lock_reader_trylock", mrb_GLib_g_rw_lock_reader_trylock, MRB_ARGS_ARG(g_rw_lock_reader_trylock_REQUIRED_ARGC, g_rw_lock_reader_trylock_OPTIONAL_ARGC));
#endif
#if BIND_g_rw_lock_reader_unlock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rw_lock_reader_unlock", mrb_GLib_g_rw_lock_reader_unlock, MRB_ARGS_ARG(g_rw_lock_reader_unlock_REQUIRED_ARGC, g_rw_lock_reader_unlock_OPTIONAL_ARGC));
#endif
#if BIND_g_rw_lock_writer_lock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rw_lock_writer_lock", mrb_GLib_g_rw_lock_writer_lock, MRB_ARGS_ARG(g_rw_lock_writer_lock_REQUIRED_ARGC, g_rw_lock_writer_lock_OPTIONAL_ARGC));
#endif
#if BIND_g_rw_lock_writer_trylock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rw_lock_writer_trylock", mrb_GLib_g_rw_lock_writer_trylock, MRB_ARGS_ARG(g_rw_lock_writer_trylock_REQUIRED_ARGC, g_rw_lock_writer_trylock_OPTIONAL_ARGC));
#endif
#if BIND_g_rw_lock_writer_unlock_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_rw_lock_writer_unlock", mrb_GLib_g_rw_lock_writer_unlock, MRB_ARGS_ARG(g_rw_lock_writer_unlock_REQUIRED_ARGC, g_rw_lock_writer_unlock_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_cur_line_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_cur_line", mrb_GLib_g_scanner_cur_line, MRB_ARGS_ARG(g_scanner_cur_line_REQUIRED_ARGC, g_scanner_cur_line_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_cur_position_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_cur_position", mrb_GLib_g_scanner_cur_position, MRB_ARGS_ARG(g_scanner_cur_position_REQUIRED_ARGC, g_scanner_cur_position_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_cur_token_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_cur_token", mrb_GLib_g_scanner_cur_token, MRB_ARGS_ARG(g_scanner_cur_token_REQUIRED_ARGC, g_scanner_cur_token_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_cur_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_cur_value", mrb_GLib_g_scanner_cur_value, MRB_ARGS_ARG(g_scanner_cur_value_REQUIRED_ARGC, g_scanner_cur_value_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_destroy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_destroy", mrb_GLib_g_scanner_destroy, MRB_ARGS_ARG(g_scanner_destroy_REQUIRED_ARGC, g_scanner_destroy_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_eof_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_eof", mrb_GLib_g_scanner_eof, MRB_ARGS_ARG(g_scanner_eof_REQUIRED_ARGC, g_scanner_eof_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_error_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_error", mrb_GLib_g_scanner_error, MRB_ARGS_ARG(g_scanner_error_REQUIRED_ARGC, g_scanner_error_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_get_next_token_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_get_next_token", mrb_GLib_g_scanner_get_next_token, MRB_ARGS_ARG(g_scanner_get_next_token_REQUIRED_ARGC, g_scanner_get_next_token_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_input_file_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_input_file", mrb_GLib_g_scanner_input_file, MRB_ARGS_ARG(g_scanner_input_file_REQUIRED_ARGC, g_scanner_input_file_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_input_text_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_input_text", mrb_GLib_g_scanner_input_text, MRB_ARGS_ARG(g_scanner_input_text_REQUIRED_ARGC, g_scanner_input_text_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_lookup_symbol_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_lookup_symbol", mrb_GLib_g_scanner_lookup_symbol, MRB_ARGS_ARG(g_scanner_lookup_symbol_REQUIRED_ARGC, g_scanner_lookup_symbol_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_new", mrb_GLib_g_scanner_new, MRB_ARGS_ARG(g_scanner_new_REQUIRED_ARGC, g_scanner_new_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_peek_next_token_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_peek_next_token", mrb_GLib_g_scanner_peek_next_token, MRB_ARGS_ARG(g_scanner_peek_next_token_REQUIRED_ARGC, g_scanner_peek_next_token_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_scope_add_symbol_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_scope_add_symbol", mrb_GLib_g_scanner_scope_add_symbol, MRB_ARGS_ARG(g_scanner_scope_add_symbol_REQUIRED_ARGC, g_scanner_scope_add_symbol_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_scope_foreach_symbol_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_scope_foreach_symbol", mrb_GLib_g_scanner_scope_foreach_symbol, MRB_ARGS_ARG(g_scanner_scope_foreach_symbol_REQUIRED_ARGC, g_scanner_scope_foreach_symbol_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_scope_lookup_symbol_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_scope_lookup_symbol", mrb_GLib_g_scanner_scope_lookup_symbol, MRB_ARGS_ARG(g_scanner_scope_lookup_symbol_REQUIRED_ARGC, g_scanner_scope_lookup_symbol_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_scope_remove_symbol_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_scope_remove_symbol", mrb_GLib_g_scanner_scope_remove_symbol, MRB_ARGS_ARG(g_scanner_scope_remove_symbol_REQUIRED_ARGC, g_scanner_scope_remove_symbol_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_set_scope_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_set_scope", mrb_GLib_g_scanner_set_scope, MRB_ARGS_ARG(g_scanner_set_scope_REQUIRED_ARGC, g_scanner_set_scope_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_sync_file_offset_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_sync_file_offset", mrb_GLib_g_scanner_sync_file_offset, MRB_ARGS_ARG(g_scanner_sync_file_offset_REQUIRED_ARGC, g_scanner_sync_file_offset_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_unexp_token_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_unexp_token", mrb_GLib_g_scanner_unexp_token, MRB_ARGS_ARG(g_scanner_unexp_token_REQUIRED_ARGC, g_scanner_unexp_token_OPTIONAL_ARGC));
#endif
#if BIND_g_scanner_warn_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_scanner_warn", mrb_GLib_g_scanner_warn, MRB_ARGS_ARG(g_scanner_warn_REQUIRED_ARGC, g_scanner_warn_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_append_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_append", mrb_GLib_g_sequence_append, MRB_ARGS_ARG(g_sequence_append_REQUIRED_ARGC, g_sequence_append_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_foreach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_foreach", mrb_GLib_g_sequence_foreach, MRB_ARGS_ARG(g_sequence_foreach_REQUIRED_ARGC, g_sequence_foreach_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_foreach_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_foreach_range", mrb_GLib_g_sequence_foreach_range, MRB_ARGS_ARG(g_sequence_foreach_range_REQUIRED_ARGC, g_sequence_foreach_range_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_free", mrb_GLib_g_sequence_free, MRB_ARGS_ARG(g_sequence_free_REQUIRED_ARGC, g_sequence_free_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_get_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_get", mrb_GLib_g_sequence_get, MRB_ARGS_ARG(g_sequence_get_REQUIRED_ARGC, g_sequence_get_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_get_begin_iter_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_get_begin_iter", mrb_GLib_g_sequence_get_begin_iter, MRB_ARGS_ARG(g_sequence_get_begin_iter_REQUIRED_ARGC, g_sequence_get_begin_iter_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_get_end_iter_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_get_end_iter", mrb_GLib_g_sequence_get_end_iter, MRB_ARGS_ARG(g_sequence_get_end_iter_REQUIRED_ARGC, g_sequence_get_end_iter_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_get_iter_at_pos_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_get_iter_at_pos", mrb_GLib_g_sequence_get_iter_at_pos, MRB_ARGS_ARG(g_sequence_get_iter_at_pos_REQUIRED_ARGC, g_sequence_get_iter_at_pos_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_get_length_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_get_length", mrb_GLib_g_sequence_get_length, MRB_ARGS_ARG(g_sequence_get_length_REQUIRED_ARGC, g_sequence_get_length_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_insert_before_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_insert_before", mrb_GLib_g_sequence_insert_before, MRB_ARGS_ARG(g_sequence_insert_before_REQUIRED_ARGC, g_sequence_insert_before_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_insert_sorted_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_insert_sorted", mrb_GLib_g_sequence_insert_sorted, MRB_ARGS_ARG(g_sequence_insert_sorted_REQUIRED_ARGC, g_sequence_insert_sorted_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_insert_sorted_iter_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_insert_sorted_iter", mrb_GLib_g_sequence_insert_sorted_iter, MRB_ARGS_ARG(g_sequence_insert_sorted_iter_REQUIRED_ARGC, g_sequence_insert_sorted_iter_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_iter_compare_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_iter_compare", mrb_GLib_g_sequence_iter_compare, MRB_ARGS_ARG(g_sequence_iter_compare_REQUIRED_ARGC, g_sequence_iter_compare_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_iter_get_position_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_iter_get_position", mrb_GLib_g_sequence_iter_get_position, MRB_ARGS_ARG(g_sequence_iter_get_position_REQUIRED_ARGC, g_sequence_iter_get_position_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_iter_get_sequence_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_iter_get_sequence", mrb_GLib_g_sequence_iter_get_sequence, MRB_ARGS_ARG(g_sequence_iter_get_sequence_REQUIRED_ARGC, g_sequence_iter_get_sequence_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_iter_is_begin_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_iter_is_begin", mrb_GLib_g_sequence_iter_is_begin, MRB_ARGS_ARG(g_sequence_iter_is_begin_REQUIRED_ARGC, g_sequence_iter_is_begin_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_iter_is_end_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_iter_is_end", mrb_GLib_g_sequence_iter_is_end, MRB_ARGS_ARG(g_sequence_iter_is_end_REQUIRED_ARGC, g_sequence_iter_is_end_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_iter_move_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_iter_move", mrb_GLib_g_sequence_iter_move, MRB_ARGS_ARG(g_sequence_iter_move_REQUIRED_ARGC, g_sequence_iter_move_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_iter_next_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_iter_next", mrb_GLib_g_sequence_iter_next, MRB_ARGS_ARG(g_sequence_iter_next_REQUIRED_ARGC, g_sequence_iter_next_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_iter_prev_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_iter_prev", mrb_GLib_g_sequence_iter_prev, MRB_ARGS_ARG(g_sequence_iter_prev_REQUIRED_ARGC, g_sequence_iter_prev_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_lookup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_lookup", mrb_GLib_g_sequence_lookup, MRB_ARGS_ARG(g_sequence_lookup_REQUIRED_ARGC, g_sequence_lookup_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_lookup_iter_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_lookup_iter", mrb_GLib_g_sequence_lookup_iter, MRB_ARGS_ARG(g_sequence_lookup_iter_REQUIRED_ARGC, g_sequence_lookup_iter_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_move_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_move", mrb_GLib_g_sequence_move, MRB_ARGS_ARG(g_sequence_move_REQUIRED_ARGC, g_sequence_move_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_move_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_move_range", mrb_GLib_g_sequence_move_range, MRB_ARGS_ARG(g_sequence_move_range_REQUIRED_ARGC, g_sequence_move_range_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_new", mrb_GLib_g_sequence_new, MRB_ARGS_ARG(g_sequence_new_REQUIRED_ARGC, g_sequence_new_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_prepend_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_prepend", mrb_GLib_g_sequence_prepend, MRB_ARGS_ARG(g_sequence_prepend_REQUIRED_ARGC, g_sequence_prepend_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_range_get_midpoint_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_range_get_midpoint", mrb_GLib_g_sequence_range_get_midpoint, MRB_ARGS_ARG(g_sequence_range_get_midpoint_REQUIRED_ARGC, g_sequence_range_get_midpoint_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_remove", mrb_GLib_g_sequence_remove, MRB_ARGS_ARG(g_sequence_remove_REQUIRED_ARGC, g_sequence_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_remove_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_remove_range", mrb_GLib_g_sequence_remove_range, MRB_ARGS_ARG(g_sequence_remove_range_REQUIRED_ARGC, g_sequence_remove_range_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_search_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_search", mrb_GLib_g_sequence_search, MRB_ARGS_ARG(g_sequence_search_REQUIRED_ARGC, g_sequence_search_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_search_iter_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_search_iter", mrb_GLib_g_sequence_search_iter, MRB_ARGS_ARG(g_sequence_search_iter_REQUIRED_ARGC, g_sequence_search_iter_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_set_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_set", mrb_GLib_g_sequence_set, MRB_ARGS_ARG(g_sequence_set_REQUIRED_ARGC, g_sequence_set_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_sort_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_sort", mrb_GLib_g_sequence_sort, MRB_ARGS_ARG(g_sequence_sort_REQUIRED_ARGC, g_sequence_sort_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_sort_changed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_sort_changed", mrb_GLib_g_sequence_sort_changed, MRB_ARGS_ARG(g_sequence_sort_changed_REQUIRED_ARGC, g_sequence_sort_changed_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_sort_changed_iter_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_sort_changed_iter", mrb_GLib_g_sequence_sort_changed_iter, MRB_ARGS_ARG(g_sequence_sort_changed_iter_REQUIRED_ARGC, g_sequence_sort_changed_iter_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_sort_iter_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_sort_iter", mrb_GLib_g_sequence_sort_iter, MRB_ARGS_ARG(g_sequence_sort_iter_REQUIRED_ARGC, g_sequence_sort_iter_OPTIONAL_ARGC));
#endif
#if BIND_g_sequence_swap_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sequence_swap", mrb_GLib_g_sequence_swap, MRB_ARGS_ARG(g_sequence_swap_REQUIRED_ARGC, g_sequence_swap_OPTIONAL_ARGC));
#endif
#if BIND_g_set_application_name_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_set_application_name", mrb_GLib_g_set_application_name, MRB_ARGS_ARG(g_set_application_name_REQUIRED_ARGC, g_set_application_name_OPTIONAL_ARGC));
#endif
#if BIND_g_set_error_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_set_error", mrb_GLib_g_set_error, MRB_ARGS_ARG(g_set_error_REQUIRED_ARGC, g_set_error_OPTIONAL_ARGC));
#endif
#if BIND_g_set_error_literal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_set_error_literal", mrb_GLib_g_set_error_literal, MRB_ARGS_ARG(g_set_error_literal_REQUIRED_ARGC, g_set_error_literal_OPTIONAL_ARGC));
#endif
#if BIND_g_set_prgname_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_set_prgname", mrb_GLib_g_set_prgname, MRB_ARGS_ARG(g_set_prgname_REQUIRED_ARGC, g_set_prgname_OPTIONAL_ARGC));
#endif
#if BIND_g_set_print_handler_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_set_print_handler", mrb_GLib_g_set_print_handler, MRB_ARGS_ARG(g_set_print_handler_REQUIRED_ARGC, g_set_print_handler_OPTIONAL_ARGC));
#endif
#if BIND_g_set_printerr_handler_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_set_printerr_handler", mrb_GLib_g_set_printerr_handler, MRB_ARGS_ARG(g_set_printerr_handler_REQUIRED_ARGC, g_set_printerr_handler_OPTIONAL_ARGC));
#endif
#if BIND_g_setenv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_setenv", mrb_GLib_g_setenv, MRB_ARGS_ARG(g_setenv_REQUIRED_ARGC, g_setenv_OPTIONAL_ARGC));
#endif
#if BIND_g_shell_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_shell_error_quark", mrb_GLib_g_shell_error_quark, MRB_ARGS_ARG(g_shell_error_quark_REQUIRED_ARGC, g_shell_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_shell_parse_argv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_shell_parse_argv", mrb_GLib_g_shell_parse_argv, MRB_ARGS_ARG(g_shell_parse_argv_REQUIRED_ARGC, g_shell_parse_argv_OPTIONAL_ARGC));
#endif
#if BIND_g_shell_quote_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_shell_quote", mrb_GLib_g_shell_quote, MRB_ARGS_ARG(g_shell_quote_REQUIRED_ARGC, g_shell_quote_OPTIONAL_ARGC));
#endif
#if BIND_g_shell_unquote_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_shell_unquote", mrb_GLib_g_shell_unquote, MRB_ARGS_ARG(g_shell_unquote_REQUIRED_ARGC, g_shell_unquote_OPTIONAL_ARGC));
#endif
#if BIND_g_slice_alloc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slice_alloc", mrb_GLib_g_slice_alloc, MRB_ARGS_ARG(g_slice_alloc_REQUIRED_ARGC, g_slice_alloc_OPTIONAL_ARGC));
#endif
#if BIND_g_slice_alloc0_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slice_alloc0", mrb_GLib_g_slice_alloc0, MRB_ARGS_ARG(g_slice_alloc0_REQUIRED_ARGC, g_slice_alloc0_OPTIONAL_ARGC));
#endif
#if BIND_g_slice_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slice_copy", mrb_GLib_g_slice_copy, MRB_ARGS_ARG(g_slice_copy_REQUIRED_ARGC, g_slice_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_slice_free1_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slice_free1", mrb_GLib_g_slice_free1, MRB_ARGS_ARG(g_slice_free1_REQUIRED_ARGC, g_slice_free1_OPTIONAL_ARGC));
#endif
#if BIND_g_slice_free_chain_with_offset_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slice_free_chain_with_offset", mrb_GLib_g_slice_free_chain_with_offset, MRB_ARGS_ARG(g_slice_free_chain_with_offset_REQUIRED_ARGC, g_slice_free_chain_with_offset_OPTIONAL_ARGC));
#endif
#if BIND_g_slice_get_config_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slice_get_config", mrb_GLib_g_slice_get_config, MRB_ARGS_ARG(g_slice_get_config_REQUIRED_ARGC, g_slice_get_config_OPTIONAL_ARGC));
#endif
#if BIND_g_slice_get_config_state_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slice_get_config_state", mrb_GLib_g_slice_get_config_state, MRB_ARGS_ARG(g_slice_get_config_state_REQUIRED_ARGC, g_slice_get_config_state_OPTIONAL_ARGC));
#endif
#if BIND_g_slice_set_config_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slice_set_config", mrb_GLib_g_slice_set_config, MRB_ARGS_ARG(g_slice_set_config_REQUIRED_ARGC, g_slice_set_config_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_alloc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_alloc", mrb_GLib_g_slist_alloc, MRB_ARGS_ARG(g_slist_alloc_REQUIRED_ARGC, g_slist_alloc_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_append_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_append", mrb_GLib_g_slist_append, MRB_ARGS_ARG(g_slist_append_REQUIRED_ARGC, g_slist_append_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_concat_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_concat", mrb_GLib_g_slist_concat, MRB_ARGS_ARG(g_slist_concat_REQUIRED_ARGC, g_slist_concat_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_copy", mrb_GLib_g_slist_copy, MRB_ARGS_ARG(g_slist_copy_REQUIRED_ARGC, g_slist_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_copy_deep_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_copy_deep", mrb_GLib_g_slist_copy_deep, MRB_ARGS_ARG(g_slist_copy_deep_REQUIRED_ARGC, g_slist_copy_deep_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_delete_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_delete_link", mrb_GLib_g_slist_delete_link, MRB_ARGS_ARG(g_slist_delete_link_REQUIRED_ARGC, g_slist_delete_link_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_find_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_find", mrb_GLib_g_slist_find, MRB_ARGS_ARG(g_slist_find_REQUIRED_ARGC, g_slist_find_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_find_custom_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_find_custom", mrb_GLib_g_slist_find_custom, MRB_ARGS_ARG(g_slist_find_custom_REQUIRED_ARGC, g_slist_find_custom_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_foreach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_foreach", mrb_GLib_g_slist_foreach, MRB_ARGS_ARG(g_slist_foreach_REQUIRED_ARGC, g_slist_foreach_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_free", mrb_GLib_g_slist_free, MRB_ARGS_ARG(g_slist_free_REQUIRED_ARGC, g_slist_free_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_free_1_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_free_1", mrb_GLib_g_slist_free_1, MRB_ARGS_ARG(g_slist_free_1_REQUIRED_ARGC, g_slist_free_1_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_free_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_free_full", mrb_GLib_g_slist_free_full, MRB_ARGS_ARG(g_slist_free_full_REQUIRED_ARGC, g_slist_free_full_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_index_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_index", mrb_GLib_g_slist_index, MRB_ARGS_ARG(g_slist_index_REQUIRED_ARGC, g_slist_index_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_insert_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_insert", mrb_GLib_g_slist_insert, MRB_ARGS_ARG(g_slist_insert_REQUIRED_ARGC, g_slist_insert_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_insert_before_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_insert_before", mrb_GLib_g_slist_insert_before, MRB_ARGS_ARG(g_slist_insert_before_REQUIRED_ARGC, g_slist_insert_before_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_insert_sorted_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_insert_sorted", mrb_GLib_g_slist_insert_sorted, MRB_ARGS_ARG(g_slist_insert_sorted_REQUIRED_ARGC, g_slist_insert_sorted_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_insert_sorted_with_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_insert_sorted_with_data", mrb_GLib_g_slist_insert_sorted_with_data, MRB_ARGS_ARG(g_slist_insert_sorted_with_data_REQUIRED_ARGC, g_slist_insert_sorted_with_data_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_last_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_last", mrb_GLib_g_slist_last, MRB_ARGS_ARG(g_slist_last_REQUIRED_ARGC, g_slist_last_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_length_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_length", mrb_GLib_g_slist_length, MRB_ARGS_ARG(g_slist_length_REQUIRED_ARGC, g_slist_length_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_nth_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_nth", mrb_GLib_g_slist_nth, MRB_ARGS_ARG(g_slist_nth_REQUIRED_ARGC, g_slist_nth_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_nth_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_nth_data", mrb_GLib_g_slist_nth_data, MRB_ARGS_ARG(g_slist_nth_data_REQUIRED_ARGC, g_slist_nth_data_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_position_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_position", mrb_GLib_g_slist_position, MRB_ARGS_ARG(g_slist_position_REQUIRED_ARGC, g_slist_position_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_prepend_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_prepend", mrb_GLib_g_slist_prepend, MRB_ARGS_ARG(g_slist_prepend_REQUIRED_ARGC, g_slist_prepend_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_remove", mrb_GLib_g_slist_remove, MRB_ARGS_ARG(g_slist_remove_REQUIRED_ARGC, g_slist_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_remove_all_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_remove_all", mrb_GLib_g_slist_remove_all, MRB_ARGS_ARG(g_slist_remove_all_REQUIRED_ARGC, g_slist_remove_all_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_remove_link_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_remove_link", mrb_GLib_g_slist_remove_link, MRB_ARGS_ARG(g_slist_remove_link_REQUIRED_ARGC, g_slist_remove_link_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_reverse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_reverse", mrb_GLib_g_slist_reverse, MRB_ARGS_ARG(g_slist_reverse_REQUIRED_ARGC, g_slist_reverse_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_sort_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_sort", mrb_GLib_g_slist_sort, MRB_ARGS_ARG(g_slist_sort_REQUIRED_ARGC, g_slist_sort_OPTIONAL_ARGC));
#endif
#if BIND_g_slist_sort_with_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_slist_sort_with_data", mrb_GLib_g_slist_sort_with_data, MRB_ARGS_ARG(g_slist_sort_with_data_REQUIRED_ARGC, g_slist_sort_with_data_OPTIONAL_ARGC));
#endif
#if BIND_g_snprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_snprintf", mrb_GLib_g_snprintf, MRB_ARGS_ARG(g_snprintf_REQUIRED_ARGC, g_snprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_source_add_child_source_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_add_child_source", mrb_GLib_g_source_add_child_source, MRB_ARGS_ARG(g_source_add_child_source_REQUIRED_ARGC, g_source_add_child_source_OPTIONAL_ARGC));
#endif
#if BIND_g_source_add_poll_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_add_poll", mrb_GLib_g_source_add_poll, MRB_ARGS_ARG(g_source_add_poll_REQUIRED_ARGC, g_source_add_poll_OPTIONAL_ARGC));
#endif
#if BIND_g_source_add_unix_fd_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_add_unix_fd", mrb_GLib_g_source_add_unix_fd, MRB_ARGS_ARG(g_source_add_unix_fd_REQUIRED_ARGC, g_source_add_unix_fd_OPTIONAL_ARGC));
#endif
#if BIND_g_source_attach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_attach", mrb_GLib_g_source_attach, MRB_ARGS_ARG(g_source_attach_REQUIRED_ARGC, g_source_attach_OPTIONAL_ARGC));
#endif
#if BIND_g_source_destroy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_destroy", mrb_GLib_g_source_destroy, MRB_ARGS_ARG(g_source_destroy_REQUIRED_ARGC, g_source_destroy_OPTIONAL_ARGC));
#endif
#if BIND_g_source_get_can_recurse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_get_can_recurse", mrb_GLib_g_source_get_can_recurse, MRB_ARGS_ARG(g_source_get_can_recurse_REQUIRED_ARGC, g_source_get_can_recurse_OPTIONAL_ARGC));
#endif
#if BIND_g_source_get_context_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_get_context", mrb_GLib_g_source_get_context, MRB_ARGS_ARG(g_source_get_context_REQUIRED_ARGC, g_source_get_context_OPTIONAL_ARGC));
#endif
#if BIND_g_source_get_current_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_get_current_time", mrb_GLib_g_source_get_current_time, MRB_ARGS_ARG(g_source_get_current_time_REQUIRED_ARGC, g_source_get_current_time_OPTIONAL_ARGC));
#endif
#if BIND_g_source_get_id_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_get_id", mrb_GLib_g_source_get_id, MRB_ARGS_ARG(g_source_get_id_REQUIRED_ARGC, g_source_get_id_OPTIONAL_ARGC));
#endif
#if BIND_g_source_get_name_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_get_name", mrb_GLib_g_source_get_name, MRB_ARGS_ARG(g_source_get_name_REQUIRED_ARGC, g_source_get_name_OPTIONAL_ARGC));
#endif
#if BIND_g_source_get_priority_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_get_priority", mrb_GLib_g_source_get_priority, MRB_ARGS_ARG(g_source_get_priority_REQUIRED_ARGC, g_source_get_priority_OPTIONAL_ARGC));
#endif
#if BIND_g_source_get_ready_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_get_ready_time", mrb_GLib_g_source_get_ready_time, MRB_ARGS_ARG(g_source_get_ready_time_REQUIRED_ARGC, g_source_get_ready_time_OPTIONAL_ARGC));
#endif
#if BIND_g_source_get_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_get_time", mrb_GLib_g_source_get_time, MRB_ARGS_ARG(g_source_get_time_REQUIRED_ARGC, g_source_get_time_OPTIONAL_ARGC));
#endif
#if BIND_g_source_is_destroyed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_is_destroyed", mrb_GLib_g_source_is_destroyed, MRB_ARGS_ARG(g_source_is_destroyed_REQUIRED_ARGC, g_source_is_destroyed_OPTIONAL_ARGC));
#endif
#if BIND_g_source_modify_unix_fd_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_modify_unix_fd", mrb_GLib_g_source_modify_unix_fd, MRB_ARGS_ARG(g_source_modify_unix_fd_REQUIRED_ARGC, g_source_modify_unix_fd_OPTIONAL_ARGC));
#endif
#if BIND_g_source_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_new", mrb_GLib_g_source_new, MRB_ARGS_ARG(g_source_new_REQUIRED_ARGC, g_source_new_OPTIONAL_ARGC));
#endif
#if BIND_g_source_query_unix_fd_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_query_unix_fd", mrb_GLib_g_source_query_unix_fd, MRB_ARGS_ARG(g_source_query_unix_fd_REQUIRED_ARGC, g_source_query_unix_fd_OPTIONAL_ARGC));
#endif
#if BIND_g_source_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_ref", mrb_GLib_g_source_ref, MRB_ARGS_ARG(g_source_ref_REQUIRED_ARGC, g_source_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_source_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_remove", mrb_GLib_g_source_remove, MRB_ARGS_ARG(g_source_remove_REQUIRED_ARGC, g_source_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_source_remove_by_funcs_user_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_remove_by_funcs_user_data", mrb_GLib_g_source_remove_by_funcs_user_data, MRB_ARGS_ARG(g_source_remove_by_funcs_user_data_REQUIRED_ARGC, g_source_remove_by_funcs_user_data_OPTIONAL_ARGC));
#endif
#if BIND_g_source_remove_by_user_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_remove_by_user_data", mrb_GLib_g_source_remove_by_user_data, MRB_ARGS_ARG(g_source_remove_by_user_data_REQUIRED_ARGC, g_source_remove_by_user_data_OPTIONAL_ARGC));
#endif
#if BIND_g_source_remove_child_source_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_remove_child_source", mrb_GLib_g_source_remove_child_source, MRB_ARGS_ARG(g_source_remove_child_source_REQUIRED_ARGC, g_source_remove_child_source_OPTIONAL_ARGC));
#endif
#if BIND_g_source_remove_poll_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_remove_poll", mrb_GLib_g_source_remove_poll, MRB_ARGS_ARG(g_source_remove_poll_REQUIRED_ARGC, g_source_remove_poll_OPTIONAL_ARGC));
#endif
#if BIND_g_source_remove_unix_fd_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_remove_unix_fd", mrb_GLib_g_source_remove_unix_fd, MRB_ARGS_ARG(g_source_remove_unix_fd_REQUIRED_ARGC, g_source_remove_unix_fd_OPTIONAL_ARGC));
#endif
#if BIND_g_source_set_callback_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_set_callback", mrb_GLib_g_source_set_callback, MRB_ARGS_ARG(g_source_set_callback_REQUIRED_ARGC, g_source_set_callback_OPTIONAL_ARGC));
#endif
#if BIND_g_source_set_callback_indirect_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_set_callback_indirect", mrb_GLib_g_source_set_callback_indirect, MRB_ARGS_ARG(g_source_set_callback_indirect_REQUIRED_ARGC, g_source_set_callback_indirect_OPTIONAL_ARGC));
#endif
#if BIND_g_source_set_can_recurse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_set_can_recurse", mrb_GLib_g_source_set_can_recurse, MRB_ARGS_ARG(g_source_set_can_recurse_REQUIRED_ARGC, g_source_set_can_recurse_OPTIONAL_ARGC));
#endif
#if BIND_g_source_set_funcs_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_set_funcs", mrb_GLib_g_source_set_funcs, MRB_ARGS_ARG(g_source_set_funcs_REQUIRED_ARGC, g_source_set_funcs_OPTIONAL_ARGC));
#endif
#if BIND_g_source_set_name_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_set_name", mrb_GLib_g_source_set_name, MRB_ARGS_ARG(g_source_set_name_REQUIRED_ARGC, g_source_set_name_OPTIONAL_ARGC));
#endif
#if BIND_g_source_set_name_by_id_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_set_name_by_id", mrb_GLib_g_source_set_name_by_id, MRB_ARGS_ARG(g_source_set_name_by_id_REQUIRED_ARGC, g_source_set_name_by_id_OPTIONAL_ARGC));
#endif
#if BIND_g_source_set_priority_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_set_priority", mrb_GLib_g_source_set_priority, MRB_ARGS_ARG(g_source_set_priority_REQUIRED_ARGC, g_source_set_priority_OPTIONAL_ARGC));
#endif
#if BIND_g_source_set_ready_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_set_ready_time", mrb_GLib_g_source_set_ready_time, MRB_ARGS_ARG(g_source_set_ready_time_REQUIRED_ARGC, g_source_set_ready_time_OPTIONAL_ARGC));
#endif
#if BIND_g_source_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_source_unref", mrb_GLib_g_source_unref, MRB_ARGS_ARG(g_source_unref_REQUIRED_ARGC, g_source_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_spaced_primes_closest_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_spaced_primes_closest", mrb_GLib_g_spaced_primes_closest, MRB_ARGS_ARG(g_spaced_primes_closest_REQUIRED_ARGC, g_spaced_primes_closest_OPTIONAL_ARGC));
#endif
#if BIND_g_spawn_async_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_spawn_async", mrb_GLib_g_spawn_async, MRB_ARGS_ARG(g_spawn_async_REQUIRED_ARGC, g_spawn_async_OPTIONAL_ARGC));
#endif
#if BIND_g_spawn_async_with_pipes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_spawn_async_with_pipes", mrb_GLib_g_spawn_async_with_pipes, MRB_ARGS_ARG(g_spawn_async_with_pipes_REQUIRED_ARGC, g_spawn_async_with_pipes_OPTIONAL_ARGC));
#endif
#if BIND_g_spawn_check_exit_status_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_spawn_check_exit_status", mrb_GLib_g_spawn_check_exit_status, MRB_ARGS_ARG(g_spawn_check_exit_status_REQUIRED_ARGC, g_spawn_check_exit_status_OPTIONAL_ARGC));
#endif
#if BIND_g_spawn_close_pid_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_spawn_close_pid", mrb_GLib_g_spawn_close_pid, MRB_ARGS_ARG(g_spawn_close_pid_REQUIRED_ARGC, g_spawn_close_pid_OPTIONAL_ARGC));
#endif
#if BIND_g_spawn_command_line_async_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_spawn_command_line_async", mrb_GLib_g_spawn_command_line_async, MRB_ARGS_ARG(g_spawn_command_line_async_REQUIRED_ARGC, g_spawn_command_line_async_OPTIONAL_ARGC));
#endif
#if BIND_g_spawn_command_line_sync_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_spawn_command_line_sync", mrb_GLib_g_spawn_command_line_sync, MRB_ARGS_ARG(g_spawn_command_line_sync_REQUIRED_ARGC, g_spawn_command_line_sync_OPTIONAL_ARGC));
#endif
#if BIND_g_spawn_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_spawn_error_quark", mrb_GLib_g_spawn_error_quark, MRB_ARGS_ARG(g_spawn_error_quark_REQUIRED_ARGC, g_spawn_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_spawn_exit_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_spawn_exit_error_quark", mrb_GLib_g_spawn_exit_error_quark, MRB_ARGS_ARG(g_spawn_exit_error_quark_REQUIRED_ARGC, g_spawn_exit_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_spawn_sync_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_spawn_sync", mrb_GLib_g_spawn_sync, MRB_ARGS_ARG(g_spawn_sync_REQUIRED_ARGC, g_spawn_sync_OPTIONAL_ARGC));
#endif
#if BIND_g_sprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_sprintf", mrb_GLib_g_sprintf, MRB_ARGS_ARG(g_sprintf_REQUIRED_ARGC, g_sprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_steal_pointer_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_steal_pointer", mrb_GLib_g_steal_pointer, MRB_ARGS_ARG(g_steal_pointer_REQUIRED_ARGC, g_steal_pointer_OPTIONAL_ARGC));
#endif
#if BIND_g_stpcpy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_stpcpy", mrb_GLib_g_stpcpy, MRB_ARGS_ARG(g_stpcpy_REQUIRED_ARGC, g_stpcpy_OPTIONAL_ARGC));
#endif
#if BIND_g_str_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_str_equal", mrb_GLib_g_str_equal, MRB_ARGS_ARG(g_str_equal_REQUIRED_ARGC, g_str_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_str_has_prefix_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_str_has_prefix", mrb_GLib_g_str_has_prefix, MRB_ARGS_ARG(g_str_has_prefix_REQUIRED_ARGC, g_str_has_prefix_OPTIONAL_ARGC));
#endif
#if BIND_g_str_has_suffix_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_str_has_suffix", mrb_GLib_g_str_has_suffix, MRB_ARGS_ARG(g_str_has_suffix_REQUIRED_ARGC, g_str_has_suffix_OPTIONAL_ARGC));
#endif
#if BIND_g_str_hash_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_str_hash", mrb_GLib_g_str_hash, MRB_ARGS_ARG(g_str_hash_REQUIRED_ARGC, g_str_hash_OPTIONAL_ARGC));
#endif
#if BIND_g_str_is_ascii_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_str_is_ascii", mrb_GLib_g_str_is_ascii, MRB_ARGS_ARG(g_str_is_ascii_REQUIRED_ARGC, g_str_is_ascii_OPTIONAL_ARGC));
#endif
#if BIND_g_str_match_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_str_match_string", mrb_GLib_g_str_match_string, MRB_ARGS_ARG(g_str_match_string_REQUIRED_ARGC, g_str_match_string_OPTIONAL_ARGC));
#endif
#if BIND_g_str_to_ascii_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_str_to_ascii", mrb_GLib_g_str_to_ascii, MRB_ARGS_ARG(g_str_to_ascii_REQUIRED_ARGC, g_str_to_ascii_OPTIONAL_ARGC));
#endif
#if BIND_g_str_tokenize_and_fold_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_str_tokenize_and_fold", mrb_GLib_g_str_tokenize_and_fold, MRB_ARGS_ARG(g_str_tokenize_and_fold_REQUIRED_ARGC, g_str_tokenize_and_fold_OPTIONAL_ARGC));
#endif
#if BIND_g_strcanon_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strcanon", mrb_GLib_g_strcanon, MRB_ARGS_ARG(g_strcanon_REQUIRED_ARGC, g_strcanon_OPTIONAL_ARGC));
#endif
#if BIND_g_strcasecmp_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strcasecmp", mrb_GLib_g_strcasecmp, MRB_ARGS_ARG(g_strcasecmp_REQUIRED_ARGC, g_strcasecmp_OPTIONAL_ARGC));
#endif
#if BIND_g_strchomp_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strchomp", mrb_GLib_g_strchomp, MRB_ARGS_ARG(g_strchomp_REQUIRED_ARGC, g_strchomp_OPTIONAL_ARGC));
#endif
#if BIND_g_strchug_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strchug", mrb_GLib_g_strchug, MRB_ARGS_ARG(g_strchug_REQUIRED_ARGC, g_strchug_OPTIONAL_ARGC));
#endif
#if BIND_g_strcmp0_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strcmp0", mrb_GLib_g_strcmp0, MRB_ARGS_ARG(g_strcmp0_REQUIRED_ARGC, g_strcmp0_OPTIONAL_ARGC));
#endif
#if BIND_g_strcompress_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strcompress", mrb_GLib_g_strcompress, MRB_ARGS_ARG(g_strcompress_REQUIRED_ARGC, g_strcompress_OPTIONAL_ARGC));
#endif
#if BIND_g_strconcat_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strconcat", mrb_GLib_g_strconcat, MRB_ARGS_ARG(g_strconcat_REQUIRED_ARGC, g_strconcat_OPTIONAL_ARGC));
#endif
#if BIND_g_strdelimit_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strdelimit", mrb_GLib_g_strdelimit, MRB_ARGS_ARG(g_strdelimit_REQUIRED_ARGC, g_strdelimit_OPTIONAL_ARGC));
#endif
#if BIND_g_strdown_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strdown", mrb_GLib_g_strdown, MRB_ARGS_ARG(g_strdown_REQUIRED_ARGC, g_strdown_OPTIONAL_ARGC));
#endif
#if BIND_g_strdup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strdup", mrb_GLib_g_strdup, MRB_ARGS_ARG(g_strdup_REQUIRED_ARGC, g_strdup_OPTIONAL_ARGC));
#endif
#if BIND_g_strdup_printf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strdup_printf", mrb_GLib_g_strdup_printf, MRB_ARGS_ARG(g_strdup_printf_REQUIRED_ARGC, g_strdup_printf_OPTIONAL_ARGC));
#endif
#if BIND_g_strdup_vprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strdup_vprintf", mrb_GLib_g_strdup_vprintf, MRB_ARGS_ARG(g_strdup_vprintf_REQUIRED_ARGC, g_strdup_vprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_strdupv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strdupv", mrb_GLib_g_strdupv, MRB_ARGS_ARG(g_strdupv_REQUIRED_ARGC, g_strdupv_OPTIONAL_ARGC));
#endif
#if BIND_g_strerror_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strerror", mrb_GLib_g_strerror, MRB_ARGS_ARG(g_strerror_REQUIRED_ARGC, g_strerror_OPTIONAL_ARGC));
#endif
#if BIND_g_strescape_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strescape", mrb_GLib_g_strescape, MRB_ARGS_ARG(g_strescape_REQUIRED_ARGC, g_strescape_OPTIONAL_ARGC));
#endif
#if BIND_g_strfreev_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strfreev", mrb_GLib_g_strfreev, MRB_ARGS_ARG(g_strfreev_REQUIRED_ARGC, g_strfreev_OPTIONAL_ARGC));
#endif
#if BIND_g_string_append_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_append", mrb_GLib_g_string_append, MRB_ARGS_ARG(g_string_append_REQUIRED_ARGC, g_string_append_OPTIONAL_ARGC));
#endif
#if BIND_g_string_append_c_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_append_c", mrb_GLib_g_string_append_c, MRB_ARGS_ARG(g_string_append_c_REQUIRED_ARGC, g_string_append_c_OPTIONAL_ARGC));
#endif
#if BIND_g_string_append_c_inline_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_append_c_inline", mrb_GLib_g_string_append_c_inline, MRB_ARGS_ARG(g_string_append_c_inline_REQUIRED_ARGC, g_string_append_c_inline_OPTIONAL_ARGC));
#endif
#if BIND_g_string_append_len_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_append_len", mrb_GLib_g_string_append_len, MRB_ARGS_ARG(g_string_append_len_REQUIRED_ARGC, g_string_append_len_OPTIONAL_ARGC));
#endif
#if BIND_g_string_append_printf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_append_printf", mrb_GLib_g_string_append_printf, MRB_ARGS_ARG(g_string_append_printf_REQUIRED_ARGC, g_string_append_printf_OPTIONAL_ARGC));
#endif
#if BIND_g_string_append_unichar_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_append_unichar", mrb_GLib_g_string_append_unichar, MRB_ARGS_ARG(g_string_append_unichar_REQUIRED_ARGC, g_string_append_unichar_OPTIONAL_ARGC));
#endif
#if BIND_g_string_append_uri_escaped_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_append_uri_escaped", mrb_GLib_g_string_append_uri_escaped, MRB_ARGS_ARG(g_string_append_uri_escaped_REQUIRED_ARGC, g_string_append_uri_escaped_OPTIONAL_ARGC));
#endif
#if BIND_g_string_append_vprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_append_vprintf", mrb_GLib_g_string_append_vprintf, MRB_ARGS_ARG(g_string_append_vprintf_REQUIRED_ARGC, g_string_append_vprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_string_ascii_down_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_ascii_down", mrb_GLib_g_string_ascii_down, MRB_ARGS_ARG(g_string_ascii_down_REQUIRED_ARGC, g_string_ascii_down_OPTIONAL_ARGC));
#endif
#if BIND_g_string_ascii_up_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_ascii_up", mrb_GLib_g_string_ascii_up, MRB_ARGS_ARG(g_string_ascii_up_REQUIRED_ARGC, g_string_ascii_up_OPTIONAL_ARGC));
#endif
#if BIND_g_string_assign_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_assign", mrb_GLib_g_string_assign, MRB_ARGS_ARG(g_string_assign_REQUIRED_ARGC, g_string_assign_OPTIONAL_ARGC));
#endif
#if BIND_g_string_chunk_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_chunk_clear", mrb_GLib_g_string_chunk_clear, MRB_ARGS_ARG(g_string_chunk_clear_REQUIRED_ARGC, g_string_chunk_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_string_chunk_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_chunk_free", mrb_GLib_g_string_chunk_free, MRB_ARGS_ARG(g_string_chunk_free_REQUIRED_ARGC, g_string_chunk_free_OPTIONAL_ARGC));
#endif
#if BIND_g_string_chunk_insert_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_chunk_insert", mrb_GLib_g_string_chunk_insert, MRB_ARGS_ARG(g_string_chunk_insert_REQUIRED_ARGC, g_string_chunk_insert_OPTIONAL_ARGC));
#endif
#if BIND_g_string_chunk_insert_const_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_chunk_insert_const", mrb_GLib_g_string_chunk_insert_const, MRB_ARGS_ARG(g_string_chunk_insert_const_REQUIRED_ARGC, g_string_chunk_insert_const_OPTIONAL_ARGC));
#endif
#if BIND_g_string_chunk_insert_len_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_chunk_insert_len", mrb_GLib_g_string_chunk_insert_len, MRB_ARGS_ARG(g_string_chunk_insert_len_REQUIRED_ARGC, g_string_chunk_insert_len_OPTIONAL_ARGC));
#endif
#if BIND_g_string_chunk_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_chunk_new", mrb_GLib_g_string_chunk_new, MRB_ARGS_ARG(g_string_chunk_new_REQUIRED_ARGC, g_string_chunk_new_OPTIONAL_ARGC));
#endif
#if BIND_g_string_down_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_down", mrb_GLib_g_string_down, MRB_ARGS_ARG(g_string_down_REQUIRED_ARGC, g_string_down_OPTIONAL_ARGC));
#endif
#if BIND_g_string_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_equal", mrb_GLib_g_string_equal, MRB_ARGS_ARG(g_string_equal_REQUIRED_ARGC, g_string_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_string_erase_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_erase", mrb_GLib_g_string_erase, MRB_ARGS_ARG(g_string_erase_REQUIRED_ARGC, g_string_erase_OPTIONAL_ARGC));
#endif
#if BIND_g_string_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_free", mrb_GLib_g_string_free, MRB_ARGS_ARG(g_string_free_REQUIRED_ARGC, g_string_free_OPTIONAL_ARGC));
#endif
#if BIND_g_string_free_to_bytes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_free_to_bytes", mrb_GLib_g_string_free_to_bytes, MRB_ARGS_ARG(g_string_free_to_bytes_REQUIRED_ARGC, g_string_free_to_bytes_OPTIONAL_ARGC));
#endif
#if BIND_g_string_hash_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_hash", mrb_GLib_g_string_hash, MRB_ARGS_ARG(g_string_hash_REQUIRED_ARGC, g_string_hash_OPTIONAL_ARGC));
#endif
#if BIND_g_string_insert_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_insert", mrb_GLib_g_string_insert, MRB_ARGS_ARG(g_string_insert_REQUIRED_ARGC, g_string_insert_OPTIONAL_ARGC));
#endif
#if BIND_g_string_insert_c_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_insert_c", mrb_GLib_g_string_insert_c, MRB_ARGS_ARG(g_string_insert_c_REQUIRED_ARGC, g_string_insert_c_OPTIONAL_ARGC));
#endif
#if BIND_g_string_insert_len_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_insert_len", mrb_GLib_g_string_insert_len, MRB_ARGS_ARG(g_string_insert_len_REQUIRED_ARGC, g_string_insert_len_OPTIONAL_ARGC));
#endif
#if BIND_g_string_insert_unichar_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_insert_unichar", mrb_GLib_g_string_insert_unichar, MRB_ARGS_ARG(g_string_insert_unichar_REQUIRED_ARGC, g_string_insert_unichar_OPTIONAL_ARGC));
#endif
#if BIND_g_string_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_new", mrb_GLib_g_string_new, MRB_ARGS_ARG(g_string_new_REQUIRED_ARGC, g_string_new_OPTIONAL_ARGC));
#endif
#if BIND_g_string_new_len_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_new_len", mrb_GLib_g_string_new_len, MRB_ARGS_ARG(g_string_new_len_REQUIRED_ARGC, g_string_new_len_OPTIONAL_ARGC));
#endif
#if BIND_g_string_overwrite_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_overwrite", mrb_GLib_g_string_overwrite, MRB_ARGS_ARG(g_string_overwrite_REQUIRED_ARGC, g_string_overwrite_OPTIONAL_ARGC));
#endif
#if BIND_g_string_overwrite_len_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_overwrite_len", mrb_GLib_g_string_overwrite_len, MRB_ARGS_ARG(g_string_overwrite_len_REQUIRED_ARGC, g_string_overwrite_len_OPTIONAL_ARGC));
#endif
#if BIND_g_string_prepend_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_prepend", mrb_GLib_g_string_prepend, MRB_ARGS_ARG(g_string_prepend_REQUIRED_ARGC, g_string_prepend_OPTIONAL_ARGC));
#endif
#if BIND_g_string_prepend_c_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_prepend_c", mrb_GLib_g_string_prepend_c, MRB_ARGS_ARG(g_string_prepend_c_REQUIRED_ARGC, g_string_prepend_c_OPTIONAL_ARGC));
#endif
#if BIND_g_string_prepend_len_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_prepend_len", mrb_GLib_g_string_prepend_len, MRB_ARGS_ARG(g_string_prepend_len_REQUIRED_ARGC, g_string_prepend_len_OPTIONAL_ARGC));
#endif
#if BIND_g_string_prepend_unichar_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_prepend_unichar", mrb_GLib_g_string_prepend_unichar, MRB_ARGS_ARG(g_string_prepend_unichar_REQUIRED_ARGC, g_string_prepend_unichar_OPTIONAL_ARGC));
#endif
#if BIND_g_string_printf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_printf", mrb_GLib_g_string_printf, MRB_ARGS_ARG(g_string_printf_REQUIRED_ARGC, g_string_printf_OPTIONAL_ARGC));
#endif
#if BIND_g_string_set_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_set_size", mrb_GLib_g_string_set_size, MRB_ARGS_ARG(g_string_set_size_REQUIRED_ARGC, g_string_set_size_OPTIONAL_ARGC));
#endif
#if BIND_g_string_sized_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_sized_new", mrb_GLib_g_string_sized_new, MRB_ARGS_ARG(g_string_sized_new_REQUIRED_ARGC, g_string_sized_new_OPTIONAL_ARGC));
#endif
#if BIND_g_string_truncate_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_truncate", mrb_GLib_g_string_truncate, MRB_ARGS_ARG(g_string_truncate_REQUIRED_ARGC, g_string_truncate_OPTIONAL_ARGC));
#endif
#if BIND_g_string_up_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_up", mrb_GLib_g_string_up, MRB_ARGS_ARG(g_string_up_REQUIRED_ARGC, g_string_up_OPTIONAL_ARGC));
#endif
#if BIND_g_string_vprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_string_vprintf", mrb_GLib_g_string_vprintf, MRB_ARGS_ARG(g_string_vprintf_REQUIRED_ARGC, g_string_vprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_strip_context_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strip_context", mrb_GLib_g_strip_context, MRB_ARGS_ARG(g_strip_context_REQUIRED_ARGC, g_strip_context_OPTIONAL_ARGC));
#endif
#if BIND_g_strjoin_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strjoin", mrb_GLib_g_strjoin, MRB_ARGS_ARG(g_strjoin_REQUIRED_ARGC, g_strjoin_OPTIONAL_ARGC));
#endif
#if BIND_g_strjoinv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strjoinv", mrb_GLib_g_strjoinv, MRB_ARGS_ARG(g_strjoinv_REQUIRED_ARGC, g_strjoinv_OPTIONAL_ARGC));
#endif
#if BIND_g_strlcat_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strlcat", mrb_GLib_g_strlcat, MRB_ARGS_ARG(g_strlcat_REQUIRED_ARGC, g_strlcat_OPTIONAL_ARGC));
#endif
#if BIND_g_strlcpy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strlcpy", mrb_GLib_g_strlcpy, MRB_ARGS_ARG(g_strlcpy_REQUIRED_ARGC, g_strlcpy_OPTIONAL_ARGC));
#endif
#if BIND_g_strncasecmp_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strncasecmp", mrb_GLib_g_strncasecmp, MRB_ARGS_ARG(g_strncasecmp_REQUIRED_ARGC, g_strncasecmp_OPTIONAL_ARGC));
#endif
#if BIND_g_strndup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strndup", mrb_GLib_g_strndup, MRB_ARGS_ARG(g_strndup_REQUIRED_ARGC, g_strndup_OPTIONAL_ARGC));
#endif
#if BIND_g_strnfill_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strnfill", mrb_GLib_g_strnfill, MRB_ARGS_ARG(g_strnfill_REQUIRED_ARGC, g_strnfill_OPTIONAL_ARGC));
#endif
#if BIND_g_strreverse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strreverse", mrb_GLib_g_strreverse, MRB_ARGS_ARG(g_strreverse_REQUIRED_ARGC, g_strreverse_OPTIONAL_ARGC));
#endif
#if BIND_g_strrstr_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strrstr", mrb_GLib_g_strrstr, MRB_ARGS_ARG(g_strrstr_REQUIRED_ARGC, g_strrstr_OPTIONAL_ARGC));
#endif
#if BIND_g_strrstr_len_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strrstr_len", mrb_GLib_g_strrstr_len, MRB_ARGS_ARG(g_strrstr_len_REQUIRED_ARGC, g_strrstr_len_OPTIONAL_ARGC));
#endif
#if BIND_g_strsignal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strsignal", mrb_GLib_g_strsignal, MRB_ARGS_ARG(g_strsignal_REQUIRED_ARGC, g_strsignal_OPTIONAL_ARGC));
#endif
#if BIND_g_strsplit_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strsplit", mrb_GLib_g_strsplit, MRB_ARGS_ARG(g_strsplit_REQUIRED_ARGC, g_strsplit_OPTIONAL_ARGC));
#endif
#if BIND_g_strsplit_set_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strsplit_set", mrb_GLib_g_strsplit_set, MRB_ARGS_ARG(g_strsplit_set_REQUIRED_ARGC, g_strsplit_set_OPTIONAL_ARGC));
#endif
#if BIND_g_strstr_len_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strstr_len", mrb_GLib_g_strstr_len, MRB_ARGS_ARG(g_strstr_len_REQUIRED_ARGC, g_strstr_len_OPTIONAL_ARGC));
#endif
#if BIND_g_strtod_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strtod", mrb_GLib_g_strtod, MRB_ARGS_ARG(g_strtod_REQUIRED_ARGC, g_strtod_OPTIONAL_ARGC));
#endif
#if BIND_g_strup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strup", mrb_GLib_g_strup, MRB_ARGS_ARG(g_strup_REQUIRED_ARGC, g_strup_OPTIONAL_ARGC));
#endif
#if BIND_g_strv_contains_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strv_contains", mrb_GLib_g_strv_contains, MRB_ARGS_ARG(g_strv_contains_REQUIRED_ARGC, g_strv_contains_OPTIONAL_ARGC));
#endif
#if BIND_g_strv_length_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_strv_length", mrb_GLib_g_strv_length, MRB_ARGS_ARG(g_strv_length_REQUIRED_ARGC, g_strv_length_OPTIONAL_ARGC));
#endif
#if BIND_g_test_add_data_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_add_data_func", mrb_GLib_g_test_add_data_func, MRB_ARGS_ARG(g_test_add_data_func_REQUIRED_ARGC, g_test_add_data_func_OPTIONAL_ARGC));
#endif
#if BIND_g_test_add_data_func_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_add_data_func_full", mrb_GLib_g_test_add_data_func_full, MRB_ARGS_ARG(g_test_add_data_func_full_REQUIRED_ARGC, g_test_add_data_func_full_OPTIONAL_ARGC));
#endif
#if BIND_g_test_add_func_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_add_func", mrb_GLib_g_test_add_func, MRB_ARGS_ARG(g_test_add_func_REQUIRED_ARGC, g_test_add_func_OPTIONAL_ARGC));
#endif
#if BIND_g_test_add_vtable_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_add_vtable", mrb_GLib_g_test_add_vtable, MRB_ARGS_ARG(g_test_add_vtable_REQUIRED_ARGC, g_test_add_vtable_OPTIONAL_ARGC));
#endif
#if BIND_g_test_assert_expected_messages_internal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_assert_expected_messages_internal", mrb_GLib_g_test_assert_expected_messages_internal, MRB_ARGS_ARG(g_test_assert_expected_messages_internal_REQUIRED_ARGC, g_test_assert_expected_messages_internal_OPTIONAL_ARGC));
#endif
#if BIND_g_test_bug_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_bug", mrb_GLib_g_test_bug, MRB_ARGS_ARG(g_test_bug_REQUIRED_ARGC, g_test_bug_OPTIONAL_ARGC));
#endif
#if BIND_g_test_bug_base_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_bug_base", mrb_GLib_g_test_bug_base, MRB_ARGS_ARG(g_test_bug_base_REQUIRED_ARGC, g_test_bug_base_OPTIONAL_ARGC));
#endif
#if BIND_g_test_build_filename_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_build_filename", mrb_GLib_g_test_build_filename, MRB_ARGS_ARG(g_test_build_filename_REQUIRED_ARGC, g_test_build_filename_OPTIONAL_ARGC));
#endif
#if BIND_g_test_create_case_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_create_case", mrb_GLib_g_test_create_case, MRB_ARGS_ARG(g_test_create_case_REQUIRED_ARGC, g_test_create_case_OPTIONAL_ARGC));
#endif
#if BIND_g_test_create_suite_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_create_suite", mrb_GLib_g_test_create_suite, MRB_ARGS_ARG(g_test_create_suite_REQUIRED_ARGC, g_test_create_suite_OPTIONAL_ARGC));
#endif
#if BIND_g_test_expect_message_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_expect_message", mrb_GLib_g_test_expect_message, MRB_ARGS_ARG(g_test_expect_message_REQUIRED_ARGC, g_test_expect_message_OPTIONAL_ARGC));
#endif
#if BIND_g_test_fail_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_fail", mrb_GLib_g_test_fail, MRB_ARGS_ARG(g_test_fail_REQUIRED_ARGC, g_test_fail_OPTIONAL_ARGC));
#endif
#if BIND_g_test_failed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_failed", mrb_GLib_g_test_failed, MRB_ARGS_ARG(g_test_failed_REQUIRED_ARGC, g_test_failed_OPTIONAL_ARGC));
#endif
#if BIND_g_test_get_dir_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_get_dir", mrb_GLib_g_test_get_dir, MRB_ARGS_ARG(g_test_get_dir_REQUIRED_ARGC, g_test_get_dir_OPTIONAL_ARGC));
#endif
#if BIND_g_test_get_filename_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_get_filename", mrb_GLib_g_test_get_filename, MRB_ARGS_ARG(g_test_get_filename_REQUIRED_ARGC, g_test_get_filename_OPTIONAL_ARGC));
#endif
#if BIND_g_test_get_root_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_get_root", mrb_GLib_g_test_get_root, MRB_ARGS_ARG(g_test_get_root_REQUIRED_ARGC, g_test_get_root_OPTIONAL_ARGC));
#endif
#if BIND_g_test_incomplete_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_incomplete", mrb_GLib_g_test_incomplete, MRB_ARGS_ARG(g_test_incomplete_REQUIRED_ARGC, g_test_incomplete_OPTIONAL_ARGC));
#endif
#if BIND_g_test_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_init", mrb_GLib_g_test_init, MRB_ARGS_ARG(g_test_init_REQUIRED_ARGC, g_test_init_OPTIONAL_ARGC));
#endif
#if BIND_g_test_log_buffer_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_log_buffer_free", mrb_GLib_g_test_log_buffer_free, MRB_ARGS_ARG(g_test_log_buffer_free_REQUIRED_ARGC, g_test_log_buffer_free_OPTIONAL_ARGC));
#endif
#if BIND_g_test_log_buffer_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_log_buffer_new", mrb_GLib_g_test_log_buffer_new, MRB_ARGS_ARG(g_test_log_buffer_new_REQUIRED_ARGC, g_test_log_buffer_new_OPTIONAL_ARGC));
#endif
#if BIND_g_test_log_buffer_pop_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_log_buffer_pop", mrb_GLib_g_test_log_buffer_pop, MRB_ARGS_ARG(g_test_log_buffer_pop_REQUIRED_ARGC, g_test_log_buffer_pop_OPTIONAL_ARGC));
#endif
#if BIND_g_test_log_buffer_push_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_log_buffer_push", mrb_GLib_g_test_log_buffer_push, MRB_ARGS_ARG(g_test_log_buffer_push_REQUIRED_ARGC, g_test_log_buffer_push_OPTIONAL_ARGC));
#endif
#if BIND_g_test_log_msg_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_log_msg_free", mrb_GLib_g_test_log_msg_free, MRB_ARGS_ARG(g_test_log_msg_free_REQUIRED_ARGC, g_test_log_msg_free_OPTIONAL_ARGC));
#endif
#if BIND_g_test_log_set_fatal_handler_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_log_set_fatal_handler", mrb_GLib_g_test_log_set_fatal_handler, MRB_ARGS_ARG(g_test_log_set_fatal_handler_REQUIRED_ARGC, g_test_log_set_fatal_handler_OPTIONAL_ARGC));
#endif
#if BIND_g_test_log_type_name_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_log_type_name", mrb_GLib_g_test_log_type_name, MRB_ARGS_ARG(g_test_log_type_name_REQUIRED_ARGC, g_test_log_type_name_OPTIONAL_ARGC));
#endif
#if BIND_g_test_maximized_result_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_maximized_result", mrb_GLib_g_test_maximized_result, MRB_ARGS_ARG(g_test_maximized_result_REQUIRED_ARGC, g_test_maximized_result_OPTIONAL_ARGC));
#endif
#if BIND_g_test_message_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_message", mrb_GLib_g_test_message, MRB_ARGS_ARG(g_test_message_REQUIRED_ARGC, g_test_message_OPTIONAL_ARGC));
#endif
#if BIND_g_test_minimized_result_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_minimized_result", mrb_GLib_g_test_minimized_result, MRB_ARGS_ARG(g_test_minimized_result_REQUIRED_ARGC, g_test_minimized_result_OPTIONAL_ARGC));
#endif
#if BIND_g_test_queue_destroy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_queue_destroy", mrb_GLib_g_test_queue_destroy, MRB_ARGS_ARG(g_test_queue_destroy_REQUIRED_ARGC, g_test_queue_destroy_OPTIONAL_ARGC));
#endif
#if BIND_g_test_queue_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_queue_free", mrb_GLib_g_test_queue_free, MRB_ARGS_ARG(g_test_queue_free_REQUIRED_ARGC, g_test_queue_free_OPTIONAL_ARGC));
#endif
#if BIND_g_test_rand_double_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_rand_double", mrb_GLib_g_test_rand_double, MRB_ARGS_ARG(g_test_rand_double_REQUIRED_ARGC, g_test_rand_double_OPTIONAL_ARGC));
#endif
#if BIND_g_test_rand_double_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_rand_double_range", mrb_GLib_g_test_rand_double_range, MRB_ARGS_ARG(g_test_rand_double_range_REQUIRED_ARGC, g_test_rand_double_range_OPTIONAL_ARGC));
#endif
#if BIND_g_test_rand_int_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_rand_int", mrb_GLib_g_test_rand_int, MRB_ARGS_ARG(g_test_rand_int_REQUIRED_ARGC, g_test_rand_int_OPTIONAL_ARGC));
#endif
#if BIND_g_test_rand_int_range_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_rand_int_range", mrb_GLib_g_test_rand_int_range, MRB_ARGS_ARG(g_test_rand_int_range_REQUIRED_ARGC, g_test_rand_int_range_OPTIONAL_ARGC));
#endif
#if BIND_g_test_run_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_run", mrb_GLib_g_test_run, MRB_ARGS_ARG(g_test_run_REQUIRED_ARGC, g_test_run_OPTIONAL_ARGC));
#endif
#if BIND_g_test_run_suite_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_run_suite", mrb_GLib_g_test_run_suite, MRB_ARGS_ARG(g_test_run_suite_REQUIRED_ARGC, g_test_run_suite_OPTIONAL_ARGC));
#endif
#if BIND_g_test_set_nonfatal_assertions_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_set_nonfatal_assertions", mrb_GLib_g_test_set_nonfatal_assertions, MRB_ARGS_ARG(g_test_set_nonfatal_assertions_REQUIRED_ARGC, g_test_set_nonfatal_assertions_OPTIONAL_ARGC));
#endif
#if BIND_g_test_skip_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_skip", mrb_GLib_g_test_skip, MRB_ARGS_ARG(g_test_skip_REQUIRED_ARGC, g_test_skip_OPTIONAL_ARGC));
#endif
#if BIND_g_test_subprocess_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_subprocess", mrb_GLib_g_test_subprocess, MRB_ARGS_ARG(g_test_subprocess_REQUIRED_ARGC, g_test_subprocess_OPTIONAL_ARGC));
#endif
#if BIND_g_test_suite_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_suite_add", mrb_GLib_g_test_suite_add, MRB_ARGS_ARG(g_test_suite_add_REQUIRED_ARGC, g_test_suite_add_OPTIONAL_ARGC));
#endif
#if BIND_g_test_suite_add_suite_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_suite_add_suite", mrb_GLib_g_test_suite_add_suite, MRB_ARGS_ARG(g_test_suite_add_suite_REQUIRED_ARGC, g_test_suite_add_suite_OPTIONAL_ARGC));
#endif
#if BIND_g_test_timer_elapsed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_timer_elapsed", mrb_GLib_g_test_timer_elapsed, MRB_ARGS_ARG(g_test_timer_elapsed_REQUIRED_ARGC, g_test_timer_elapsed_OPTIONAL_ARGC));
#endif
#if BIND_g_test_timer_last_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_timer_last", mrb_GLib_g_test_timer_last, MRB_ARGS_ARG(g_test_timer_last_REQUIRED_ARGC, g_test_timer_last_OPTIONAL_ARGC));
#endif
#if BIND_g_test_timer_start_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_timer_start", mrb_GLib_g_test_timer_start, MRB_ARGS_ARG(g_test_timer_start_REQUIRED_ARGC, g_test_timer_start_OPTIONAL_ARGC));
#endif
#if BIND_g_test_trap_assertions_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_trap_assertions", mrb_GLib_g_test_trap_assertions, MRB_ARGS_ARG(g_test_trap_assertions_REQUIRED_ARGC, g_test_trap_assertions_OPTIONAL_ARGC));
#endif
#if BIND_g_test_trap_fork_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_trap_fork", mrb_GLib_g_test_trap_fork, MRB_ARGS_ARG(g_test_trap_fork_REQUIRED_ARGC, g_test_trap_fork_OPTIONAL_ARGC));
#endif
#if BIND_g_test_trap_has_passed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_trap_has_passed", mrb_GLib_g_test_trap_has_passed, MRB_ARGS_ARG(g_test_trap_has_passed_REQUIRED_ARGC, g_test_trap_has_passed_OPTIONAL_ARGC));
#endif
#if BIND_g_test_trap_reached_timeout_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_trap_reached_timeout", mrb_GLib_g_test_trap_reached_timeout, MRB_ARGS_ARG(g_test_trap_reached_timeout_REQUIRED_ARGC, g_test_trap_reached_timeout_OPTIONAL_ARGC));
#endif
#if BIND_g_test_trap_subprocess_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_test_trap_subprocess", mrb_GLib_g_test_trap_subprocess, MRB_ARGS_ARG(g_test_trap_subprocess_REQUIRED_ARGC, g_test_trap_subprocess_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_error_quark", mrb_GLib_g_thread_error_quark, MRB_ARGS_ARG(g_thread_error_quark_REQUIRED_ARGC, g_thread_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_exit_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_exit", mrb_GLib_g_thread_exit, MRB_ARGS_ARG(g_thread_exit_REQUIRED_ARGC, g_thread_exit_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_join_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_join", mrb_GLib_g_thread_join, MRB_ARGS_ARG(g_thread_join_REQUIRED_ARGC, g_thread_join_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_new", mrb_GLib_g_thread_new, MRB_ARGS_ARG(g_thread_new_REQUIRED_ARGC, g_thread_new_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_free", mrb_GLib_g_thread_pool_free, MRB_ARGS_ARG(g_thread_pool_free_REQUIRED_ARGC, g_thread_pool_free_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_get_max_idle_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_get_max_idle_time", mrb_GLib_g_thread_pool_get_max_idle_time, MRB_ARGS_ARG(g_thread_pool_get_max_idle_time_REQUIRED_ARGC, g_thread_pool_get_max_idle_time_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_get_max_threads_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_get_max_threads", mrb_GLib_g_thread_pool_get_max_threads, MRB_ARGS_ARG(g_thread_pool_get_max_threads_REQUIRED_ARGC, g_thread_pool_get_max_threads_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_get_max_unused_threads_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_get_max_unused_threads", mrb_GLib_g_thread_pool_get_max_unused_threads, MRB_ARGS_ARG(g_thread_pool_get_max_unused_threads_REQUIRED_ARGC, g_thread_pool_get_max_unused_threads_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_get_num_threads_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_get_num_threads", mrb_GLib_g_thread_pool_get_num_threads, MRB_ARGS_ARG(g_thread_pool_get_num_threads_REQUIRED_ARGC, g_thread_pool_get_num_threads_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_get_num_unused_threads_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_get_num_unused_threads", mrb_GLib_g_thread_pool_get_num_unused_threads, MRB_ARGS_ARG(g_thread_pool_get_num_unused_threads_REQUIRED_ARGC, g_thread_pool_get_num_unused_threads_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_move_to_front_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_move_to_front", mrb_GLib_g_thread_pool_move_to_front, MRB_ARGS_ARG(g_thread_pool_move_to_front_REQUIRED_ARGC, g_thread_pool_move_to_front_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_new", mrb_GLib_g_thread_pool_new, MRB_ARGS_ARG(g_thread_pool_new_REQUIRED_ARGC, g_thread_pool_new_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_push_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_push", mrb_GLib_g_thread_pool_push, MRB_ARGS_ARG(g_thread_pool_push_REQUIRED_ARGC, g_thread_pool_push_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_set_max_idle_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_set_max_idle_time", mrb_GLib_g_thread_pool_set_max_idle_time, MRB_ARGS_ARG(g_thread_pool_set_max_idle_time_REQUIRED_ARGC, g_thread_pool_set_max_idle_time_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_set_max_threads_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_set_max_threads", mrb_GLib_g_thread_pool_set_max_threads, MRB_ARGS_ARG(g_thread_pool_set_max_threads_REQUIRED_ARGC, g_thread_pool_set_max_threads_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_set_max_unused_threads_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_set_max_unused_threads", mrb_GLib_g_thread_pool_set_max_unused_threads, MRB_ARGS_ARG(g_thread_pool_set_max_unused_threads_REQUIRED_ARGC, g_thread_pool_set_max_unused_threads_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_set_sort_function_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_set_sort_function", mrb_GLib_g_thread_pool_set_sort_function, MRB_ARGS_ARG(g_thread_pool_set_sort_function_REQUIRED_ARGC, g_thread_pool_set_sort_function_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_stop_unused_threads_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_stop_unused_threads", mrb_GLib_g_thread_pool_stop_unused_threads, MRB_ARGS_ARG(g_thread_pool_stop_unused_threads_REQUIRED_ARGC, g_thread_pool_stop_unused_threads_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_pool_unprocessed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_pool_unprocessed", mrb_GLib_g_thread_pool_unprocessed, MRB_ARGS_ARG(g_thread_pool_unprocessed_REQUIRED_ARGC, g_thread_pool_unprocessed_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_ref", mrb_GLib_g_thread_ref, MRB_ARGS_ARG(g_thread_ref_REQUIRED_ARGC, g_thread_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_self_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_self", mrb_GLib_g_thread_self, MRB_ARGS_ARG(g_thread_self_REQUIRED_ARGC, g_thread_self_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_try_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_try_new", mrb_GLib_g_thread_try_new, MRB_ARGS_ARG(g_thread_try_new_REQUIRED_ARGC, g_thread_try_new_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_unref", mrb_GLib_g_thread_unref, MRB_ARGS_ARG(g_thread_unref_REQUIRED_ARGC, g_thread_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_thread_yield_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_thread_yield", mrb_GLib_g_thread_yield, MRB_ARGS_ARG(g_thread_yield_REQUIRED_ARGC, g_thread_yield_OPTIONAL_ARGC));
#endif
#if BIND_g_time_val_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_val_add", mrb_GLib_g_time_val_add, MRB_ARGS_ARG(g_time_val_add_REQUIRED_ARGC, g_time_val_add_OPTIONAL_ARGC));
#endif
#if BIND_g_time_val_from_iso8601_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_val_from_iso8601", mrb_GLib_g_time_val_from_iso8601, MRB_ARGS_ARG(g_time_val_from_iso8601_REQUIRED_ARGC, g_time_val_from_iso8601_OPTIONAL_ARGC));
#endif
#if BIND_g_time_val_to_iso8601_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_val_to_iso8601", mrb_GLib_g_time_val_to_iso8601, MRB_ARGS_ARG(g_time_val_to_iso8601_REQUIRED_ARGC, g_time_val_to_iso8601_OPTIONAL_ARGC));
#endif
#if BIND_g_time_zone_adjust_time_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_zone_adjust_time", mrb_GLib_g_time_zone_adjust_time, MRB_ARGS_ARG(g_time_zone_adjust_time_REQUIRED_ARGC, g_time_zone_adjust_time_OPTIONAL_ARGC));
#endif
#if BIND_g_time_zone_find_interval_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_zone_find_interval", mrb_GLib_g_time_zone_find_interval, MRB_ARGS_ARG(g_time_zone_find_interval_REQUIRED_ARGC, g_time_zone_find_interval_OPTIONAL_ARGC));
#endif
#if BIND_g_time_zone_get_abbreviation_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_zone_get_abbreviation", mrb_GLib_g_time_zone_get_abbreviation, MRB_ARGS_ARG(g_time_zone_get_abbreviation_REQUIRED_ARGC, g_time_zone_get_abbreviation_OPTIONAL_ARGC));
#endif
#if BIND_g_time_zone_get_offset_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_zone_get_offset", mrb_GLib_g_time_zone_get_offset, MRB_ARGS_ARG(g_time_zone_get_offset_REQUIRED_ARGC, g_time_zone_get_offset_OPTIONAL_ARGC));
#endif
#if BIND_g_time_zone_is_dst_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_zone_is_dst", mrb_GLib_g_time_zone_is_dst, MRB_ARGS_ARG(g_time_zone_is_dst_REQUIRED_ARGC, g_time_zone_is_dst_OPTIONAL_ARGC));
#endif
#if BIND_g_time_zone_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_zone_new", mrb_GLib_g_time_zone_new, MRB_ARGS_ARG(g_time_zone_new_REQUIRED_ARGC, g_time_zone_new_OPTIONAL_ARGC));
#endif
#if BIND_g_time_zone_new_local_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_zone_new_local", mrb_GLib_g_time_zone_new_local, MRB_ARGS_ARG(g_time_zone_new_local_REQUIRED_ARGC, g_time_zone_new_local_OPTIONAL_ARGC));
#endif
#if BIND_g_time_zone_new_utc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_zone_new_utc", mrb_GLib_g_time_zone_new_utc, MRB_ARGS_ARG(g_time_zone_new_utc_REQUIRED_ARGC, g_time_zone_new_utc_OPTIONAL_ARGC));
#endif
#if BIND_g_time_zone_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_zone_ref", mrb_GLib_g_time_zone_ref, MRB_ARGS_ARG(g_time_zone_ref_REQUIRED_ARGC, g_time_zone_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_time_zone_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_time_zone_unref", mrb_GLib_g_time_zone_unref, MRB_ARGS_ARG(g_time_zone_unref_REQUIRED_ARGC, g_time_zone_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_timeout_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timeout_add", mrb_GLib_g_timeout_add, MRB_ARGS_ARG(g_timeout_add_REQUIRED_ARGC, g_timeout_add_OPTIONAL_ARGC));
#endif
#if BIND_g_timeout_add_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timeout_add_full", mrb_GLib_g_timeout_add_full, MRB_ARGS_ARG(g_timeout_add_full_REQUIRED_ARGC, g_timeout_add_full_OPTIONAL_ARGC));
#endif
#if BIND_g_timeout_add_seconds_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timeout_add_seconds", mrb_GLib_g_timeout_add_seconds, MRB_ARGS_ARG(g_timeout_add_seconds_REQUIRED_ARGC, g_timeout_add_seconds_OPTIONAL_ARGC));
#endif
#if BIND_g_timeout_add_seconds_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timeout_add_seconds_full", mrb_GLib_g_timeout_add_seconds_full, MRB_ARGS_ARG(g_timeout_add_seconds_full_REQUIRED_ARGC, g_timeout_add_seconds_full_OPTIONAL_ARGC));
#endif
#if BIND_g_timeout_source_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timeout_source_new", mrb_GLib_g_timeout_source_new, MRB_ARGS_ARG(g_timeout_source_new_REQUIRED_ARGC, g_timeout_source_new_OPTIONAL_ARGC));
#endif
#if BIND_g_timeout_source_new_seconds_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timeout_source_new_seconds", mrb_GLib_g_timeout_source_new_seconds, MRB_ARGS_ARG(g_timeout_source_new_seconds_REQUIRED_ARGC, g_timeout_source_new_seconds_OPTIONAL_ARGC));
#endif
#if BIND_g_timer_continue_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timer_continue", mrb_GLib_g_timer_continue, MRB_ARGS_ARG(g_timer_continue_REQUIRED_ARGC, g_timer_continue_OPTIONAL_ARGC));
#endif
#if BIND_g_timer_destroy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timer_destroy", mrb_GLib_g_timer_destroy, MRB_ARGS_ARG(g_timer_destroy_REQUIRED_ARGC, g_timer_destroy_OPTIONAL_ARGC));
#endif
#if BIND_g_timer_elapsed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timer_elapsed", mrb_GLib_g_timer_elapsed, MRB_ARGS_ARG(g_timer_elapsed_REQUIRED_ARGC, g_timer_elapsed_OPTIONAL_ARGC));
#endif
#if BIND_g_timer_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timer_new", mrb_GLib_g_timer_new, MRB_ARGS_ARG(g_timer_new_REQUIRED_ARGC, g_timer_new_OPTIONAL_ARGC));
#endif
#if BIND_g_timer_reset_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timer_reset", mrb_GLib_g_timer_reset, MRB_ARGS_ARG(g_timer_reset_REQUIRED_ARGC, g_timer_reset_OPTIONAL_ARGC));
#endif
#if BIND_g_timer_start_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timer_start", mrb_GLib_g_timer_start, MRB_ARGS_ARG(g_timer_start_REQUIRED_ARGC, g_timer_start_OPTIONAL_ARGC));
#endif
#if BIND_g_timer_stop_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_timer_stop", mrb_GLib_g_timer_stop, MRB_ARGS_ARG(g_timer_stop_REQUIRED_ARGC, g_timer_stop_OPTIONAL_ARGC));
#endif
#if BIND_g_trash_stack_height_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_trash_stack_height", mrb_GLib_g_trash_stack_height, MRB_ARGS_ARG(g_trash_stack_height_REQUIRED_ARGC, g_trash_stack_height_OPTIONAL_ARGC));
#endif
#if BIND_g_trash_stack_peek_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_trash_stack_peek", mrb_GLib_g_trash_stack_peek, MRB_ARGS_ARG(g_trash_stack_peek_REQUIRED_ARGC, g_trash_stack_peek_OPTIONAL_ARGC));
#endif
#if BIND_g_trash_stack_pop_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_trash_stack_pop", mrb_GLib_g_trash_stack_pop, MRB_ARGS_ARG(g_trash_stack_pop_REQUIRED_ARGC, g_trash_stack_pop_OPTIONAL_ARGC));
#endif
#if BIND_g_trash_stack_push_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_trash_stack_push", mrb_GLib_g_trash_stack_push, MRB_ARGS_ARG(g_trash_stack_push_REQUIRED_ARGC, g_trash_stack_push_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_destroy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_destroy", mrb_GLib_g_tree_destroy, MRB_ARGS_ARG(g_tree_destroy_REQUIRED_ARGC, g_tree_destroy_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_foreach_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_foreach", mrb_GLib_g_tree_foreach, MRB_ARGS_ARG(g_tree_foreach_REQUIRED_ARGC, g_tree_foreach_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_height_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_height", mrb_GLib_g_tree_height, MRB_ARGS_ARG(g_tree_height_REQUIRED_ARGC, g_tree_height_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_insert_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_insert", mrb_GLib_g_tree_insert, MRB_ARGS_ARG(g_tree_insert_REQUIRED_ARGC, g_tree_insert_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_lookup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_lookup", mrb_GLib_g_tree_lookup, MRB_ARGS_ARG(g_tree_lookup_REQUIRED_ARGC, g_tree_lookup_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_lookup_extended_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_lookup_extended", mrb_GLib_g_tree_lookup_extended, MRB_ARGS_ARG(g_tree_lookup_extended_REQUIRED_ARGC, g_tree_lookup_extended_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_new", mrb_GLib_g_tree_new, MRB_ARGS_ARG(g_tree_new_REQUIRED_ARGC, g_tree_new_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_new_full_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_new_full", mrb_GLib_g_tree_new_full, MRB_ARGS_ARG(g_tree_new_full_REQUIRED_ARGC, g_tree_new_full_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_new_with_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_new_with_data", mrb_GLib_g_tree_new_with_data, MRB_ARGS_ARG(g_tree_new_with_data_REQUIRED_ARGC, g_tree_new_with_data_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_nnodes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_nnodes", mrb_GLib_g_tree_nnodes, MRB_ARGS_ARG(g_tree_nnodes_REQUIRED_ARGC, g_tree_nnodes_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_ref", mrb_GLib_g_tree_ref, MRB_ARGS_ARG(g_tree_ref_REQUIRED_ARGC, g_tree_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_remove", mrb_GLib_g_tree_remove, MRB_ARGS_ARG(g_tree_remove_REQUIRED_ARGC, g_tree_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_replace_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_replace", mrb_GLib_g_tree_replace, MRB_ARGS_ARG(g_tree_replace_REQUIRED_ARGC, g_tree_replace_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_search_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_search", mrb_GLib_g_tree_search, MRB_ARGS_ARG(g_tree_search_REQUIRED_ARGC, g_tree_search_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_steal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_steal", mrb_GLib_g_tree_steal, MRB_ARGS_ARG(g_tree_steal_REQUIRED_ARGC, g_tree_steal_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_traverse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_traverse", mrb_GLib_g_tree_traverse, MRB_ARGS_ARG(g_tree_traverse_REQUIRED_ARGC, g_tree_traverse_OPTIONAL_ARGC));
#endif
#if BIND_g_tree_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_tree_unref", mrb_GLib_g_tree_unref, MRB_ARGS_ARG(g_tree_unref_REQUIRED_ARGC, g_tree_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_try_malloc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_try_malloc", mrb_GLib_g_try_malloc, MRB_ARGS_ARG(g_try_malloc_REQUIRED_ARGC, g_try_malloc_OPTIONAL_ARGC));
#endif
#if BIND_g_try_malloc0_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_try_malloc0", mrb_GLib_g_try_malloc0, MRB_ARGS_ARG(g_try_malloc0_REQUIRED_ARGC, g_try_malloc0_OPTIONAL_ARGC));
#endif
#if BIND_g_try_malloc0_n_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_try_malloc0_n", mrb_GLib_g_try_malloc0_n, MRB_ARGS_ARG(g_try_malloc0_n_REQUIRED_ARGC, g_try_malloc0_n_OPTIONAL_ARGC));
#endif
#if BIND_g_try_malloc_n_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_try_malloc_n", mrb_GLib_g_try_malloc_n, MRB_ARGS_ARG(g_try_malloc_n_REQUIRED_ARGC, g_try_malloc_n_OPTIONAL_ARGC));
#endif
#if BIND_g_try_realloc_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_try_realloc", mrb_GLib_g_try_realloc, MRB_ARGS_ARG(g_try_realloc_REQUIRED_ARGC, g_try_realloc_OPTIONAL_ARGC));
#endif
#if BIND_g_try_realloc_n_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_try_realloc_n", mrb_GLib_g_try_realloc_n, MRB_ARGS_ARG(g_try_realloc_n_REQUIRED_ARGC, g_try_realloc_n_OPTIONAL_ARGC));
#endif
#if BIND_g_ucs4_to_utf16_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ucs4_to_utf16", mrb_GLib_g_ucs4_to_utf16, MRB_ARGS_ARG(g_ucs4_to_utf16_REQUIRED_ARGC, g_ucs4_to_utf16_OPTIONAL_ARGC));
#endif
#if BIND_g_ucs4_to_utf8_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_ucs4_to_utf8", mrb_GLib_g_ucs4_to_utf8, MRB_ARGS_ARG(g_ucs4_to_utf8_REQUIRED_ARGC, g_ucs4_to_utf8_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_break_type_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_break_type", mrb_GLib_g_unichar_break_type, MRB_ARGS_ARG(g_unichar_break_type_REQUIRED_ARGC, g_unichar_break_type_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_combining_class_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_combining_class", mrb_GLib_g_unichar_combining_class, MRB_ARGS_ARG(g_unichar_combining_class_REQUIRED_ARGC, g_unichar_combining_class_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_compose_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_compose", mrb_GLib_g_unichar_compose, MRB_ARGS_ARG(g_unichar_compose_REQUIRED_ARGC, g_unichar_compose_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_decompose_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_decompose", mrb_GLib_g_unichar_decompose, MRB_ARGS_ARG(g_unichar_decompose_REQUIRED_ARGC, g_unichar_decompose_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_digit_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_digit_value", mrb_GLib_g_unichar_digit_value, MRB_ARGS_ARG(g_unichar_digit_value_REQUIRED_ARGC, g_unichar_digit_value_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_fully_decompose_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_fully_decompose", mrb_GLib_g_unichar_fully_decompose, MRB_ARGS_ARG(g_unichar_fully_decompose_REQUIRED_ARGC, g_unichar_fully_decompose_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_get_mirror_char_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_get_mirror_char", mrb_GLib_g_unichar_get_mirror_char, MRB_ARGS_ARG(g_unichar_get_mirror_char_REQUIRED_ARGC, g_unichar_get_mirror_char_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_get_script_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_get_script", mrb_GLib_g_unichar_get_script, MRB_ARGS_ARG(g_unichar_get_script_REQUIRED_ARGC, g_unichar_get_script_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_isalnum_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_isalnum", mrb_GLib_g_unichar_isalnum, MRB_ARGS_ARG(g_unichar_isalnum_REQUIRED_ARGC, g_unichar_isalnum_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_isalpha_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_isalpha", mrb_GLib_g_unichar_isalpha, MRB_ARGS_ARG(g_unichar_isalpha_REQUIRED_ARGC, g_unichar_isalpha_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_iscntrl_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_iscntrl", mrb_GLib_g_unichar_iscntrl, MRB_ARGS_ARG(g_unichar_iscntrl_REQUIRED_ARGC, g_unichar_iscntrl_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_isdefined_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_isdefined", mrb_GLib_g_unichar_isdefined, MRB_ARGS_ARG(g_unichar_isdefined_REQUIRED_ARGC, g_unichar_isdefined_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_isdigit_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_isdigit", mrb_GLib_g_unichar_isdigit, MRB_ARGS_ARG(g_unichar_isdigit_REQUIRED_ARGC, g_unichar_isdigit_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_isgraph_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_isgraph", mrb_GLib_g_unichar_isgraph, MRB_ARGS_ARG(g_unichar_isgraph_REQUIRED_ARGC, g_unichar_isgraph_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_islower_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_islower", mrb_GLib_g_unichar_islower, MRB_ARGS_ARG(g_unichar_islower_REQUIRED_ARGC, g_unichar_islower_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_ismark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_ismark", mrb_GLib_g_unichar_ismark, MRB_ARGS_ARG(g_unichar_ismark_REQUIRED_ARGC, g_unichar_ismark_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_isprint_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_isprint", mrb_GLib_g_unichar_isprint, MRB_ARGS_ARG(g_unichar_isprint_REQUIRED_ARGC, g_unichar_isprint_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_ispunct_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_ispunct", mrb_GLib_g_unichar_ispunct, MRB_ARGS_ARG(g_unichar_ispunct_REQUIRED_ARGC, g_unichar_ispunct_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_isspace_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_isspace", mrb_GLib_g_unichar_isspace, MRB_ARGS_ARG(g_unichar_isspace_REQUIRED_ARGC, g_unichar_isspace_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_istitle_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_istitle", mrb_GLib_g_unichar_istitle, MRB_ARGS_ARG(g_unichar_istitle_REQUIRED_ARGC, g_unichar_istitle_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_isupper_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_isupper", mrb_GLib_g_unichar_isupper, MRB_ARGS_ARG(g_unichar_isupper_REQUIRED_ARGC, g_unichar_isupper_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_iswide_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_iswide", mrb_GLib_g_unichar_iswide, MRB_ARGS_ARG(g_unichar_iswide_REQUIRED_ARGC, g_unichar_iswide_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_iswide_cjk_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_iswide_cjk", mrb_GLib_g_unichar_iswide_cjk, MRB_ARGS_ARG(g_unichar_iswide_cjk_REQUIRED_ARGC, g_unichar_iswide_cjk_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_isxdigit_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_isxdigit", mrb_GLib_g_unichar_isxdigit, MRB_ARGS_ARG(g_unichar_isxdigit_REQUIRED_ARGC, g_unichar_isxdigit_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_iszerowidth_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_iszerowidth", mrb_GLib_g_unichar_iszerowidth, MRB_ARGS_ARG(g_unichar_iszerowidth_REQUIRED_ARGC, g_unichar_iszerowidth_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_to_utf8_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_to_utf8", mrb_GLib_g_unichar_to_utf8, MRB_ARGS_ARG(g_unichar_to_utf8_REQUIRED_ARGC, g_unichar_to_utf8_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_tolower_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_tolower", mrb_GLib_g_unichar_tolower, MRB_ARGS_ARG(g_unichar_tolower_REQUIRED_ARGC, g_unichar_tolower_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_totitle_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_totitle", mrb_GLib_g_unichar_totitle, MRB_ARGS_ARG(g_unichar_totitle_REQUIRED_ARGC, g_unichar_totitle_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_toupper_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_toupper", mrb_GLib_g_unichar_toupper, MRB_ARGS_ARG(g_unichar_toupper_REQUIRED_ARGC, g_unichar_toupper_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_type_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_type", mrb_GLib_g_unichar_type, MRB_ARGS_ARG(g_unichar_type_REQUIRED_ARGC, g_unichar_type_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_validate_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_validate", mrb_GLib_g_unichar_validate, MRB_ARGS_ARG(g_unichar_validate_REQUIRED_ARGC, g_unichar_validate_OPTIONAL_ARGC));
#endif
#if BIND_g_unichar_xdigit_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unichar_xdigit_value", mrb_GLib_g_unichar_xdigit_value, MRB_ARGS_ARG(g_unichar_xdigit_value_REQUIRED_ARGC, g_unichar_xdigit_value_OPTIONAL_ARGC));
#endif
#if BIND_g_unicode_canonical_decomposition_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unicode_canonical_decomposition", mrb_GLib_g_unicode_canonical_decomposition, MRB_ARGS_ARG(g_unicode_canonical_decomposition_REQUIRED_ARGC, g_unicode_canonical_decomposition_OPTIONAL_ARGC));
#endif
#if BIND_g_unicode_canonical_ordering_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unicode_canonical_ordering", mrb_GLib_g_unicode_canonical_ordering, MRB_ARGS_ARG(g_unicode_canonical_ordering_REQUIRED_ARGC, g_unicode_canonical_ordering_OPTIONAL_ARGC));
#endif
#if BIND_g_unicode_script_from_iso15924_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unicode_script_from_iso15924", mrb_GLib_g_unicode_script_from_iso15924, MRB_ARGS_ARG(g_unicode_script_from_iso15924_REQUIRED_ARGC, g_unicode_script_from_iso15924_OPTIONAL_ARGC));
#endif
#if BIND_g_unicode_script_to_iso15924_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unicode_script_to_iso15924", mrb_GLib_g_unicode_script_to_iso15924, MRB_ARGS_ARG(g_unicode_script_to_iso15924_REQUIRED_ARGC, g_unicode_script_to_iso15924_OPTIONAL_ARGC));
#endif
#if BIND_g_unlink_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unlink", mrb_GLib_g_unlink, MRB_ARGS_ARG(g_unlink_REQUIRED_ARGC, g_unlink_OPTIONAL_ARGC));
#endif
#if BIND_g_unsetenv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_unsetenv", mrb_GLib_g_unsetenv, MRB_ARGS_ARG(g_unsetenv_REQUIRED_ARGC, g_unsetenv_OPTIONAL_ARGC));
#endif
#if BIND_g_uri_escape_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_uri_escape_string", mrb_GLib_g_uri_escape_string, MRB_ARGS_ARG(g_uri_escape_string_REQUIRED_ARGC, g_uri_escape_string_OPTIONAL_ARGC));
#endif
#if BIND_g_uri_list_extract_uris_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_uri_list_extract_uris", mrb_GLib_g_uri_list_extract_uris, MRB_ARGS_ARG(g_uri_list_extract_uris_REQUIRED_ARGC, g_uri_list_extract_uris_OPTIONAL_ARGC));
#endif
#if BIND_g_uri_parse_scheme_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_uri_parse_scheme", mrb_GLib_g_uri_parse_scheme, MRB_ARGS_ARG(g_uri_parse_scheme_REQUIRED_ARGC, g_uri_parse_scheme_OPTIONAL_ARGC));
#endif
#if BIND_g_uri_unescape_segment_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_uri_unescape_segment", mrb_GLib_g_uri_unescape_segment, MRB_ARGS_ARG(g_uri_unescape_segment_REQUIRED_ARGC, g_uri_unescape_segment_OPTIONAL_ARGC));
#endif
#if BIND_g_uri_unescape_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_uri_unescape_string", mrb_GLib_g_uri_unescape_string, MRB_ARGS_ARG(g_uri_unescape_string_REQUIRED_ARGC, g_uri_unescape_string_OPTIONAL_ARGC));
#endif
#if BIND_g_usleep_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_usleep", mrb_GLib_g_usleep, MRB_ARGS_ARG(g_usleep_REQUIRED_ARGC, g_usleep_OPTIONAL_ARGC));
#endif
#if BIND_g_utf16_to_ucs4_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf16_to_ucs4", mrb_GLib_g_utf16_to_ucs4, MRB_ARGS_ARG(g_utf16_to_ucs4_REQUIRED_ARGC, g_utf16_to_ucs4_OPTIONAL_ARGC));
#endif
#if BIND_g_utf16_to_utf8_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf16_to_utf8", mrb_GLib_g_utf16_to_utf8, MRB_ARGS_ARG(g_utf16_to_utf8_REQUIRED_ARGC, g_utf16_to_utf8_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_casefold_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_casefold", mrb_GLib_g_utf8_casefold, MRB_ARGS_ARG(g_utf8_casefold_REQUIRED_ARGC, g_utf8_casefold_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_collate_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_collate", mrb_GLib_g_utf8_collate, MRB_ARGS_ARG(g_utf8_collate_REQUIRED_ARGC, g_utf8_collate_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_collate_key_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_collate_key", mrb_GLib_g_utf8_collate_key, MRB_ARGS_ARG(g_utf8_collate_key_REQUIRED_ARGC, g_utf8_collate_key_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_collate_key_for_filename_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_collate_key_for_filename", mrb_GLib_g_utf8_collate_key_for_filename, MRB_ARGS_ARG(g_utf8_collate_key_for_filename_REQUIRED_ARGC, g_utf8_collate_key_for_filename_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_find_next_char_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_find_next_char", mrb_GLib_g_utf8_find_next_char, MRB_ARGS_ARG(g_utf8_find_next_char_REQUIRED_ARGC, g_utf8_find_next_char_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_find_prev_char_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_find_prev_char", mrb_GLib_g_utf8_find_prev_char, MRB_ARGS_ARG(g_utf8_find_prev_char_REQUIRED_ARGC, g_utf8_find_prev_char_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_get_char_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_get_char", mrb_GLib_g_utf8_get_char, MRB_ARGS_ARG(g_utf8_get_char_REQUIRED_ARGC, g_utf8_get_char_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_get_char_validated_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_get_char_validated", mrb_GLib_g_utf8_get_char_validated, MRB_ARGS_ARG(g_utf8_get_char_validated_REQUIRED_ARGC, g_utf8_get_char_validated_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_normalize_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_normalize", mrb_GLib_g_utf8_normalize, MRB_ARGS_ARG(g_utf8_normalize_REQUIRED_ARGC, g_utf8_normalize_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_offset_to_pointer_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_offset_to_pointer", mrb_GLib_g_utf8_offset_to_pointer, MRB_ARGS_ARG(g_utf8_offset_to_pointer_REQUIRED_ARGC, g_utf8_offset_to_pointer_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_pointer_to_offset_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_pointer_to_offset", mrb_GLib_g_utf8_pointer_to_offset, MRB_ARGS_ARG(g_utf8_pointer_to_offset_REQUIRED_ARGC, g_utf8_pointer_to_offset_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_prev_char_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_prev_char", mrb_GLib_g_utf8_prev_char, MRB_ARGS_ARG(g_utf8_prev_char_REQUIRED_ARGC, g_utf8_prev_char_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_strchr_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_strchr", mrb_GLib_g_utf8_strchr, MRB_ARGS_ARG(g_utf8_strchr_REQUIRED_ARGC, g_utf8_strchr_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_strdown_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_strdown", mrb_GLib_g_utf8_strdown, MRB_ARGS_ARG(g_utf8_strdown_REQUIRED_ARGC, g_utf8_strdown_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_strlen_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_strlen", mrb_GLib_g_utf8_strlen, MRB_ARGS_ARG(g_utf8_strlen_REQUIRED_ARGC, g_utf8_strlen_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_strncpy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_strncpy", mrb_GLib_g_utf8_strncpy, MRB_ARGS_ARG(g_utf8_strncpy_REQUIRED_ARGC, g_utf8_strncpy_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_strrchr_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_strrchr", mrb_GLib_g_utf8_strrchr, MRB_ARGS_ARG(g_utf8_strrchr_REQUIRED_ARGC, g_utf8_strrchr_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_strreverse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_strreverse", mrb_GLib_g_utf8_strreverse, MRB_ARGS_ARG(g_utf8_strreverse_REQUIRED_ARGC, g_utf8_strreverse_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_strup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_strup", mrb_GLib_g_utf8_strup, MRB_ARGS_ARG(g_utf8_strup_REQUIRED_ARGC, g_utf8_strup_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_substring_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_substring", mrb_GLib_g_utf8_substring, MRB_ARGS_ARG(g_utf8_substring_REQUIRED_ARGC, g_utf8_substring_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_to_ucs4_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_to_ucs4", mrb_GLib_g_utf8_to_ucs4, MRB_ARGS_ARG(g_utf8_to_ucs4_REQUIRED_ARGC, g_utf8_to_ucs4_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_to_ucs4_fast_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_to_ucs4_fast", mrb_GLib_g_utf8_to_ucs4_fast, MRB_ARGS_ARG(g_utf8_to_ucs4_fast_REQUIRED_ARGC, g_utf8_to_ucs4_fast_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_to_utf16_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_to_utf16", mrb_GLib_g_utf8_to_utf16, MRB_ARGS_ARG(g_utf8_to_utf16_REQUIRED_ARGC, g_utf8_to_utf16_OPTIONAL_ARGC));
#endif
#if BIND_g_utf8_validate_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_utf8_validate", mrb_GLib_g_utf8_validate, MRB_ARGS_ARG(g_utf8_validate_REQUIRED_ARGC, g_utf8_validate_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_add_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_add", mrb_GLib_g_variant_builder_add, MRB_ARGS_ARG(g_variant_builder_add_REQUIRED_ARGC, g_variant_builder_add_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_add_parsed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_add_parsed", mrb_GLib_g_variant_builder_add_parsed, MRB_ARGS_ARG(g_variant_builder_add_parsed_REQUIRED_ARGC, g_variant_builder_add_parsed_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_add_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_add_value", mrb_GLib_g_variant_builder_add_value, MRB_ARGS_ARG(g_variant_builder_add_value_REQUIRED_ARGC, g_variant_builder_add_value_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_clear", mrb_GLib_g_variant_builder_clear, MRB_ARGS_ARG(g_variant_builder_clear_REQUIRED_ARGC, g_variant_builder_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_close_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_close", mrb_GLib_g_variant_builder_close, MRB_ARGS_ARG(g_variant_builder_close_REQUIRED_ARGC, g_variant_builder_close_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_end_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_end", mrb_GLib_g_variant_builder_end, MRB_ARGS_ARG(g_variant_builder_end_REQUIRED_ARGC, g_variant_builder_end_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_init", mrb_GLib_g_variant_builder_init, MRB_ARGS_ARG(g_variant_builder_init_REQUIRED_ARGC, g_variant_builder_init_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_new", mrb_GLib_g_variant_builder_new, MRB_ARGS_ARG(g_variant_builder_new_REQUIRED_ARGC, g_variant_builder_new_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_open_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_open", mrb_GLib_g_variant_builder_open, MRB_ARGS_ARG(g_variant_builder_open_REQUIRED_ARGC, g_variant_builder_open_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_ref", mrb_GLib_g_variant_builder_ref, MRB_ARGS_ARG(g_variant_builder_ref_REQUIRED_ARGC, g_variant_builder_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_builder_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_builder_unref", mrb_GLib_g_variant_builder_unref, MRB_ARGS_ARG(g_variant_builder_unref_REQUIRED_ARGC, g_variant_builder_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_byteswap_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_byteswap", mrb_GLib_g_variant_byteswap, MRB_ARGS_ARG(g_variant_byteswap_REQUIRED_ARGC, g_variant_byteswap_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_check_format_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_check_format_string", mrb_GLib_g_variant_check_format_string, MRB_ARGS_ARG(g_variant_check_format_string_REQUIRED_ARGC, g_variant_check_format_string_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_classify_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_classify", mrb_GLib_g_variant_classify, MRB_ARGS_ARG(g_variant_classify_REQUIRED_ARGC, g_variant_classify_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_compare_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_compare", mrb_GLib_g_variant_compare, MRB_ARGS_ARG(g_variant_compare_REQUIRED_ARGC, g_variant_compare_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_clear_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_clear", mrb_GLib_g_variant_dict_clear, MRB_ARGS_ARG(g_variant_dict_clear_REQUIRED_ARGC, g_variant_dict_clear_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_contains_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_contains", mrb_GLib_g_variant_dict_contains, MRB_ARGS_ARG(g_variant_dict_contains_REQUIRED_ARGC, g_variant_dict_contains_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_end_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_end", mrb_GLib_g_variant_dict_end, MRB_ARGS_ARG(g_variant_dict_end_REQUIRED_ARGC, g_variant_dict_end_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_init", mrb_GLib_g_variant_dict_init, MRB_ARGS_ARG(g_variant_dict_init_REQUIRED_ARGC, g_variant_dict_init_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_insert_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_insert", mrb_GLib_g_variant_dict_insert, MRB_ARGS_ARG(g_variant_dict_insert_REQUIRED_ARGC, g_variant_dict_insert_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_insert_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_insert_value", mrb_GLib_g_variant_dict_insert_value, MRB_ARGS_ARG(g_variant_dict_insert_value_REQUIRED_ARGC, g_variant_dict_insert_value_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_lookup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_lookup", mrb_GLib_g_variant_dict_lookup, MRB_ARGS_ARG(g_variant_dict_lookup_REQUIRED_ARGC, g_variant_dict_lookup_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_lookup_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_lookup_value", mrb_GLib_g_variant_dict_lookup_value, MRB_ARGS_ARG(g_variant_dict_lookup_value_REQUIRED_ARGC, g_variant_dict_lookup_value_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_new", mrb_GLib_g_variant_dict_new, MRB_ARGS_ARG(g_variant_dict_new_REQUIRED_ARGC, g_variant_dict_new_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_ref", mrb_GLib_g_variant_dict_ref, MRB_ARGS_ARG(g_variant_dict_ref_REQUIRED_ARGC, g_variant_dict_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_remove_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_remove", mrb_GLib_g_variant_dict_remove, MRB_ARGS_ARG(g_variant_dict_remove_REQUIRED_ARGC, g_variant_dict_remove_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dict_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dict_unref", mrb_GLib_g_variant_dict_unref, MRB_ARGS_ARG(g_variant_dict_unref_REQUIRED_ARGC, g_variant_dict_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dup_bytestring_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dup_bytestring", mrb_GLib_g_variant_dup_bytestring, MRB_ARGS_ARG(g_variant_dup_bytestring_REQUIRED_ARGC, g_variant_dup_bytestring_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dup_bytestring_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dup_bytestring_array", mrb_GLib_g_variant_dup_bytestring_array, MRB_ARGS_ARG(g_variant_dup_bytestring_array_REQUIRED_ARGC, g_variant_dup_bytestring_array_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dup_objv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dup_objv", mrb_GLib_g_variant_dup_objv, MRB_ARGS_ARG(g_variant_dup_objv_REQUIRED_ARGC, g_variant_dup_objv_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dup_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dup_string", mrb_GLib_g_variant_dup_string, MRB_ARGS_ARG(g_variant_dup_string_REQUIRED_ARGC, g_variant_dup_string_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_dup_strv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_dup_strv", mrb_GLib_g_variant_dup_strv, MRB_ARGS_ARG(g_variant_dup_strv_REQUIRED_ARGC, g_variant_dup_strv_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_equal", mrb_GLib_g_variant_equal, MRB_ARGS_ARG(g_variant_equal_REQUIRED_ARGC, g_variant_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get", mrb_GLib_g_variant_get, MRB_ARGS_ARG(g_variant_get_REQUIRED_ARGC, g_variant_get_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_boolean_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_boolean", mrb_GLib_g_variant_get_boolean, MRB_ARGS_ARG(g_variant_get_boolean_REQUIRED_ARGC, g_variant_get_boolean_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_byte_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_byte", mrb_GLib_g_variant_get_byte, MRB_ARGS_ARG(g_variant_get_byte_REQUIRED_ARGC, g_variant_get_byte_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_bytestring_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_bytestring", mrb_GLib_g_variant_get_bytestring, MRB_ARGS_ARG(g_variant_get_bytestring_REQUIRED_ARGC, g_variant_get_bytestring_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_bytestring_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_bytestring_array", mrb_GLib_g_variant_get_bytestring_array, MRB_ARGS_ARG(g_variant_get_bytestring_array_REQUIRED_ARGC, g_variant_get_bytestring_array_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_child_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_child", mrb_GLib_g_variant_get_child, MRB_ARGS_ARG(g_variant_get_child_REQUIRED_ARGC, g_variant_get_child_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_child_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_child_value", mrb_GLib_g_variant_get_child_value, MRB_ARGS_ARG(g_variant_get_child_value_REQUIRED_ARGC, g_variant_get_child_value_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_data", mrb_GLib_g_variant_get_data, MRB_ARGS_ARG(g_variant_get_data_REQUIRED_ARGC, g_variant_get_data_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_data_as_bytes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_data_as_bytes", mrb_GLib_g_variant_get_data_as_bytes, MRB_ARGS_ARG(g_variant_get_data_as_bytes_REQUIRED_ARGC, g_variant_get_data_as_bytes_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_double_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_double", mrb_GLib_g_variant_get_double, MRB_ARGS_ARG(g_variant_get_double_REQUIRED_ARGC, g_variant_get_double_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_fixed_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_fixed_array", mrb_GLib_g_variant_get_fixed_array, MRB_ARGS_ARG(g_variant_get_fixed_array_REQUIRED_ARGC, g_variant_get_fixed_array_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_handle_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_handle", mrb_GLib_g_variant_get_handle, MRB_ARGS_ARG(g_variant_get_handle_REQUIRED_ARGC, g_variant_get_handle_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_int16_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_int16", mrb_GLib_g_variant_get_int16, MRB_ARGS_ARG(g_variant_get_int16_REQUIRED_ARGC, g_variant_get_int16_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_int32_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_int32", mrb_GLib_g_variant_get_int32, MRB_ARGS_ARG(g_variant_get_int32_REQUIRED_ARGC, g_variant_get_int32_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_int64_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_int64", mrb_GLib_g_variant_get_int64, MRB_ARGS_ARG(g_variant_get_int64_REQUIRED_ARGC, g_variant_get_int64_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_maybe_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_maybe", mrb_GLib_g_variant_get_maybe, MRB_ARGS_ARG(g_variant_get_maybe_REQUIRED_ARGC, g_variant_get_maybe_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_normal_form_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_normal_form", mrb_GLib_g_variant_get_normal_form, MRB_ARGS_ARG(g_variant_get_normal_form_REQUIRED_ARGC, g_variant_get_normal_form_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_objv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_objv", mrb_GLib_g_variant_get_objv, MRB_ARGS_ARG(g_variant_get_objv_REQUIRED_ARGC, g_variant_get_objv_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_size_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_size", mrb_GLib_g_variant_get_size, MRB_ARGS_ARG(g_variant_get_size_REQUIRED_ARGC, g_variant_get_size_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_string", mrb_GLib_g_variant_get_string, MRB_ARGS_ARG(g_variant_get_string_REQUIRED_ARGC, g_variant_get_string_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_strv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_strv", mrb_GLib_g_variant_get_strv, MRB_ARGS_ARG(g_variant_get_strv_REQUIRED_ARGC, g_variant_get_strv_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_type_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_type", mrb_GLib_g_variant_get_type, MRB_ARGS_ARG(g_variant_get_type_REQUIRED_ARGC, g_variant_get_type_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_type_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_type_string", mrb_GLib_g_variant_get_type_string, MRB_ARGS_ARG(g_variant_get_type_string_REQUIRED_ARGC, g_variant_get_type_string_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_uint16_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_uint16", mrb_GLib_g_variant_get_uint16, MRB_ARGS_ARG(g_variant_get_uint16_REQUIRED_ARGC, g_variant_get_uint16_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_uint32_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_uint32", mrb_GLib_g_variant_get_uint32, MRB_ARGS_ARG(g_variant_get_uint32_REQUIRED_ARGC, g_variant_get_uint32_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_uint64_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_uint64", mrb_GLib_g_variant_get_uint64, MRB_ARGS_ARG(g_variant_get_uint64_REQUIRED_ARGC, g_variant_get_uint64_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_va_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_va", mrb_GLib_g_variant_get_va, MRB_ARGS_ARG(g_variant_get_va_REQUIRED_ARGC, g_variant_get_va_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_get_variant_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_get_variant", mrb_GLib_g_variant_get_variant, MRB_ARGS_ARG(g_variant_get_variant_REQUIRED_ARGC, g_variant_get_variant_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_hash_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_hash", mrb_GLib_g_variant_hash, MRB_ARGS_ARG(g_variant_hash_REQUIRED_ARGC, g_variant_hash_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_is_container_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_is_container", mrb_GLib_g_variant_is_container, MRB_ARGS_ARG(g_variant_is_container_REQUIRED_ARGC, g_variant_is_container_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_is_floating_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_is_floating", mrb_GLib_g_variant_is_floating, MRB_ARGS_ARG(g_variant_is_floating_REQUIRED_ARGC, g_variant_is_floating_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_is_normal_form_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_is_normal_form", mrb_GLib_g_variant_is_normal_form, MRB_ARGS_ARG(g_variant_is_normal_form_REQUIRED_ARGC, g_variant_is_normal_form_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_is_object_path_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_is_object_path", mrb_GLib_g_variant_is_object_path, MRB_ARGS_ARG(g_variant_is_object_path_REQUIRED_ARGC, g_variant_is_object_path_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_is_of_type_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_is_of_type", mrb_GLib_g_variant_is_of_type, MRB_ARGS_ARG(g_variant_is_of_type_REQUIRED_ARGC, g_variant_is_of_type_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_is_signature_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_is_signature", mrb_GLib_g_variant_is_signature, MRB_ARGS_ARG(g_variant_is_signature_REQUIRED_ARGC, g_variant_is_signature_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_iter_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_iter_copy", mrb_GLib_g_variant_iter_copy, MRB_ARGS_ARG(g_variant_iter_copy_REQUIRED_ARGC, g_variant_iter_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_iter_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_iter_free", mrb_GLib_g_variant_iter_free, MRB_ARGS_ARG(g_variant_iter_free_REQUIRED_ARGC, g_variant_iter_free_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_iter_init_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_iter_init", mrb_GLib_g_variant_iter_init, MRB_ARGS_ARG(g_variant_iter_init_REQUIRED_ARGC, g_variant_iter_init_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_iter_loop_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_iter_loop", mrb_GLib_g_variant_iter_loop, MRB_ARGS_ARG(g_variant_iter_loop_REQUIRED_ARGC, g_variant_iter_loop_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_iter_n_children_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_iter_n_children", mrb_GLib_g_variant_iter_n_children, MRB_ARGS_ARG(g_variant_iter_n_children_REQUIRED_ARGC, g_variant_iter_n_children_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_iter_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_iter_new", mrb_GLib_g_variant_iter_new, MRB_ARGS_ARG(g_variant_iter_new_REQUIRED_ARGC, g_variant_iter_new_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_iter_next_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_iter_next", mrb_GLib_g_variant_iter_next, MRB_ARGS_ARG(g_variant_iter_next_REQUIRED_ARGC, g_variant_iter_next_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_iter_next_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_iter_next_value", mrb_GLib_g_variant_iter_next_value, MRB_ARGS_ARG(g_variant_iter_next_value_REQUIRED_ARGC, g_variant_iter_next_value_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_lookup_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_lookup", mrb_GLib_g_variant_lookup, MRB_ARGS_ARG(g_variant_lookup_REQUIRED_ARGC, g_variant_lookup_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_lookup_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_lookup_value", mrb_GLib_g_variant_lookup_value, MRB_ARGS_ARG(g_variant_lookup_value_REQUIRED_ARGC, g_variant_lookup_value_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_n_children_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_n_children", mrb_GLib_g_variant_n_children, MRB_ARGS_ARG(g_variant_n_children_REQUIRED_ARGC, g_variant_n_children_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new", mrb_GLib_g_variant_new, MRB_ARGS_ARG(g_variant_new_REQUIRED_ARGC, g_variant_new_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_array", mrb_GLib_g_variant_new_array, MRB_ARGS_ARG(g_variant_new_array_REQUIRED_ARGC, g_variant_new_array_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_boolean_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_boolean", mrb_GLib_g_variant_new_boolean, MRB_ARGS_ARG(g_variant_new_boolean_REQUIRED_ARGC, g_variant_new_boolean_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_byte_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_byte", mrb_GLib_g_variant_new_byte, MRB_ARGS_ARG(g_variant_new_byte_REQUIRED_ARGC, g_variant_new_byte_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_bytestring_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_bytestring", mrb_GLib_g_variant_new_bytestring, MRB_ARGS_ARG(g_variant_new_bytestring_REQUIRED_ARGC, g_variant_new_bytestring_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_bytestring_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_bytestring_array", mrb_GLib_g_variant_new_bytestring_array, MRB_ARGS_ARG(g_variant_new_bytestring_array_REQUIRED_ARGC, g_variant_new_bytestring_array_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_dict_entry_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_dict_entry", mrb_GLib_g_variant_new_dict_entry, MRB_ARGS_ARG(g_variant_new_dict_entry_REQUIRED_ARGC, g_variant_new_dict_entry_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_double_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_double", mrb_GLib_g_variant_new_double, MRB_ARGS_ARG(g_variant_new_double_REQUIRED_ARGC, g_variant_new_double_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_fixed_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_fixed_array", mrb_GLib_g_variant_new_fixed_array, MRB_ARGS_ARG(g_variant_new_fixed_array_REQUIRED_ARGC, g_variant_new_fixed_array_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_from_bytes_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_from_bytes", mrb_GLib_g_variant_new_from_bytes, MRB_ARGS_ARG(g_variant_new_from_bytes_REQUIRED_ARGC, g_variant_new_from_bytes_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_from_data_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_from_data", mrb_GLib_g_variant_new_from_data, MRB_ARGS_ARG(g_variant_new_from_data_REQUIRED_ARGC, g_variant_new_from_data_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_handle_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_handle", mrb_GLib_g_variant_new_handle, MRB_ARGS_ARG(g_variant_new_handle_REQUIRED_ARGC, g_variant_new_handle_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_int16_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_int16", mrb_GLib_g_variant_new_int16, MRB_ARGS_ARG(g_variant_new_int16_REQUIRED_ARGC, g_variant_new_int16_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_int32_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_int32", mrb_GLib_g_variant_new_int32, MRB_ARGS_ARG(g_variant_new_int32_REQUIRED_ARGC, g_variant_new_int32_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_int64_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_int64", mrb_GLib_g_variant_new_int64, MRB_ARGS_ARG(g_variant_new_int64_REQUIRED_ARGC, g_variant_new_int64_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_maybe_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_maybe", mrb_GLib_g_variant_new_maybe, MRB_ARGS_ARG(g_variant_new_maybe_REQUIRED_ARGC, g_variant_new_maybe_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_object_path_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_object_path", mrb_GLib_g_variant_new_object_path, MRB_ARGS_ARG(g_variant_new_object_path_REQUIRED_ARGC, g_variant_new_object_path_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_objv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_objv", mrb_GLib_g_variant_new_objv, MRB_ARGS_ARG(g_variant_new_objv_REQUIRED_ARGC, g_variant_new_objv_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_parsed_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_parsed", mrb_GLib_g_variant_new_parsed, MRB_ARGS_ARG(g_variant_new_parsed_REQUIRED_ARGC, g_variant_new_parsed_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_parsed_va_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_parsed_va", mrb_GLib_g_variant_new_parsed_va, MRB_ARGS_ARG(g_variant_new_parsed_va_REQUIRED_ARGC, g_variant_new_parsed_va_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_printf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_printf", mrb_GLib_g_variant_new_printf, MRB_ARGS_ARG(g_variant_new_printf_REQUIRED_ARGC, g_variant_new_printf_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_signature_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_signature", mrb_GLib_g_variant_new_signature, MRB_ARGS_ARG(g_variant_new_signature_REQUIRED_ARGC, g_variant_new_signature_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_string", mrb_GLib_g_variant_new_string, MRB_ARGS_ARG(g_variant_new_string_REQUIRED_ARGC, g_variant_new_string_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_strv_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_strv", mrb_GLib_g_variant_new_strv, MRB_ARGS_ARG(g_variant_new_strv_REQUIRED_ARGC, g_variant_new_strv_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_take_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_take_string", mrb_GLib_g_variant_new_take_string, MRB_ARGS_ARG(g_variant_new_take_string_REQUIRED_ARGC, g_variant_new_take_string_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_tuple_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_tuple", mrb_GLib_g_variant_new_tuple, MRB_ARGS_ARG(g_variant_new_tuple_REQUIRED_ARGC, g_variant_new_tuple_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_uint16_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_uint16", mrb_GLib_g_variant_new_uint16, MRB_ARGS_ARG(g_variant_new_uint16_REQUIRED_ARGC, g_variant_new_uint16_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_uint32_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_uint32", mrb_GLib_g_variant_new_uint32, MRB_ARGS_ARG(g_variant_new_uint32_REQUIRED_ARGC, g_variant_new_uint32_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_uint64_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_uint64", mrb_GLib_g_variant_new_uint64, MRB_ARGS_ARG(g_variant_new_uint64_REQUIRED_ARGC, g_variant_new_uint64_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_va_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_va", mrb_GLib_g_variant_new_va, MRB_ARGS_ARG(g_variant_new_va_REQUIRED_ARGC, g_variant_new_va_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_new_variant_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_new_variant", mrb_GLib_g_variant_new_variant, MRB_ARGS_ARG(g_variant_new_variant_REQUIRED_ARGC, g_variant_new_variant_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_parse_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_parse", mrb_GLib_g_variant_parse, MRB_ARGS_ARG(g_variant_parse_REQUIRED_ARGC, g_variant_parse_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_parse_error_print_context_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_parse_error_print_context", mrb_GLib_g_variant_parse_error_print_context, MRB_ARGS_ARG(g_variant_parse_error_print_context_REQUIRED_ARGC, g_variant_parse_error_print_context_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_parse_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_parse_error_quark", mrb_GLib_g_variant_parse_error_quark, MRB_ARGS_ARG(g_variant_parse_error_quark_REQUIRED_ARGC, g_variant_parse_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_parser_get_error_quark_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_parser_get_error_quark", mrb_GLib_g_variant_parser_get_error_quark, MRB_ARGS_ARG(g_variant_parser_get_error_quark_REQUIRED_ARGC, g_variant_parser_get_error_quark_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_print_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_print", mrb_GLib_g_variant_print, MRB_ARGS_ARG(g_variant_print_REQUIRED_ARGC, g_variant_print_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_print_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_print_string", mrb_GLib_g_variant_print_string, MRB_ARGS_ARG(g_variant_print_string_REQUIRED_ARGC, g_variant_print_string_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_ref", mrb_GLib_g_variant_ref, MRB_ARGS_ARG(g_variant_ref_REQUIRED_ARGC, g_variant_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_ref_sink_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_ref_sink", mrb_GLib_g_variant_ref_sink, MRB_ARGS_ARG(g_variant_ref_sink_REQUIRED_ARGC, g_variant_ref_sink_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_store_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_store", mrb_GLib_g_variant_store, MRB_ARGS_ARG(g_variant_store_REQUIRED_ARGC, g_variant_store_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_take_ref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_take_ref", mrb_GLib_g_variant_take_ref, MRB_ARGS_ARG(g_variant_take_ref_REQUIRED_ARGC, g_variant_take_ref_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_checked__FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_checked_", mrb_GLib_g_variant_type_checked_, MRB_ARGS_ARG(g_variant_type_checked__REQUIRED_ARGC, g_variant_type_checked__OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_copy_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_copy", mrb_GLib_g_variant_type_copy, MRB_ARGS_ARG(g_variant_type_copy_REQUIRED_ARGC, g_variant_type_copy_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_dup_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_dup_string", mrb_GLib_g_variant_type_dup_string, MRB_ARGS_ARG(g_variant_type_dup_string_REQUIRED_ARGC, g_variant_type_dup_string_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_element_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_element", mrb_GLib_g_variant_type_element, MRB_ARGS_ARG(g_variant_type_element_REQUIRED_ARGC, g_variant_type_element_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_equal_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_equal", mrb_GLib_g_variant_type_equal, MRB_ARGS_ARG(g_variant_type_equal_REQUIRED_ARGC, g_variant_type_equal_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_first_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_first", mrb_GLib_g_variant_type_first, MRB_ARGS_ARG(g_variant_type_first_REQUIRED_ARGC, g_variant_type_first_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_free_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_free", mrb_GLib_g_variant_type_free, MRB_ARGS_ARG(g_variant_type_free_REQUIRED_ARGC, g_variant_type_free_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_get_string_length_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_get_string_length", mrb_GLib_g_variant_type_get_string_length, MRB_ARGS_ARG(g_variant_type_get_string_length_REQUIRED_ARGC, g_variant_type_get_string_length_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_hash_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_hash", mrb_GLib_g_variant_type_hash, MRB_ARGS_ARG(g_variant_type_hash_REQUIRED_ARGC, g_variant_type_hash_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_is_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_is_array", mrb_GLib_g_variant_type_is_array, MRB_ARGS_ARG(g_variant_type_is_array_REQUIRED_ARGC, g_variant_type_is_array_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_is_basic_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_is_basic", mrb_GLib_g_variant_type_is_basic, MRB_ARGS_ARG(g_variant_type_is_basic_REQUIRED_ARGC, g_variant_type_is_basic_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_is_container_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_is_container", mrb_GLib_g_variant_type_is_container, MRB_ARGS_ARG(g_variant_type_is_container_REQUIRED_ARGC, g_variant_type_is_container_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_is_definite_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_is_definite", mrb_GLib_g_variant_type_is_definite, MRB_ARGS_ARG(g_variant_type_is_definite_REQUIRED_ARGC, g_variant_type_is_definite_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_is_dict_entry_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_is_dict_entry", mrb_GLib_g_variant_type_is_dict_entry, MRB_ARGS_ARG(g_variant_type_is_dict_entry_REQUIRED_ARGC, g_variant_type_is_dict_entry_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_is_maybe_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_is_maybe", mrb_GLib_g_variant_type_is_maybe, MRB_ARGS_ARG(g_variant_type_is_maybe_REQUIRED_ARGC, g_variant_type_is_maybe_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_is_subtype_of_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_is_subtype_of", mrb_GLib_g_variant_type_is_subtype_of, MRB_ARGS_ARG(g_variant_type_is_subtype_of_REQUIRED_ARGC, g_variant_type_is_subtype_of_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_is_tuple_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_is_tuple", mrb_GLib_g_variant_type_is_tuple, MRB_ARGS_ARG(g_variant_type_is_tuple_REQUIRED_ARGC, g_variant_type_is_tuple_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_is_variant_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_is_variant", mrb_GLib_g_variant_type_is_variant, MRB_ARGS_ARG(g_variant_type_is_variant_REQUIRED_ARGC, g_variant_type_is_variant_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_key_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_key", mrb_GLib_g_variant_type_key, MRB_ARGS_ARG(g_variant_type_key_REQUIRED_ARGC, g_variant_type_key_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_n_items_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_n_items", mrb_GLib_g_variant_type_n_items, MRB_ARGS_ARG(g_variant_type_n_items_REQUIRED_ARGC, g_variant_type_n_items_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_new_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_new", mrb_GLib_g_variant_type_new, MRB_ARGS_ARG(g_variant_type_new_REQUIRED_ARGC, g_variant_type_new_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_new_array_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_new_array", mrb_GLib_g_variant_type_new_array, MRB_ARGS_ARG(g_variant_type_new_array_REQUIRED_ARGC, g_variant_type_new_array_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_new_dict_entry_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_new_dict_entry", mrb_GLib_g_variant_type_new_dict_entry, MRB_ARGS_ARG(g_variant_type_new_dict_entry_REQUIRED_ARGC, g_variant_type_new_dict_entry_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_new_maybe_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_new_maybe", mrb_GLib_g_variant_type_new_maybe, MRB_ARGS_ARG(g_variant_type_new_maybe_REQUIRED_ARGC, g_variant_type_new_maybe_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_new_tuple_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_new_tuple", mrb_GLib_g_variant_type_new_tuple, MRB_ARGS_ARG(g_variant_type_new_tuple_REQUIRED_ARGC, g_variant_type_new_tuple_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_next_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_next", mrb_GLib_g_variant_type_next, MRB_ARGS_ARG(g_variant_type_next_REQUIRED_ARGC, g_variant_type_next_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_peek_string_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_peek_string", mrb_GLib_g_variant_type_peek_string, MRB_ARGS_ARG(g_variant_type_peek_string_REQUIRED_ARGC, g_variant_type_peek_string_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_string_is_valid_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_string_is_valid", mrb_GLib_g_variant_type_string_is_valid, MRB_ARGS_ARG(g_variant_type_string_is_valid_REQUIRED_ARGC, g_variant_type_string_is_valid_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_string_scan_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_string_scan", mrb_GLib_g_variant_type_string_scan, MRB_ARGS_ARG(g_variant_type_string_scan_REQUIRED_ARGC, g_variant_type_string_scan_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_type_value_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_type_value", mrb_GLib_g_variant_type_value, MRB_ARGS_ARG(g_variant_type_value_REQUIRED_ARGC, g_variant_type_value_OPTIONAL_ARGC));
#endif
#if BIND_g_variant_unref_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_variant_unref", mrb_GLib_g_variant_unref, MRB_ARGS_ARG(g_variant_unref_REQUIRED_ARGC, g_variant_unref_OPTIONAL_ARGC));
#endif
#if BIND_g_vasprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_vasprintf", mrb_GLib_g_vasprintf, MRB_ARGS_ARG(g_vasprintf_REQUIRED_ARGC, g_vasprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_vfprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_vfprintf", mrb_GLib_g_vfprintf, MRB_ARGS_ARG(g_vfprintf_REQUIRED_ARGC, g_vfprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_vprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_vprintf", mrb_GLib_g_vprintf, MRB_ARGS_ARG(g_vprintf_REQUIRED_ARGC, g_vprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_vsnprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_vsnprintf", mrb_GLib_g_vsnprintf, MRB_ARGS_ARG(g_vsnprintf_REQUIRED_ARGC, g_vsnprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_vsprintf_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_vsprintf", mrb_GLib_g_vsprintf, MRB_ARGS_ARG(g_vsprintf_REQUIRED_ARGC, g_vsprintf_OPTIONAL_ARGC));
#endif
#if BIND_g_warn_message_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "g_warn_message", mrb_GLib_g_warn_message, MRB_ARGS_ARG(g_warn_message_REQUIRED_ARGC, g_warn_message_OPTIONAL_ARGC));
#endif
#if BIND_glib_check_version_FUNCTION
  mrb_define_class_method(mrb, GLib_module, "glib_check_version", mrb_GLib_glib_check_version, MRB_ARGS_ARG(glib_check_version_REQUIRED_ARGC, glib_check_version_OPTIONAL_ARGC));
#endif

}

void mrb_mruby_glib_gem_final(mrb_state* mrb){

}

#ifdef __cplusplus
}
#endif
